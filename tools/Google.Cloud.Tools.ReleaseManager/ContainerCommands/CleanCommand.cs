// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License"):
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using Google.Cloud.Tools.Common;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Google.Cloud.Tools.ReleaseManager.ContainerCommands;

/// <summary>
/// Removes generated APIs from a repo clone. Expected options:
/// - repo-root: path to the root of the clone
/// - api-path: path to the API to clean generated files from, e.g. google/cloud/functions/v2
///   This is optional; when omitted, all configured APIs are cleaned.
///   The special value of "none" means "clean non-API-specific files only".
/// </summary>
internal class CleanCommand : IContainerCommand
{
    public int Execute(Dictionary<string, string> options)
    {
        var repoRoot = options["repo-root"];
        var apiPath = options.GetValueOrDefault("api-path");
        var rootLayout = RootLayout.ForRepositoryRoot(repoRoot);
        var catalog = ApiCatalog.Load(rootLayout);

        List<ApiMetadata> apis;
        // No APIs, just clean non-API-specific.
        if (apiPath == "none")
        {
            apis = new();
        }
        else if (apiPath is not null)
        {
            apis = new List<ApiMetadata>();
            var targetApi = catalog.Apis.SingleOrDefault(api => api.ProtoPath == apiPath);
            if (targetApi is null)
            {
                Console.WriteLine($"API path '{apiPath}' is not configured for any API. Ignoring.");
            }
            else
            {
                apis.Add(targetApi);
            }
        }
        else
        {
            apis = catalog.Apis.ToList();
        }

        var nonSourceGenerator = new NonSourceGenerator(rootLayout);

        foreach (var api in apis)
        {
            CleanApiFiles(api);
        }
        Console.WriteLine($"Cleaning non-API-specific files");
        nonSourceGenerator.CleanNonApiFiles();
        return 0;

        void CleanApiFiles(ApiMetadata api)
        {
            Console.WriteLine($"Cleaning {api.Id}");
            var apiLayout = rootLayout.CreateGeneratorApiLayout(api);

            switch (api.Generator)
            {
                case GeneratorType.Proto:
                    // We don't generate any snippets for proto-only APIs.
                    DeleteGeneratedSource(apiLayout.ProductionDirectory);
                    break;
                case GeneratorType.Micro:
                    DeleteGeneratedSource(apiLayout.ProductionDirectory);
                    DeleteGeneratedSource(apiLayout.SnippetsDirectory);
                    DeleteGeneratedSource(apiLayout.GeneratedSnippetsDirectory);
                    if (Directory.Exists(apiLayout.GeneratedSnippetsDirectory))
                    {
                        DeleteAll(Directory.EnumerateFiles(apiLayout.GeneratedSnippetsDirectory, "*.json"));
                    }
                    File.Delete(Path.Combine(apiLayout.SourceDirectory, "gapic_metadata.json"));
                    break;
                default:
                    // We didn't generate any code, so we leave anything that's still there alone.
                    // Any project files which were generated will be deleted by nonSourceGenerator.
                    // Note that there may be other generated files, e.g. conformance tests, or the BigQuery
                    // separate generator - but they're not generated by GenerateApis.
                    break;
            }
            nonSourceGenerator.CleanApiFiles(api);
            PruneEmptyDirectories(apiLayout.SourceDirectory);

            void DeleteGeneratedSource(string directory)
            {
                if (Directory.Exists(directory))
                {
                    DeleteAll(Directory.EnumerateFiles(directory, "*.g.cs", SearchOption.AllDirectories));
                }
            }
        }
    }

    private static void DeleteAll(IEnumerable<string> files)
    {
        foreach (var file in files)
        {
            File.Delete(file);
        }
    }

    private static bool PruneEmptyDirectories(string directory)
    {
        bool allDirectoriesRemoved = true;
        // We go depth first, so it's easier to see what's left.
        foreach (var nested in Directory.GetDirectories(directory))
        {
            allDirectoriesRemoved &= PruneEmptyDirectories(nested);
        }
        var empty = allDirectoriesRemoved && Directory.GetFiles(directory).Length == 0;
        if (empty)
        {
            Directory.Delete(directory);
        }
        return empty;
    }
}
