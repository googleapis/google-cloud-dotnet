// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/cloud/automl/v1/image.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Cloud.AutoML.V1 {

  /// <summary>Holder for reflection information generated from google/cloud/automl/v1/image.proto</summary>
  public static partial class ImageReflection {

    #region Descriptor
    /// <summary>File descriptor for google/cloud/automl/v1/image.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ImageReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiJnb29nbGUvY2xvdWQvYXV0b21sL3YxL2ltYWdlLnByb3RvEhZnb29nbGUu",
            "Y2xvdWQuYXV0b21sLnYxGhxnb29nbGUvYXBpL2Fubm90YXRpb25zLnByb3Rv",
            "Ghlnb29nbGUvYXBpL3Jlc291cmNlLnByb3RvGixnb29nbGUvY2xvdWQvYXV0",
            "b21sL3YxL2Fubm90YXRpb25fc3BlYy5wcm90bxorZ29vZ2xlL2Nsb3VkL2F1",
            "dG9tbC92MS9jbGFzc2lmaWNhdGlvbi5wcm90bxofZ29vZ2xlL3Byb3RvYnVm",
            "L3RpbWVzdGFtcC5wcm90byJtCiJJbWFnZUNsYXNzaWZpY2F0aW9uRGF0YXNl",
            "dE1ldGFkYXRhEkcKE2NsYXNzaWZpY2F0aW9uX3R5cGUYASABKA4yKi5nb29n",
            "bGUuY2xvdWQuYXV0b21sLnYxLkNsYXNzaWZpY2F0aW9uVHlwZSIlCiNJbWFn",
            "ZU9iamVjdERldGVjdGlvbkRhdGFzZXRNZXRhZGF0YSLUAQogSW1hZ2VDbGFz",
            "c2lmaWNhdGlvbk1vZGVsTWV0YWRhdGESFQoNYmFzZV9tb2RlbF9pZBgBIAEo",
            "CRIlCh10cmFpbl9idWRnZXRfbWlsbGlfbm9kZV9ob3VycxgQIAEoAxIjCht0",
            "cmFpbl9jb3N0X21pbGxpX25vZGVfaG91cnMYESABKAMSEwoLc3RvcF9yZWFz",
            "b24YBSABKAkSEgoKbW9kZWxfdHlwZRgHIAEoCRIQCghub2RlX3FwcxgNIAEo",
            "ARISCgpub2RlX2NvdW50GA4gASgDIr4BCiFJbWFnZU9iamVjdERldGVjdGlv",
            "bk1vZGVsTWV0YWRhdGESEgoKbW9kZWxfdHlwZRgBIAEoCRISCgpub2RlX2Nv",
            "dW50GAMgASgDEhAKCG5vZGVfcXBzGAQgASgBEhMKC3N0b3BfcmVhc29uGAUg",
            "ASgJEiUKHXRyYWluX2J1ZGdldF9taWxsaV9ub2RlX2hvdXJzGAYgASgDEiMK",
            "G3RyYWluX2Nvc3RfbWlsbGlfbm9kZV9ob3VycxgHIAEoAyJACipJbWFnZUNs",
            "YXNzaWZpY2F0aW9uTW9kZWxEZXBsb3ltZW50TWV0YWRhdGESEgoKbm9kZV9j",
            "b3VudBgBIAEoAyJBCitJbWFnZU9iamVjdERldGVjdGlvbk1vZGVsRGVwbG95",
            "bWVudE1ldGFkYXRhEhIKCm5vZGVfY291bnQYASABKANCtgEKGmNvbS5nb29n",
            "bGUuY2xvdWQuYXV0b21sLnYxQgpJbWFnZVByb3RvUAFaPGdvb2dsZS5nb2xh",
            "bmcub3JnL2dlbnByb3RvL2dvb2dsZWFwaXMvY2xvdWQvYXV0b21sL3YxO2F1",
            "dG9tbKoCFkdvb2dsZS5DbG91ZC5BdXRvTUwuVjHKAhZHb29nbGVcQ2xvdWRc",
            "QXV0b01sXFYx6gIZR29vZ2xlOjpDbG91ZDo6QXV0b01MOjpWMWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.AnnotationsReflection.Descriptor, global::Google.Api.ResourceReflection.Descriptor, global::Google.Cloud.AutoML.V1.AnnotationSpecReflection.Descriptor, global::Google.Cloud.AutoML.V1.ClassificationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.AutoML.V1.ImageClassificationDatasetMetadata), global::Google.Cloud.AutoML.V1.ImageClassificationDatasetMetadata.Parser, new[]{ "ClassificationType" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.AutoML.V1.ImageObjectDetectionDatasetMetadata), global::Google.Cloud.AutoML.V1.ImageObjectDetectionDatasetMetadata.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.AutoML.V1.ImageClassificationModelMetadata), global::Google.Cloud.AutoML.V1.ImageClassificationModelMetadata.Parser, new[]{ "BaseModelId", "TrainBudgetMilliNodeHours", "TrainCostMilliNodeHours", "StopReason", "ModelType", "NodeQps", "NodeCount" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.AutoML.V1.ImageObjectDetectionModelMetadata), global::Google.Cloud.AutoML.V1.ImageObjectDetectionModelMetadata.Parser, new[]{ "ModelType", "NodeCount", "NodeQps", "StopReason", "TrainBudgetMilliNodeHours", "TrainCostMilliNodeHours" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.AutoML.V1.ImageClassificationModelDeploymentMetadata), global::Google.Cloud.AutoML.V1.ImageClassificationModelDeploymentMetadata.Parser, new[]{ "NodeCount" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.AutoML.V1.ImageObjectDetectionModelDeploymentMetadata), global::Google.Cloud.AutoML.V1.ImageObjectDetectionModelDeploymentMetadata.Parser, new[]{ "NodeCount" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Dataset metadata that is specific to image classification.
  /// </summary>
  public sealed partial class ImageClassificationDatasetMetadata : pb::IMessage<ImageClassificationDatasetMetadata> {
    private static readonly pb::MessageParser<ImageClassificationDatasetMetadata> _parser = new pb::MessageParser<ImageClassificationDatasetMetadata>(() => new ImageClassificationDatasetMetadata());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ImageClassificationDatasetMetadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.AutoML.V1.ImageReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageClassificationDatasetMetadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageClassificationDatasetMetadata(ImageClassificationDatasetMetadata other) : this() {
      classificationType_ = other.classificationType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageClassificationDatasetMetadata Clone() {
      return new ImageClassificationDatasetMetadata(this);
    }

    /// <summary>Field number for the "classification_type" field.</summary>
    public const int ClassificationTypeFieldNumber = 1;
    private global::Google.Cloud.AutoML.V1.ClassificationType classificationType_ = global::Google.Cloud.AutoML.V1.ClassificationType.Unspecified;
    /// <summary>
    /// Required. Type of the classification problem.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.AutoML.V1.ClassificationType ClassificationType {
      get { return classificationType_; }
      set {
        classificationType_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ImageClassificationDatasetMetadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ImageClassificationDatasetMetadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ClassificationType != other.ClassificationType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ClassificationType != global::Google.Cloud.AutoML.V1.ClassificationType.Unspecified) hash ^= ClassificationType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ClassificationType != global::Google.Cloud.AutoML.V1.ClassificationType.Unspecified) {
        output.WriteRawTag(8);
        output.WriteEnum((int) ClassificationType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ClassificationType != global::Google.Cloud.AutoML.V1.ClassificationType.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ClassificationType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ImageClassificationDatasetMetadata other) {
      if (other == null) {
        return;
      }
      if (other.ClassificationType != global::Google.Cloud.AutoML.V1.ClassificationType.Unspecified) {
        ClassificationType = other.ClassificationType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ClassificationType = (global::Google.Cloud.AutoML.V1.ClassificationType) input.ReadEnum();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Dataset metadata specific to image object detection.
  /// </summary>
  public sealed partial class ImageObjectDetectionDatasetMetadata : pb::IMessage<ImageObjectDetectionDatasetMetadata> {
    private static readonly pb::MessageParser<ImageObjectDetectionDatasetMetadata> _parser = new pb::MessageParser<ImageObjectDetectionDatasetMetadata>(() => new ImageObjectDetectionDatasetMetadata());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ImageObjectDetectionDatasetMetadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.AutoML.V1.ImageReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageObjectDetectionDatasetMetadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageObjectDetectionDatasetMetadata(ImageObjectDetectionDatasetMetadata other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageObjectDetectionDatasetMetadata Clone() {
      return new ImageObjectDetectionDatasetMetadata(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ImageObjectDetectionDatasetMetadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ImageObjectDetectionDatasetMetadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ImageObjectDetectionDatasetMetadata other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  /// <summary>
  /// Model metadata for image classification.
  /// </summary>
  public sealed partial class ImageClassificationModelMetadata : pb::IMessage<ImageClassificationModelMetadata> {
    private static readonly pb::MessageParser<ImageClassificationModelMetadata> _parser = new pb::MessageParser<ImageClassificationModelMetadata>(() => new ImageClassificationModelMetadata());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ImageClassificationModelMetadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.AutoML.V1.ImageReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageClassificationModelMetadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageClassificationModelMetadata(ImageClassificationModelMetadata other) : this() {
      baseModelId_ = other.baseModelId_;
      trainBudgetMilliNodeHours_ = other.trainBudgetMilliNodeHours_;
      trainCostMilliNodeHours_ = other.trainCostMilliNodeHours_;
      stopReason_ = other.stopReason_;
      modelType_ = other.modelType_;
      nodeQps_ = other.nodeQps_;
      nodeCount_ = other.nodeCount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageClassificationModelMetadata Clone() {
      return new ImageClassificationModelMetadata(this);
    }

    /// <summary>Field number for the "base_model_id" field.</summary>
    public const int BaseModelIdFieldNumber = 1;
    private string baseModelId_ = "";
    /// <summary>
    /// Optional. The ID of the `base` model. If it is specified, the new model
    /// will be created based on the `base` model. Otherwise, the new model will be
    /// created from scratch. The `base` model must be in the same
    /// `project` and `location` as the new model to create, and have the same
    /// `model_type`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string BaseModelId {
      get { return baseModelId_; }
      set {
        baseModelId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "train_budget_milli_node_hours" field.</summary>
    public const int TrainBudgetMilliNodeHoursFieldNumber = 16;
    private long trainBudgetMilliNodeHours_;
    /// <summary>
    /// The train budget of creating this model, expressed in milli node
    /// hours i.e. 1,000 value in this field means 1 node hour. The actual
    /// `train_cost` will be equal or less than this value. If further model
    /// training ceases to provide any improvements, it will stop without using
    /// full budget and the stop_reason will be `MODEL_CONVERGED`.
    /// Note, node_hour  = actual_hour * number_of_nodes_invovled.
    /// For model type `cloud`(default), the train budget must be between 8,000
    /// and 800,000 milli node hours, inclusive. The default value is 192, 000
    /// which represents one day in wall time. For model type
    /// `mobile-low-latency-1`, `mobile-versatile-1`, `mobile-high-accuracy-1`,
    /// `mobile-core-ml-low-latency-1`, `mobile-core-ml-versatile-1`,
    /// `mobile-core-ml-high-accuracy-1`, the train budget must be between 1,000
    /// and 100,000 milli node hours, inclusive. The default value is 24, 000 which
    /// represents one day in wall time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TrainBudgetMilliNodeHours {
      get { return trainBudgetMilliNodeHours_; }
      set {
        trainBudgetMilliNodeHours_ = value;
      }
    }

    /// <summary>Field number for the "train_cost_milli_node_hours" field.</summary>
    public const int TrainCostMilliNodeHoursFieldNumber = 17;
    private long trainCostMilliNodeHours_;
    /// <summary>
    /// Output only. The actual train cost of creating this model, expressed in
    /// milli node hours, i.e. 1,000 value in this field means 1 node hour.
    /// Guaranteed to not exceed the train budget.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TrainCostMilliNodeHours {
      get { return trainCostMilliNodeHours_; }
      set {
        trainCostMilliNodeHours_ = value;
      }
    }

    /// <summary>Field number for the "stop_reason" field.</summary>
    public const int StopReasonFieldNumber = 5;
    private string stopReason_ = "";
    /// <summary>
    /// Output only. The reason that this create model operation stopped,
    /// e.g. `BUDGET_REACHED`, `MODEL_CONVERGED`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string StopReason {
      get { return stopReason_; }
      set {
        stopReason_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "model_type" field.</summary>
    public const int ModelTypeFieldNumber = 7;
    private string modelType_ = "";
    /// <summary>
    /// Optional. Type of the model. The available values are:
    /// *   `cloud` - Model to be used via prediction calls to AutoML API.
    ///               This is the default value.
    /// *   `mobile-low-latency-1` - A model that, in addition to providing
    ///               prediction via AutoML API, can also be exported (see
    ///               [AutoMl.ExportModel][google.cloud.automl.v1.AutoMl.ExportModel])
    ///               and used on a mobile or edge device with TensorFlow
    ///               afterwards. Expected to have low latency, but may have lower
    ///               prediction quality than other models.
    /// *   `mobile-versatile-1` - A model that, in addition to providing
    ///               prediction via AutoML API, can also be exported (see
    ///               [AutoMl.ExportModel][google.cloud.automl.v1.AutoMl.ExportModel])
    ///               and used on a mobile or edge device with TensorFlow
    ///               afterwards.
    /// *   `mobile-high-accuracy-1` - A model that, in addition to providing
    ///               prediction via AutoML API, can also be exported (see
    ///               [AutoMl.ExportModel][google.cloud.automl.v1.AutoMl.ExportModel])
    ///               and used on a mobile or edge device with TensorFlow
    ///               afterwards.  Expected to have a higher latency, but should
    ///               also have a higher prediction quality than other models.
    /// *   `mobile-core-ml-low-latency-1` - A model that, in addition to providing
    ///               prediction via AutoML API, can also be exported (see
    ///               [AutoMl.ExportModel][google.cloud.automl.v1.AutoMl.ExportModel])
    ///               and used on a mobile device with Core ML afterwards. Expected
    ///               to have low latency, but may have lower prediction quality
    ///               than other models.
    /// *   `mobile-core-ml-versatile-1` - A model that, in addition to providing
    ///               prediction via AutoML API, can also be exported (see
    ///               [AutoMl.ExportModel][google.cloud.automl.v1.AutoMl.ExportModel])
    ///               and used on a mobile device with Core ML afterwards.
    /// *   `mobile-core-ml-high-accuracy-1` - A model that, in addition to
    ///               providing prediction via AutoML API, can also be exported
    ///               (see
    ///               [AutoMl.ExportModel][google.cloud.automl.v1.AutoMl.ExportModel])
    ///               and used on a mobile device with Core ML afterwards. Expected
    ///               to have a higher latency, but should also have a higher
    ///               prediction quality than other models.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ModelType {
      get { return modelType_; }
      set {
        modelType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "node_qps" field.</summary>
    public const int NodeQpsFieldNumber = 13;
    private double nodeQps_;
    /// <summary>
    /// Output only. An approximate number of online prediction QPS that can
    /// be supported by this model per each node on which it is deployed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double NodeQps {
      get { return nodeQps_; }
      set {
        nodeQps_ = value;
      }
    }

    /// <summary>Field number for the "node_count" field.</summary>
    public const int NodeCountFieldNumber = 14;
    private long nodeCount_;
    /// <summary>
    /// Output only. The number of nodes this model is deployed on. A node is an
    /// abstraction of a machine resource, which can handle online prediction QPS
    /// as given in the node_qps field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long NodeCount {
      get { return nodeCount_; }
      set {
        nodeCount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ImageClassificationModelMetadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ImageClassificationModelMetadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BaseModelId != other.BaseModelId) return false;
      if (TrainBudgetMilliNodeHours != other.TrainBudgetMilliNodeHours) return false;
      if (TrainCostMilliNodeHours != other.TrainCostMilliNodeHours) return false;
      if (StopReason != other.StopReason) return false;
      if (ModelType != other.ModelType) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(NodeQps, other.NodeQps)) return false;
      if (NodeCount != other.NodeCount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BaseModelId.Length != 0) hash ^= BaseModelId.GetHashCode();
      if (TrainBudgetMilliNodeHours != 0L) hash ^= TrainBudgetMilliNodeHours.GetHashCode();
      if (TrainCostMilliNodeHours != 0L) hash ^= TrainCostMilliNodeHours.GetHashCode();
      if (StopReason.Length != 0) hash ^= StopReason.GetHashCode();
      if (ModelType.Length != 0) hash ^= ModelType.GetHashCode();
      if (NodeQps != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(NodeQps);
      if (NodeCount != 0L) hash ^= NodeCount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (BaseModelId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(BaseModelId);
      }
      if (StopReason.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(StopReason);
      }
      if (ModelType.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(ModelType);
      }
      if (NodeQps != 0D) {
        output.WriteRawTag(105);
        output.WriteDouble(NodeQps);
      }
      if (NodeCount != 0L) {
        output.WriteRawTag(112);
        output.WriteInt64(NodeCount);
      }
      if (TrainBudgetMilliNodeHours != 0L) {
        output.WriteRawTag(128, 1);
        output.WriteInt64(TrainBudgetMilliNodeHours);
      }
      if (TrainCostMilliNodeHours != 0L) {
        output.WriteRawTag(136, 1);
        output.WriteInt64(TrainCostMilliNodeHours);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BaseModelId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(BaseModelId);
      }
      if (TrainBudgetMilliNodeHours != 0L) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(TrainBudgetMilliNodeHours);
      }
      if (TrainCostMilliNodeHours != 0L) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(TrainCostMilliNodeHours);
      }
      if (StopReason.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StopReason);
      }
      if (ModelType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ModelType);
      }
      if (NodeQps != 0D) {
        size += 1 + 8;
      }
      if (NodeCount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(NodeCount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ImageClassificationModelMetadata other) {
      if (other == null) {
        return;
      }
      if (other.BaseModelId.Length != 0) {
        BaseModelId = other.BaseModelId;
      }
      if (other.TrainBudgetMilliNodeHours != 0L) {
        TrainBudgetMilliNodeHours = other.TrainBudgetMilliNodeHours;
      }
      if (other.TrainCostMilliNodeHours != 0L) {
        TrainCostMilliNodeHours = other.TrainCostMilliNodeHours;
      }
      if (other.StopReason.Length != 0) {
        StopReason = other.StopReason;
      }
      if (other.ModelType.Length != 0) {
        ModelType = other.ModelType;
      }
      if (other.NodeQps != 0D) {
        NodeQps = other.NodeQps;
      }
      if (other.NodeCount != 0L) {
        NodeCount = other.NodeCount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            BaseModelId = input.ReadString();
            break;
          }
          case 42: {
            StopReason = input.ReadString();
            break;
          }
          case 58: {
            ModelType = input.ReadString();
            break;
          }
          case 105: {
            NodeQps = input.ReadDouble();
            break;
          }
          case 112: {
            NodeCount = input.ReadInt64();
            break;
          }
          case 128: {
            TrainBudgetMilliNodeHours = input.ReadInt64();
            break;
          }
          case 136: {
            TrainCostMilliNodeHours = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Model metadata specific to image object detection.
  /// </summary>
  public sealed partial class ImageObjectDetectionModelMetadata : pb::IMessage<ImageObjectDetectionModelMetadata> {
    private static readonly pb::MessageParser<ImageObjectDetectionModelMetadata> _parser = new pb::MessageParser<ImageObjectDetectionModelMetadata>(() => new ImageObjectDetectionModelMetadata());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ImageObjectDetectionModelMetadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.AutoML.V1.ImageReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageObjectDetectionModelMetadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageObjectDetectionModelMetadata(ImageObjectDetectionModelMetadata other) : this() {
      modelType_ = other.modelType_;
      nodeCount_ = other.nodeCount_;
      nodeQps_ = other.nodeQps_;
      stopReason_ = other.stopReason_;
      trainBudgetMilliNodeHours_ = other.trainBudgetMilliNodeHours_;
      trainCostMilliNodeHours_ = other.trainCostMilliNodeHours_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageObjectDetectionModelMetadata Clone() {
      return new ImageObjectDetectionModelMetadata(this);
    }

    /// <summary>Field number for the "model_type" field.</summary>
    public const int ModelTypeFieldNumber = 1;
    private string modelType_ = "";
    /// <summary>
    /// Optional. Type of the model. The available values are:
    /// *   `cloud-high-accuracy-1` - (default) A model to be used via prediction
    ///               calls to AutoML API. Expected to have a higher latency, but
    ///               should also have a higher prediction quality than other
    ///               models.
    /// *   `cloud-low-latency-1` -  A model to be used via prediction
    ///               calls to AutoML API. Expected to have low latency, but may
    ///               have lower prediction quality than other models.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ModelType {
      get { return modelType_; }
      set {
        modelType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "node_count" field.</summary>
    public const int NodeCountFieldNumber = 3;
    private long nodeCount_;
    /// <summary>
    /// Output only. The number of nodes this model is deployed on. A node is an
    /// abstraction of a machine resource, which can handle online prediction QPS
    /// as given in the qps_per_node field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long NodeCount {
      get { return nodeCount_; }
      set {
        nodeCount_ = value;
      }
    }

    /// <summary>Field number for the "node_qps" field.</summary>
    public const int NodeQpsFieldNumber = 4;
    private double nodeQps_;
    /// <summary>
    /// Output only. An approximate number of online prediction QPS that can
    /// be supported by this model per each node on which it is deployed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double NodeQps {
      get { return nodeQps_; }
      set {
        nodeQps_ = value;
      }
    }

    /// <summary>Field number for the "stop_reason" field.</summary>
    public const int StopReasonFieldNumber = 5;
    private string stopReason_ = "";
    /// <summary>
    /// Output only. The reason that this create model operation stopped,
    /// e.g. `BUDGET_REACHED`, `MODEL_CONVERGED`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string StopReason {
      get { return stopReason_; }
      set {
        stopReason_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "train_budget_milli_node_hours" field.</summary>
    public const int TrainBudgetMilliNodeHoursFieldNumber = 6;
    private long trainBudgetMilliNodeHours_;
    /// <summary>
    /// The train budget of creating this model, expressed in milli node
    /// hours i.e. 1,000 value in this field means 1 node hour. The actual
    /// `train_cost` will be equal or less than this value. If further model
    /// training ceases to provide any improvements, it will stop without using
    /// full budget and the stop_reason will be `MODEL_CONVERGED`.
    /// Note, node_hour  = actual_hour * number_of_nodes_invovled.
    /// For model type `cloud-high-accuracy-1`(default) and `cloud-low-latency-1`,
    /// the train budget must be between 20,000 and 900,000 milli node hours,
    /// inclusive. The default value is 216, 000 which represents one day in
    /// wall time.
    /// For model type `mobile-low-latency-1`, `mobile-versatile-1`,
    /// `mobile-high-accuracy-1`, `mobile-core-ml-low-latency-1`,
    /// `mobile-core-ml-versatile-1`, `mobile-core-ml-high-accuracy-1`, the train
    /// budget must be between 1,000 and 100,000 milli node hours, inclusive.
    /// The default value is 24, 000 which represents one day in wall time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TrainBudgetMilliNodeHours {
      get { return trainBudgetMilliNodeHours_; }
      set {
        trainBudgetMilliNodeHours_ = value;
      }
    }

    /// <summary>Field number for the "train_cost_milli_node_hours" field.</summary>
    public const int TrainCostMilliNodeHoursFieldNumber = 7;
    private long trainCostMilliNodeHours_;
    /// <summary>
    /// Output only. The actual train cost of creating this model, expressed in
    /// milli node hours, i.e. 1,000 value in this field means 1 node hour.
    /// Guaranteed to not exceed the train budget.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TrainCostMilliNodeHours {
      get { return trainCostMilliNodeHours_; }
      set {
        trainCostMilliNodeHours_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ImageObjectDetectionModelMetadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ImageObjectDetectionModelMetadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ModelType != other.ModelType) return false;
      if (NodeCount != other.NodeCount) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(NodeQps, other.NodeQps)) return false;
      if (StopReason != other.StopReason) return false;
      if (TrainBudgetMilliNodeHours != other.TrainBudgetMilliNodeHours) return false;
      if (TrainCostMilliNodeHours != other.TrainCostMilliNodeHours) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ModelType.Length != 0) hash ^= ModelType.GetHashCode();
      if (NodeCount != 0L) hash ^= NodeCount.GetHashCode();
      if (NodeQps != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(NodeQps);
      if (StopReason.Length != 0) hash ^= StopReason.GetHashCode();
      if (TrainBudgetMilliNodeHours != 0L) hash ^= TrainBudgetMilliNodeHours.GetHashCode();
      if (TrainCostMilliNodeHours != 0L) hash ^= TrainCostMilliNodeHours.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ModelType.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(ModelType);
      }
      if (NodeCount != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(NodeCount);
      }
      if (NodeQps != 0D) {
        output.WriteRawTag(33);
        output.WriteDouble(NodeQps);
      }
      if (StopReason.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(StopReason);
      }
      if (TrainBudgetMilliNodeHours != 0L) {
        output.WriteRawTag(48);
        output.WriteInt64(TrainBudgetMilliNodeHours);
      }
      if (TrainCostMilliNodeHours != 0L) {
        output.WriteRawTag(56);
        output.WriteInt64(TrainCostMilliNodeHours);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ModelType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ModelType);
      }
      if (NodeCount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(NodeCount);
      }
      if (NodeQps != 0D) {
        size += 1 + 8;
      }
      if (StopReason.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StopReason);
      }
      if (TrainBudgetMilliNodeHours != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TrainBudgetMilliNodeHours);
      }
      if (TrainCostMilliNodeHours != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TrainCostMilliNodeHours);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ImageObjectDetectionModelMetadata other) {
      if (other == null) {
        return;
      }
      if (other.ModelType.Length != 0) {
        ModelType = other.ModelType;
      }
      if (other.NodeCount != 0L) {
        NodeCount = other.NodeCount;
      }
      if (other.NodeQps != 0D) {
        NodeQps = other.NodeQps;
      }
      if (other.StopReason.Length != 0) {
        StopReason = other.StopReason;
      }
      if (other.TrainBudgetMilliNodeHours != 0L) {
        TrainBudgetMilliNodeHours = other.TrainBudgetMilliNodeHours;
      }
      if (other.TrainCostMilliNodeHours != 0L) {
        TrainCostMilliNodeHours = other.TrainCostMilliNodeHours;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ModelType = input.ReadString();
            break;
          }
          case 24: {
            NodeCount = input.ReadInt64();
            break;
          }
          case 33: {
            NodeQps = input.ReadDouble();
            break;
          }
          case 42: {
            StopReason = input.ReadString();
            break;
          }
          case 48: {
            TrainBudgetMilliNodeHours = input.ReadInt64();
            break;
          }
          case 56: {
            TrainCostMilliNodeHours = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Model deployment metadata specific to Image Classification.
  /// </summary>
  public sealed partial class ImageClassificationModelDeploymentMetadata : pb::IMessage<ImageClassificationModelDeploymentMetadata> {
    private static readonly pb::MessageParser<ImageClassificationModelDeploymentMetadata> _parser = new pb::MessageParser<ImageClassificationModelDeploymentMetadata>(() => new ImageClassificationModelDeploymentMetadata());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ImageClassificationModelDeploymentMetadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.AutoML.V1.ImageReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageClassificationModelDeploymentMetadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageClassificationModelDeploymentMetadata(ImageClassificationModelDeploymentMetadata other) : this() {
      nodeCount_ = other.nodeCount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageClassificationModelDeploymentMetadata Clone() {
      return new ImageClassificationModelDeploymentMetadata(this);
    }

    /// <summary>Field number for the "node_count" field.</summary>
    public const int NodeCountFieldNumber = 1;
    private long nodeCount_;
    /// <summary>
    /// Input only. The number of nodes to deploy the model on. A node is an
    /// abstraction of a machine resource, which can handle online prediction QPS
    /// as given in the model's
    ///
    /// [node_qps][google.cloud.automl.v1.ImageClassificationModelMetadata.node_qps].
    /// Must be between 1 and 100, inclusive on both ends.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long NodeCount {
      get { return nodeCount_; }
      set {
        nodeCount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ImageClassificationModelDeploymentMetadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ImageClassificationModelDeploymentMetadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (NodeCount != other.NodeCount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (NodeCount != 0L) hash ^= NodeCount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (NodeCount != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(NodeCount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (NodeCount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(NodeCount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ImageClassificationModelDeploymentMetadata other) {
      if (other == null) {
        return;
      }
      if (other.NodeCount != 0L) {
        NodeCount = other.NodeCount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            NodeCount = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Model deployment metadata specific to Image Object Detection.
  /// </summary>
  public sealed partial class ImageObjectDetectionModelDeploymentMetadata : pb::IMessage<ImageObjectDetectionModelDeploymentMetadata> {
    private static readonly pb::MessageParser<ImageObjectDetectionModelDeploymentMetadata> _parser = new pb::MessageParser<ImageObjectDetectionModelDeploymentMetadata>(() => new ImageObjectDetectionModelDeploymentMetadata());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ImageObjectDetectionModelDeploymentMetadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.AutoML.V1.ImageReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageObjectDetectionModelDeploymentMetadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageObjectDetectionModelDeploymentMetadata(ImageObjectDetectionModelDeploymentMetadata other) : this() {
      nodeCount_ = other.nodeCount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageObjectDetectionModelDeploymentMetadata Clone() {
      return new ImageObjectDetectionModelDeploymentMetadata(this);
    }

    /// <summary>Field number for the "node_count" field.</summary>
    public const int NodeCountFieldNumber = 1;
    private long nodeCount_;
    /// <summary>
    /// Input only. The number of nodes to deploy the model on. A node is an
    /// abstraction of a machine resource, which can handle online prediction QPS
    /// as given in the model's
    ///
    /// [qps_per_node][google.cloud.automl.v1.ImageObjectDetectionModelMetadata.qps_per_node].
    /// Must be between 1 and 100, inclusive on both ends.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long NodeCount {
      get { return nodeCount_; }
      set {
        nodeCount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ImageObjectDetectionModelDeploymentMetadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ImageObjectDetectionModelDeploymentMetadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (NodeCount != other.NodeCount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (NodeCount != 0L) hash ^= NodeCount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (NodeCount != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(NodeCount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (NodeCount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(NodeCount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ImageObjectDetectionModelDeploymentMetadata other) {
      if (other == null) {
        return;
      }
      if (other.NodeCount != 0L) {
        NodeCount = other.NodeCount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            NodeCount = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
