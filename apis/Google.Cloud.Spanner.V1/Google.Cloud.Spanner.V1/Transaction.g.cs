// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/spanner/v1/transaction.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Cloud.Spanner.V1 {

  /// <summary>Holder for reflection information generated from google/spanner/v1/transaction.proto</summary>
  public static partial class TransactionReflection {

    #region Descriptor
    /// <summary>File descriptor for google/spanner/v1/transaction.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TransactionReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiNnb29nbGUvc3Bhbm5lci92MS90cmFuc2FjdGlvbi5wcm90bxIRZ29vZ2xl",
            "LnNwYW5uZXIudjEaH2dvb2dsZS9hcGkvZmllbGRfYmVoYXZpb3IucHJvdG8a",
            "Hmdvb2dsZS9wcm90b2J1Zi9kdXJhdGlvbi5wcm90bxofZ29vZ2xlL3Byb3Rv",
            "YnVmL3RpbWVzdGFtcC5wcm90byL3BwoSVHJhbnNhY3Rpb25PcHRpb25zEkUK",
            "CnJlYWRfd3JpdGUYASABKAsyLy5nb29nbGUuc3Bhbm5lci52MS5UcmFuc2Fj",
            "dGlvbk9wdGlvbnMuUmVhZFdyaXRlSAASTwoPcGFydGl0aW9uZWRfZG1sGAMg",
            "ASgLMjQuZ29vZ2xlLnNwYW5uZXIudjEuVHJhbnNhY3Rpb25PcHRpb25zLlBh",
            "cnRpdGlvbmVkRG1sSAASQwoJcmVhZF9vbmx5GAIgASgLMi4uZ29vZ2xlLnNw",
            "YW5uZXIudjEuVHJhbnNhY3Rpb25PcHRpb25zLlJlYWRPbmx5SAASJwofZXhj",
            "bHVkZV90eG5fZnJvbV9jaGFuZ2Vfc3RyZWFtcxgFIAEoCBJNCg9pc29sYXRp",
            "b25fbGV2ZWwYBiABKA4yNC5nb29nbGUuc3Bhbm5lci52MS5UcmFuc2FjdGlv",
            "bk9wdGlvbnMuSXNvbGF0aW9uTGV2ZWwa7AEKCVJlYWRXcml0ZRJUCg5yZWFk",
            "X2xvY2tfbW9kZRgBIAEoDjI8Lmdvb2dsZS5zcGFubmVyLnYxLlRyYW5zYWN0",
            "aW9uT3B0aW9ucy5SZWFkV3JpdGUuUmVhZExvY2tNb2RlEjgKK211bHRpcGxl",
            "eGVkX3Nlc3Npb25fcHJldmlvdXNfdHJhbnNhY3Rpb25faWQYAiABKAxCA+BB",
            "ASJPCgxSZWFkTG9ja01vZGUSHgoaUkVBRF9MT0NLX01PREVfVU5TUEVDSUZJ",
            "RUQQABIPCgtQRVNTSU1JU1RJQxABEg4KCk9QVElNSVNUSUMQAhoQCg5QYXJ0",
            "aXRpb25lZERtbBqoAgoIUmVhZE9ubHkSEAoGc3Ryb25nGAEgASgISAASOAoS",
            "bWluX3JlYWRfdGltZXN0YW1wGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRp",
            "bWVzdGFtcEgAEjIKDW1heF9zdGFsZW5lc3MYAyABKAsyGS5nb29nbGUucHJv",
            "dG9idWYuRHVyYXRpb25IABI0Cg5yZWFkX3RpbWVzdGFtcBgEIAEoCzIaLmdv",
            "b2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBIABI0Cg9leGFjdF9zdGFsZW5lc3MY",
            "BSABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb25IABIdChVyZXR1cm5f",
            "cmVhZF90aW1lc3RhbXAYBiABKAhCEQoPdGltZXN0YW1wX2JvdW5kIlgKDklz",
            "b2xhdGlvbkxldmVsEh8KG0lTT0xBVElPTl9MRVZFTF9VTlNQRUNJRklFRBAA",
            "EhAKDFNFUklBTElaQUJMRRABEhMKD1JFUEVBVEFCTEVfUkVBRBACQgYKBG1v",
            "ZGUimwEKC1RyYW5zYWN0aW9uEgoKAmlkGAEgASgMEjIKDnJlYWRfdGltZXN0",
            "YW1wGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBJMCg9wcmVj",
            "b21taXRfdG9rZW4YAyABKAsyMy5nb29nbGUuc3Bhbm5lci52MS5NdWx0aXBs",
            "ZXhlZFNlc3Npb25QcmVjb21taXRUb2tlbiKkAQoTVHJhbnNhY3Rpb25TZWxl",
            "Y3RvchI7CgpzaW5nbGVfdXNlGAEgASgLMiUuZ29vZ2xlLnNwYW5uZXIudjEu",
            "VHJhbnNhY3Rpb25PcHRpb25zSAASDAoCaWQYAiABKAxIABI2CgViZWdpbhgD",
            "IAEoCzIlLmdvb2dsZS5zcGFubmVyLnYxLlRyYW5zYWN0aW9uT3B0aW9uc0gA",
            "QgoKCHNlbGVjdG9yIkwKIE11bHRpcGxleGVkU2Vzc2lvblByZWNvbW1pdFRv",
            "a2VuEhcKD3ByZWNvbW1pdF90b2tlbhgBIAEoDBIPCgdzZXFfbnVtGAIgASgF",
            "QrMBChVjb20uZ29vZ2xlLnNwYW5uZXIudjFCEFRyYW5zYWN0aW9uUHJvdG9Q",
            "AVo1Y2xvdWQuZ29vZ2xlLmNvbS9nby9zcGFubmVyL2FwaXYxL3NwYW5uZXJw",
            "YjtzcGFubmVycGKqAhdHb29nbGUuQ2xvdWQuU3Bhbm5lci5WMcoCF0dvb2ds",
            "ZVxDbG91ZFxTcGFubmVyXFYx6gIaR29vZ2xlOjpDbG91ZDo6U3Bhbm5lcjo6",
            "VjFiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.FieldBehaviorReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Spanner.V1.TransactionOptions), global::Google.Cloud.Spanner.V1.TransactionOptions.Parser, new[]{ "ReadWrite", "PartitionedDml", "ReadOnly", "ExcludeTxnFromChangeStreams", "IsolationLevel" }, new[]{ "Mode" }, new[]{ typeof(global::Google.Cloud.Spanner.V1.TransactionOptions.Types.IsolationLevel) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite), global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite.Parser, new[]{ "ReadLockMode", "MultiplexedSessionPreviousTransactionId" }, null, new[]{ typeof(global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite.Types.ReadLockMode) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Spanner.V1.TransactionOptions.Types.PartitionedDml), global::Google.Cloud.Spanner.V1.TransactionOptions.Types.PartitionedDml.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadOnly), global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadOnly.Parser, new[]{ "Strong", "MinReadTimestamp", "MaxStaleness", "ReadTimestamp", "ExactStaleness", "ReturnReadTimestamp" }, new[]{ "TimestampBound" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Spanner.V1.Transaction), global::Google.Cloud.Spanner.V1.Transaction.Parser, new[]{ "Id", "ReadTimestamp", "PrecommitToken" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Spanner.V1.TransactionSelector), global::Google.Cloud.Spanner.V1.TransactionSelector.Parser, new[]{ "SingleUse", "Id", "Begin" }, new[]{ "Selector" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Spanner.V1.MultiplexedSessionPrecommitToken), global::Google.Cloud.Spanner.V1.MultiplexedSessionPrecommitToken.Parser, new[]{ "PrecommitToken", "SeqNum" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Transactions:
  ///
  /// Each session can have at most one active transaction at a time (note that
  /// standalone reads and queries use a transaction internally and do count
  /// towards the one transaction limit). After the active transaction is
  /// completed, the session can immediately be re-used for the next transaction.
  /// It is not necessary to create a new session for each transaction.
  ///
  /// Transaction modes:
  ///
  /// Cloud Spanner supports three transaction modes:
  ///
  ///   1. Locking read-write. This type of transaction is the only way
  ///      to write data into Cloud Spanner. These transactions rely on
  ///      pessimistic locking and, if necessary, two-phase commit.
  ///      Locking read-write transactions may abort, requiring the
  ///      application to retry.
  ///
  ///   2. Snapshot read-only. Snapshot read-only transactions provide guaranteed
  ///      consistency across several reads, but do not allow
  ///      writes. Snapshot read-only transactions can be configured to read at
  ///      timestamps in the past, or configured to perform a strong read
  ///      (where Spanner will select a timestamp such that the read is
  ///      guaranteed to see the effects of all transactions that have committed
  ///      before the start of the read). Snapshot read-only transactions do not
  ///      need to be committed.
  ///
  ///      Queries on change streams must be performed with the snapshot read-only
  ///      transaction mode, specifying a strong read. Please see
  ///      [TransactionOptions.ReadOnly.strong][google.spanner.v1.TransactionOptions.ReadOnly.strong]
  ///      for more details.
  ///
  ///   3. Partitioned DML. This type of transaction is used to execute
  ///      a single Partitioned DML statement. Partitioned DML partitions
  ///      the key space and runs the DML statement over each partition
  ///      in parallel using separate, internal transactions that commit
  ///      independently. Partitioned DML transactions do not need to be
  ///      committed.
  ///
  /// For transactions that only read, snapshot read-only transactions
  /// provide simpler semantics and are almost always faster. In
  /// particular, read-only transactions do not take locks, so they do
  /// not conflict with read-write transactions. As a consequence of not
  /// taking locks, they also do not abort, so retry loops are not needed.
  ///
  /// Transactions may only read-write data in a single database. They
  /// may, however, read-write data in different tables within that
  /// database.
  ///
  /// Locking read-write transactions:
  ///
  /// Locking transactions may be used to atomically read-modify-write
  /// data anywhere in a database. This type of transaction is externally
  /// consistent.
  ///
  /// Clients should attempt to minimize the amount of time a transaction
  /// is active. Faster transactions commit with higher probability
  /// and cause less contention. Cloud Spanner attempts to keep read locks
  /// active as long as the transaction continues to do reads, and the
  /// transaction has not been terminated by
  /// [Commit][google.spanner.v1.Spanner.Commit] or
  /// [Rollback][google.spanner.v1.Spanner.Rollback]. Long periods of
  /// inactivity at the client may cause Cloud Spanner to release a
  /// transaction's locks and abort it.
  ///
  /// Conceptually, a read-write transaction consists of zero or more
  /// reads or SQL statements followed by
  /// [Commit][google.spanner.v1.Spanner.Commit]. At any time before
  /// [Commit][google.spanner.v1.Spanner.Commit], the client can send a
  /// [Rollback][google.spanner.v1.Spanner.Rollback] request to abort the
  /// transaction.
  ///
  /// Semantics:
  ///
  /// Cloud Spanner can commit the transaction if all read locks it acquired
  /// are still valid at commit time, and it is able to acquire write
  /// locks for all writes. Cloud Spanner can abort the transaction for any
  /// reason. If a commit attempt returns `ABORTED`, Cloud Spanner guarantees
  /// that the transaction has not modified any user data in Cloud Spanner.
  ///
  /// Unless the transaction commits, Cloud Spanner makes no guarantees about
  /// how long the transaction's locks were held for. It is an error to
  /// use Cloud Spanner locks for any sort of mutual exclusion other than
  /// between Cloud Spanner transactions themselves.
  ///
  /// Retrying aborted transactions:
  ///
  /// When a transaction aborts, the application can choose to retry the
  /// whole transaction again. To maximize the chances of successfully
  /// committing the retry, the client should execute the retry in the
  /// same session as the original attempt. The original session's lock
  /// priority increases with each consecutive abort, meaning that each
  /// attempt has a slightly better chance of success than the previous.
  ///
  /// Under some circumstances (for example, many transactions attempting to
  /// modify the same row(s)), a transaction can abort many times in a
  /// short period before successfully committing. Thus, it is not a good
  /// idea to cap the number of retries a transaction can attempt;
  /// instead, it is better to limit the total amount of time spent
  /// retrying.
  ///
  /// Idle transactions:
  ///
  /// A transaction is considered idle if it has no outstanding reads or
  /// SQL queries and has not started a read or SQL query within the last 10
  /// seconds. Idle transactions can be aborted by Cloud Spanner so that they
  /// don't hold on to locks indefinitely. If an idle transaction is aborted, the
  /// commit will fail with error `ABORTED`.
  ///
  /// If this behavior is undesirable, periodically executing a simple
  /// SQL query in the transaction (for example, `SELECT 1`) prevents the
  /// transaction from becoming idle.
  ///
  /// Snapshot read-only transactions:
  ///
  /// Snapshot read-only transactions provides a simpler method than
  /// locking read-write transactions for doing several consistent
  /// reads. However, this type of transaction does not support writes.
  ///
  /// Snapshot transactions do not take locks. Instead, they work by
  /// choosing a Cloud Spanner timestamp, then executing all reads at that
  /// timestamp. Since they do not acquire locks, they do not block
  /// concurrent read-write transactions.
  ///
  /// Unlike locking read-write transactions, snapshot read-only
  /// transactions never abort. They can fail if the chosen read
  /// timestamp is garbage collected; however, the default garbage
  /// collection policy is generous enough that most applications do not
  /// need to worry about this in practice.
  ///
  /// Snapshot read-only transactions do not need to call
  /// [Commit][google.spanner.v1.Spanner.Commit] or
  /// [Rollback][google.spanner.v1.Spanner.Rollback] (and in fact are not
  /// permitted to do so).
  ///
  /// To execute a snapshot transaction, the client specifies a timestamp
  /// bound, which tells Cloud Spanner how to choose a read timestamp.
  ///
  /// The types of timestamp bound are:
  ///
  ///   - Strong (the default).
  ///   - Bounded staleness.
  ///   - Exact staleness.
  ///
  /// If the Cloud Spanner database to be read is geographically distributed,
  /// stale read-only transactions can execute more quickly than strong
  /// or read-write transactions, because they are able to execute far
  /// from the leader replica.
  ///
  /// Each type of timestamp bound is discussed in detail below.
  ///
  /// Strong: Strong reads are guaranteed to see the effects of all transactions
  /// that have committed before the start of the read. Furthermore, all
  /// rows yielded by a single read are consistent with each other -- if
  /// any part of the read observes a transaction, all parts of the read
  /// see the transaction.
  ///
  /// Strong reads are not repeatable: two consecutive strong read-only
  /// transactions might return inconsistent results if there are
  /// concurrent writes. If consistency across reads is required, the
  /// reads should be executed within a transaction or at an exact read
  /// timestamp.
  ///
  /// Queries on change streams (see below for more details) must also specify
  /// the strong read timestamp bound.
  ///
  /// See
  /// [TransactionOptions.ReadOnly.strong][google.spanner.v1.TransactionOptions.ReadOnly.strong].
  ///
  /// Exact staleness:
  ///
  /// These timestamp bounds execute reads at a user-specified
  /// timestamp. Reads at a timestamp are guaranteed to see a consistent
  /// prefix of the global transaction history: they observe
  /// modifications done by all transactions with a commit timestamp less than or
  /// equal to the read timestamp, and observe none of the modifications done by
  /// transactions with a larger commit timestamp. They will block until
  /// all conflicting transactions that may be assigned commit timestamps
  /// &lt;= the read timestamp have finished.
  ///
  /// The timestamp can either be expressed as an absolute Cloud Spanner commit
  /// timestamp or a staleness relative to the current time.
  ///
  /// These modes do not require a "negotiation phase" to pick a
  /// timestamp. As a result, they execute slightly faster than the
  /// equivalent boundedly stale concurrency modes. On the other hand,
  /// boundedly stale reads usually return fresher results.
  ///
  /// See
  /// [TransactionOptions.ReadOnly.read_timestamp][google.spanner.v1.TransactionOptions.ReadOnly.read_timestamp]
  /// and
  /// [TransactionOptions.ReadOnly.exact_staleness][google.spanner.v1.TransactionOptions.ReadOnly.exact_staleness].
  ///
  /// Bounded staleness:
  ///
  /// Bounded staleness modes allow Cloud Spanner to pick the read timestamp,
  /// subject to a user-provided staleness bound. Cloud Spanner chooses the
  /// newest timestamp within the staleness bound that allows execution
  /// of the reads at the closest available replica without blocking.
  ///
  /// All rows yielded are consistent with each other -- if any part of
  /// the read observes a transaction, all parts of the read see the
  /// transaction. Boundedly stale reads are not repeatable: two stale
  /// reads, even if they use the same staleness bound, can execute at
  /// different timestamps and thus return inconsistent results.
  ///
  /// Boundedly stale reads execute in two phases: the first phase
  /// negotiates a timestamp among all replicas needed to serve the
  /// read. In the second phase, reads are executed at the negotiated
  /// timestamp.
  ///
  /// As a result of the two phase execution, bounded staleness reads are
  /// usually a little slower than comparable exact staleness
  /// reads. However, they are typically able to return fresher
  /// results, and are more likely to execute at the closest replica.
  ///
  /// Because the timestamp negotiation requires up-front knowledge of
  /// which rows will be read, it can only be used with single-use
  /// read-only transactions.
  ///
  /// See
  /// [TransactionOptions.ReadOnly.max_staleness][google.spanner.v1.TransactionOptions.ReadOnly.max_staleness]
  /// and
  /// [TransactionOptions.ReadOnly.min_read_timestamp][google.spanner.v1.TransactionOptions.ReadOnly.min_read_timestamp].
  ///
  /// Old read timestamps and garbage collection:
  ///
  /// Cloud Spanner continuously garbage collects deleted and overwritten data
  /// in the background to reclaim storage space. This process is known
  /// as "version GC". By default, version GC reclaims versions after they
  /// are one hour old. Because of this, Cloud Spanner cannot perform reads
  /// at read timestamps more than one hour in the past. This
  /// restriction also applies to in-progress reads and/or SQL queries whose
  /// timestamp become too old while executing. Reads and SQL queries with
  /// too-old read timestamps fail with the error `FAILED_PRECONDITION`.
  ///
  /// You can configure and extend the `VERSION_RETENTION_PERIOD` of a
  /// database up to a period as long as one week, which allows Cloud Spanner
  /// to perform reads up to one week in the past.
  ///
  /// Querying change Streams:
  ///
  /// A Change Stream is a schema object that can be configured to watch data
  /// changes on the entire database, a set of tables, or a set of columns
  /// in a database.
  ///
  /// When a change stream is created, Spanner automatically defines a
  /// corresponding SQL Table-Valued Function (TVF) that can be used to query
  /// the change records in the associated change stream using the
  /// ExecuteStreamingSql API. The name of the TVF for a change stream is
  /// generated from the name of the change stream: READ_&lt;change_stream_name>.
  ///
  /// All queries on change stream TVFs must be executed using the
  /// ExecuteStreamingSql API with a single-use read-only transaction with a
  /// strong read-only timestamp_bound. The change stream TVF allows users to
  /// specify the start_timestamp and end_timestamp for the time range of
  /// interest. All change records within the retention period is accessible
  /// using the strong read-only timestamp_bound. All other TransactionOptions
  /// are invalid for change stream queries.
  ///
  /// In addition, if TransactionOptions.read_only.return_read_timestamp is set
  /// to true, a special value of 2^63 - 2 will be returned in the
  /// [Transaction][google.spanner.v1.Transaction] message that describes the
  /// transaction, instead of a valid read timestamp. This special value should be
  /// discarded and not used for any subsequent queries.
  ///
  /// Please see https://cloud.google.com/spanner/docs/change-streams
  /// for more details on how to query the change stream TVFs.
  ///
  /// Partitioned DML transactions:
  ///
  /// Partitioned DML transactions are used to execute DML statements with a
  /// different execution strategy that provides different, and often better,
  /// scalability properties for large, table-wide operations than DML in a
  /// ReadWrite transaction. Smaller scoped statements, such as an OLTP workload,
  /// should prefer using ReadWrite transactions.
  ///
  /// Partitioned DML partitions the keyspace and runs the DML statement on each
  /// partition in separate, internal transactions. These transactions commit
  /// automatically when complete, and run independently from one another.
  ///
  /// To reduce lock contention, this execution strategy only acquires read locks
  /// on rows that match the WHERE clause of the statement. Additionally, the
  /// smaller per-partition transactions hold locks for less time.
  ///
  /// That said, Partitioned DML is not a drop-in replacement for standard DML used
  /// in ReadWrite transactions.
  ///
  ///  - The DML statement must be fully-partitionable. Specifically, the statement
  ///    must be expressible as the union of many statements which each access only
  ///    a single row of the table.
  ///
  ///  - The statement is not applied atomically to all rows of the table. Rather,
  ///    the statement is applied atomically to partitions of the table, in
  ///    independent transactions. Secondary index rows are updated atomically
  ///    with the base table rows.
  ///
  ///  - Partitioned DML does not guarantee exactly-once execution semantics
  ///    against a partition. The statement will be applied at least once to each
  ///    partition. It is strongly recommended that the DML statement should be
  ///    idempotent to avoid unexpected results. For instance, it is potentially
  ///    dangerous to run a statement such as
  ///    `UPDATE table SET column = column + 1` as it could be run multiple times
  ///    against some rows.
  ///
  ///  - The partitions are committed automatically - there is no support for
  ///    Commit or Rollback. If the call returns an error, or if the client issuing
  ///    the ExecuteSql call dies, it is possible that some rows had the statement
  ///    executed on them successfully. It is also possible that statement was
  ///    never executed against other rows.
  ///
  ///  - Partitioned DML transactions may only contain the execution of a single
  ///    DML statement via ExecuteSql or ExecuteStreamingSql.
  ///
  ///  - If any error is encountered during the execution of the partitioned DML
  ///    operation (for instance, a UNIQUE INDEX violation, division by zero, or a
  ///    value that cannot be stored due to schema constraints), then the
  ///    operation is stopped at that point and an error is returned. It is
  ///    possible that at this point, some partitions have been committed (or even
  ///    committed multiple times), and other partitions have not been run at all.
  ///
  /// Given the above, Partitioned DML is good fit for large, database-wide,
  /// operations that are idempotent, such as deleting old rows from a very large
  /// table.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TransactionOptions : pb::IMessage<TransactionOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TransactionOptions> _parser = new pb::MessageParser<TransactionOptions>(() => new TransactionOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TransactionOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Spanner.V1.TransactionReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TransactionOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TransactionOptions(TransactionOptions other) : this() {
      excludeTxnFromChangeStreams_ = other.excludeTxnFromChangeStreams_;
      isolationLevel_ = other.isolationLevel_;
      switch (other.ModeCase) {
        case ModeOneofCase.ReadWrite:
          ReadWrite = other.ReadWrite.Clone();
          break;
        case ModeOneofCase.PartitionedDml:
          PartitionedDml = other.PartitionedDml.Clone();
          break;
        case ModeOneofCase.ReadOnly:
          ReadOnly = other.ReadOnly.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TransactionOptions Clone() {
      return new TransactionOptions(this);
    }

    /// <summary>Field number for the "read_write" field.</summary>
    public const int ReadWriteFieldNumber = 1;
    /// <summary>
    /// Transaction may write.
    ///
    /// Authorization to begin a read-write transaction requires
    /// `spanner.databases.beginOrRollbackReadWriteTransaction` permission
    /// on the `session` resource.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite ReadWrite {
      get { return modeCase_ == ModeOneofCase.ReadWrite ? (global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite) mode_ : null; }
      set {
        mode_ = value;
        modeCase_ = value == null ? ModeOneofCase.None : ModeOneofCase.ReadWrite;
      }
    }

    /// <summary>Field number for the "partitioned_dml" field.</summary>
    public const int PartitionedDmlFieldNumber = 3;
    /// <summary>
    /// Partitioned DML transaction.
    ///
    /// Authorization to begin a Partitioned DML transaction requires
    /// `spanner.databases.beginPartitionedDmlTransaction` permission
    /// on the `session` resource.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.Spanner.V1.TransactionOptions.Types.PartitionedDml PartitionedDml {
      get { return modeCase_ == ModeOneofCase.PartitionedDml ? (global::Google.Cloud.Spanner.V1.TransactionOptions.Types.PartitionedDml) mode_ : null; }
      set {
        mode_ = value;
        modeCase_ = value == null ? ModeOneofCase.None : ModeOneofCase.PartitionedDml;
      }
    }

    /// <summary>Field number for the "read_only" field.</summary>
    public const int ReadOnlyFieldNumber = 2;
    /// <summary>
    /// Transaction will not write.
    ///
    /// Authorization to begin a read-only transaction requires
    /// `spanner.databases.beginReadOnlyTransaction` permission
    /// on the `session` resource.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadOnly ReadOnly {
      get { return modeCase_ == ModeOneofCase.ReadOnly ? (global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadOnly) mode_ : null; }
      set {
        mode_ = value;
        modeCase_ = value == null ? ModeOneofCase.None : ModeOneofCase.ReadOnly;
      }
    }

    /// <summary>Field number for the "exclude_txn_from_change_streams" field.</summary>
    public const int ExcludeTxnFromChangeStreamsFieldNumber = 5;
    private bool excludeTxnFromChangeStreams_;
    /// <summary>
    /// When `exclude_txn_from_change_streams` is set to `true`:
    ///  * Mutations from this transaction will not be recorded in change streams
    ///  with DDL option `allow_txn_exclusion=true` that are tracking columns
    ///  modified by these transactions.
    ///  * Mutations from this transaction will be recorded in change streams with
    ///  DDL option `allow_txn_exclusion=false or not set` that are tracking
    ///  columns modified by these transactions.
    ///
    /// When `exclude_txn_from_change_streams` is set to `false` or not set,
    /// mutations from this transaction will be recorded in all change streams that
    /// are tracking columns modified by these transactions.
    /// `exclude_txn_from_change_streams` may only be specified for read-write or
    /// partitioned-dml transactions, otherwise the API will return an
    /// `INVALID_ARGUMENT` error.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ExcludeTxnFromChangeStreams {
      get { return excludeTxnFromChangeStreams_; }
      set {
        excludeTxnFromChangeStreams_ = value;
      }
    }

    /// <summary>Field number for the "isolation_level" field.</summary>
    public const int IsolationLevelFieldNumber = 6;
    private global::Google.Cloud.Spanner.V1.TransactionOptions.Types.IsolationLevel isolationLevel_ = global::Google.Cloud.Spanner.V1.TransactionOptions.Types.IsolationLevel.Unspecified;
    /// <summary>
    /// Isolation level for the transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.Spanner.V1.TransactionOptions.Types.IsolationLevel IsolationLevel {
      get { return isolationLevel_; }
      set {
        isolationLevel_ = value;
      }
    }

    private object mode_;
    /// <summary>Enum of possible cases for the "mode" oneof.</summary>
    public enum ModeOneofCase {
      None = 0,
      ReadWrite = 1,
      PartitionedDml = 3,
      ReadOnly = 2,
    }
    private ModeOneofCase modeCase_ = ModeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModeOneofCase ModeCase {
      get { return modeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMode() {
      modeCase_ = ModeOneofCase.None;
      mode_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TransactionOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TransactionOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ReadWrite, other.ReadWrite)) return false;
      if (!object.Equals(PartitionedDml, other.PartitionedDml)) return false;
      if (!object.Equals(ReadOnly, other.ReadOnly)) return false;
      if (ExcludeTxnFromChangeStreams != other.ExcludeTxnFromChangeStreams) return false;
      if (IsolationLevel != other.IsolationLevel) return false;
      if (ModeCase != other.ModeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (modeCase_ == ModeOneofCase.ReadWrite) hash ^= ReadWrite.GetHashCode();
      if (modeCase_ == ModeOneofCase.PartitionedDml) hash ^= PartitionedDml.GetHashCode();
      if (modeCase_ == ModeOneofCase.ReadOnly) hash ^= ReadOnly.GetHashCode();
      if (ExcludeTxnFromChangeStreams != false) hash ^= ExcludeTxnFromChangeStreams.GetHashCode();
      if (IsolationLevel != global::Google.Cloud.Spanner.V1.TransactionOptions.Types.IsolationLevel.Unspecified) hash ^= IsolationLevel.GetHashCode();
      hash ^= (int) modeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (modeCase_ == ModeOneofCase.ReadWrite) {
        output.WriteRawTag(10);
        output.WriteMessage(ReadWrite);
      }
      if (modeCase_ == ModeOneofCase.ReadOnly) {
        output.WriteRawTag(18);
        output.WriteMessage(ReadOnly);
      }
      if (modeCase_ == ModeOneofCase.PartitionedDml) {
        output.WriteRawTag(26);
        output.WriteMessage(PartitionedDml);
      }
      if (ExcludeTxnFromChangeStreams != false) {
        output.WriteRawTag(40);
        output.WriteBool(ExcludeTxnFromChangeStreams);
      }
      if (IsolationLevel != global::Google.Cloud.Spanner.V1.TransactionOptions.Types.IsolationLevel.Unspecified) {
        output.WriteRawTag(48);
        output.WriteEnum((int) IsolationLevel);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (modeCase_ == ModeOneofCase.ReadWrite) {
        output.WriteRawTag(10);
        output.WriteMessage(ReadWrite);
      }
      if (modeCase_ == ModeOneofCase.ReadOnly) {
        output.WriteRawTag(18);
        output.WriteMessage(ReadOnly);
      }
      if (modeCase_ == ModeOneofCase.PartitionedDml) {
        output.WriteRawTag(26);
        output.WriteMessage(PartitionedDml);
      }
      if (ExcludeTxnFromChangeStreams != false) {
        output.WriteRawTag(40);
        output.WriteBool(ExcludeTxnFromChangeStreams);
      }
      if (IsolationLevel != global::Google.Cloud.Spanner.V1.TransactionOptions.Types.IsolationLevel.Unspecified) {
        output.WriteRawTag(48);
        output.WriteEnum((int) IsolationLevel);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (modeCase_ == ModeOneofCase.ReadWrite) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReadWrite);
      }
      if (modeCase_ == ModeOneofCase.PartitionedDml) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PartitionedDml);
      }
      if (modeCase_ == ModeOneofCase.ReadOnly) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReadOnly);
      }
      if (ExcludeTxnFromChangeStreams != false) {
        size += 1 + 1;
      }
      if (IsolationLevel != global::Google.Cloud.Spanner.V1.TransactionOptions.Types.IsolationLevel.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) IsolationLevel);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TransactionOptions other) {
      if (other == null) {
        return;
      }
      if (other.ExcludeTxnFromChangeStreams != false) {
        ExcludeTxnFromChangeStreams = other.ExcludeTxnFromChangeStreams;
      }
      if (other.IsolationLevel != global::Google.Cloud.Spanner.V1.TransactionOptions.Types.IsolationLevel.Unspecified) {
        IsolationLevel = other.IsolationLevel;
      }
      switch (other.ModeCase) {
        case ModeOneofCase.ReadWrite:
          if (ReadWrite == null) {
            ReadWrite = new global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite();
          }
          ReadWrite.MergeFrom(other.ReadWrite);
          break;
        case ModeOneofCase.PartitionedDml:
          if (PartitionedDml == null) {
            PartitionedDml = new global::Google.Cloud.Spanner.V1.TransactionOptions.Types.PartitionedDml();
          }
          PartitionedDml.MergeFrom(other.PartitionedDml);
          break;
        case ModeOneofCase.ReadOnly:
          if (ReadOnly == null) {
            ReadOnly = new global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadOnly();
          }
          ReadOnly.MergeFrom(other.ReadOnly);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite subBuilder = new global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite();
            if (modeCase_ == ModeOneofCase.ReadWrite) {
              subBuilder.MergeFrom(ReadWrite);
            }
            input.ReadMessage(subBuilder);
            ReadWrite = subBuilder;
            break;
          }
          case 18: {
            global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadOnly subBuilder = new global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadOnly();
            if (modeCase_ == ModeOneofCase.ReadOnly) {
              subBuilder.MergeFrom(ReadOnly);
            }
            input.ReadMessage(subBuilder);
            ReadOnly = subBuilder;
            break;
          }
          case 26: {
            global::Google.Cloud.Spanner.V1.TransactionOptions.Types.PartitionedDml subBuilder = new global::Google.Cloud.Spanner.V1.TransactionOptions.Types.PartitionedDml();
            if (modeCase_ == ModeOneofCase.PartitionedDml) {
              subBuilder.MergeFrom(PartitionedDml);
            }
            input.ReadMessage(subBuilder);
            PartitionedDml = subBuilder;
            break;
          }
          case 40: {
            ExcludeTxnFromChangeStreams = input.ReadBool();
            break;
          }
          case 48: {
            IsolationLevel = (global::Google.Cloud.Spanner.V1.TransactionOptions.Types.IsolationLevel) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite subBuilder = new global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite();
            if (modeCase_ == ModeOneofCase.ReadWrite) {
              subBuilder.MergeFrom(ReadWrite);
            }
            input.ReadMessage(subBuilder);
            ReadWrite = subBuilder;
            break;
          }
          case 18: {
            global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadOnly subBuilder = new global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadOnly();
            if (modeCase_ == ModeOneofCase.ReadOnly) {
              subBuilder.MergeFrom(ReadOnly);
            }
            input.ReadMessage(subBuilder);
            ReadOnly = subBuilder;
            break;
          }
          case 26: {
            global::Google.Cloud.Spanner.V1.TransactionOptions.Types.PartitionedDml subBuilder = new global::Google.Cloud.Spanner.V1.TransactionOptions.Types.PartitionedDml();
            if (modeCase_ == ModeOneofCase.PartitionedDml) {
              subBuilder.MergeFrom(PartitionedDml);
            }
            input.ReadMessage(subBuilder);
            PartitionedDml = subBuilder;
            break;
          }
          case 40: {
            ExcludeTxnFromChangeStreams = input.ReadBool();
            break;
          }
          case 48: {
            IsolationLevel = (global::Google.Cloud.Spanner.V1.TransactionOptions.Types.IsolationLevel) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the TransactionOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// `IsolationLevel` is used when setting `isolation_level` for a transaction.
      /// </summary>
      public enum IsolationLevel {
        /// <summary>
        /// Default value.
        ///
        /// If the value is not specified, the `SERIALIZABLE` isolation level is
        /// used.
        /// </summary>
        [pbr::OriginalName("ISOLATION_LEVEL_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// All transactions appear as if they executed in a serial order, even if
        /// some of the reads, writes, and other operations of distinct transactions
        /// actually occurred in parallel. Spanner assigns commit timestamps that
        /// reflect the order of committed transactions to implement this property.
        /// Spanner offers a stronger guarantee than serializability called external
        /// consistency. For further details, please refer to
        /// https://cloud.google.com/spanner/docs/true-time-external-consistency#serializability.
        /// </summary>
        [pbr::OriginalName("SERIALIZABLE")] Serializable = 1,
        /// <summary>
        /// All reads performed during the transaction observe a consistent snapshot
        /// of the database, and the transaction will only successfully commit in the
        /// absence of conflicts between its updates and any concurrent updates that
        /// have occurred since that snapshot. Consequently, in contrast to
        /// `SERIALIZABLE` transactions, only write-write conflicts are detected in
        /// snapshot transactions.
        ///
        /// This isolation level does not support Read-only and Partitioned DML
        /// transactions.
        ///
        /// When `REPEATABLE_READ` is specified on a read-write transaction, the
        /// locking semantics default to `OPTIMISTIC`.
        /// </summary>
        [pbr::OriginalName("REPEATABLE_READ")] RepeatableRead = 2,
      }

      /// <summary>
      /// Message type to initiate a read-write transaction. Currently this
      /// transaction type has no options.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class ReadWrite : pb::IMessage<ReadWrite>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<ReadWrite> _parser = new pb::MessageParser<ReadWrite>(() => new ReadWrite());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<ReadWrite> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Spanner.V1.TransactionOptions.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ReadWrite() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ReadWrite(ReadWrite other) : this() {
          readLockMode_ = other.readLockMode_;
          multiplexedSessionPreviousTransactionId_ = other.multiplexedSessionPreviousTransactionId_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ReadWrite Clone() {
          return new ReadWrite(this);
        }

        /// <summary>Field number for the "read_lock_mode" field.</summary>
        public const int ReadLockModeFieldNumber = 1;
        private global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite.Types.ReadLockMode readLockMode_ = global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite.Types.ReadLockMode.Unspecified;
        /// <summary>
        /// Read lock mode for the transaction.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite.Types.ReadLockMode ReadLockMode {
          get { return readLockMode_; }
          set {
            readLockMode_ = value;
          }
        }

        /// <summary>Field number for the "multiplexed_session_previous_transaction_id" field.</summary>
        public const int MultiplexedSessionPreviousTransactionIdFieldNumber = 2;
        private pb::ByteString multiplexedSessionPreviousTransactionId_ = pb::ByteString.Empty;
        /// <summary>
        /// Optional. Clients should pass the transaction ID of the previous
        /// transaction attempt that was aborted if this transaction is being
        /// executed on a multiplexed session.
        /// This feature is not yet supported and will result in an UNIMPLEMENTED
        /// error.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pb::ByteString MultiplexedSessionPreviousTransactionId {
          get { return multiplexedSessionPreviousTransactionId_; }
          set {
            multiplexedSessionPreviousTransactionId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as ReadWrite);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(ReadWrite other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (ReadLockMode != other.ReadLockMode) return false;
          if (MultiplexedSessionPreviousTransactionId != other.MultiplexedSessionPreviousTransactionId) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (ReadLockMode != global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite.Types.ReadLockMode.Unspecified) hash ^= ReadLockMode.GetHashCode();
          if (MultiplexedSessionPreviousTransactionId.Length != 0) hash ^= MultiplexedSessionPreviousTransactionId.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (ReadLockMode != global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite.Types.ReadLockMode.Unspecified) {
            output.WriteRawTag(8);
            output.WriteEnum((int) ReadLockMode);
          }
          if (MultiplexedSessionPreviousTransactionId.Length != 0) {
            output.WriteRawTag(18);
            output.WriteBytes(MultiplexedSessionPreviousTransactionId);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (ReadLockMode != global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite.Types.ReadLockMode.Unspecified) {
            output.WriteRawTag(8);
            output.WriteEnum((int) ReadLockMode);
          }
          if (MultiplexedSessionPreviousTransactionId.Length != 0) {
            output.WriteRawTag(18);
            output.WriteBytes(MultiplexedSessionPreviousTransactionId);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (ReadLockMode != global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite.Types.ReadLockMode.Unspecified) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ReadLockMode);
          }
          if (MultiplexedSessionPreviousTransactionId.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeBytesSize(MultiplexedSessionPreviousTransactionId);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(ReadWrite other) {
          if (other == null) {
            return;
          }
          if (other.ReadLockMode != global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite.Types.ReadLockMode.Unspecified) {
            ReadLockMode = other.ReadLockMode;
          }
          if (other.MultiplexedSessionPreviousTransactionId.Length != 0) {
            MultiplexedSessionPreviousTransactionId = other.MultiplexedSessionPreviousTransactionId;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                ReadLockMode = (global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite.Types.ReadLockMode) input.ReadEnum();
                break;
              }
              case 18: {
                MultiplexedSessionPreviousTransactionId = input.ReadBytes();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                ReadLockMode = (global::Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite.Types.ReadLockMode) input.ReadEnum();
                break;
              }
              case 18: {
                MultiplexedSessionPreviousTransactionId = input.ReadBytes();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the ReadWrite message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// `ReadLockMode` is used to set the read lock mode for read-write
          /// transactions.
          /// </summary>
          public enum ReadLockMode {
            /// <summary>
            /// Default value.
            ///
            /// * If isolation level is `REPEATABLE_READ`, then it is an error to
            ///   specify `read_lock_mode`. Locking semantics default to `OPTIMISTIC`.
            ///   No validation checks are done for reads, except for:
            ///     1. reads done as part of queries that use `SELECT FOR UPDATE`
            ///     2. reads done as part of statements with a `LOCK_SCANNED_RANGES`
            ///        hint
            ///     3. reads done as part of DML statements
            ///   to validate that the data that was served at the snapshot time is
            ///   unchanged at commit time.
            /// * At all other isolation levels, if `read_lock_mode` is the default
            ///   value, then pessimistic read lock is used.
            /// </summary>
            [pbr::OriginalName("READ_LOCK_MODE_UNSPECIFIED")] Unspecified = 0,
            /// <summary>
            /// Pessimistic lock mode.
            ///
            /// Read locks are acquired immediately on read.
            /// Semantics described only applies to `SERIALIZABLE` isolation.
            /// </summary>
            [pbr::OriginalName("PESSIMISTIC")] Pessimistic = 1,
            /// <summary>
            /// Optimistic lock mode.
            ///
            /// Locks for reads within the transaction are not acquired on read.
            /// Instead the locks are acquired on a commit to validate that
            /// read/queried data has not changed since the transaction started.
            /// Semantics described only applies to `SERIALIZABLE` isolation.
            /// </summary>
            [pbr::OriginalName("OPTIMISTIC")] Optimistic = 2,
          }

        }
        #endregion

      }

      /// <summary>
      /// Message type to initiate a Partitioned DML transaction.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class PartitionedDml : pb::IMessage<PartitionedDml>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<PartitionedDml> _parser = new pb::MessageParser<PartitionedDml>(() => new PartitionedDml());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<PartitionedDml> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Spanner.V1.TransactionOptions.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PartitionedDml() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PartitionedDml(PartitionedDml other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PartitionedDml Clone() {
          return new PartitionedDml(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as PartitionedDml);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(PartitionedDml other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(PartitionedDml other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Message type to initiate a read-only transaction.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class ReadOnly : pb::IMessage<ReadOnly>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<ReadOnly> _parser = new pb::MessageParser<ReadOnly>(() => new ReadOnly());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<ReadOnly> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.Spanner.V1.TransactionOptions.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ReadOnly() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ReadOnly(ReadOnly other) : this() {
          returnReadTimestamp_ = other.returnReadTimestamp_;
          switch (other.TimestampBoundCase) {
            case TimestampBoundOneofCase.Strong:
              Strong = other.Strong;
              break;
            case TimestampBoundOneofCase.MinReadTimestamp:
              MinReadTimestamp = other.MinReadTimestamp.Clone();
              break;
            case TimestampBoundOneofCase.MaxStaleness:
              MaxStaleness = other.MaxStaleness.Clone();
              break;
            case TimestampBoundOneofCase.ReadTimestamp:
              ReadTimestamp = other.ReadTimestamp.Clone();
              break;
            case TimestampBoundOneofCase.ExactStaleness:
              ExactStaleness = other.ExactStaleness.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ReadOnly Clone() {
          return new ReadOnly(this);
        }

        /// <summary>Field number for the "strong" field.</summary>
        public const int StrongFieldNumber = 1;
        /// <summary>
        /// Read at a timestamp where all previously committed transactions
        /// are visible.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Strong {
          get { return HasStrong ? (bool) timestampBound_ : false; }
          set {
            timestampBound_ = value;
            timestampBoundCase_ = TimestampBoundOneofCase.Strong;
          }
        }
        /// <summary>Gets whether the "strong" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasStrong {
          get { return timestampBoundCase_ == TimestampBoundOneofCase.Strong; }
        }
        /// <summary> Clears the value of the oneof if it's currently set to "strong" </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearStrong() {
          if (HasStrong) {
            ClearTimestampBound();
          }
        }

        /// <summary>Field number for the "min_read_timestamp" field.</summary>
        public const int MinReadTimestampFieldNumber = 2;
        /// <summary>
        /// Executes all reads at a timestamp >= `min_read_timestamp`.
        ///
        /// This is useful for requesting fresher data than some previous
        /// read, or data that is fresh enough to observe the effects of some
        /// previously committed transaction whose timestamp is known.
        ///
        /// Note that this option can only be used in single-use transactions.
        ///
        /// A timestamp in RFC3339 UTC \"Zulu\" format, accurate to nanoseconds.
        /// Example: `"2014-10-02T15:01:23.045123456Z"`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Timestamp MinReadTimestamp {
          get { return timestampBoundCase_ == TimestampBoundOneofCase.MinReadTimestamp ? (global::Google.Protobuf.WellKnownTypes.Timestamp) timestampBound_ : null; }
          set {
            timestampBound_ = value;
            timestampBoundCase_ = value == null ? TimestampBoundOneofCase.None : TimestampBoundOneofCase.MinReadTimestamp;
          }
        }

        /// <summary>Field number for the "max_staleness" field.</summary>
        public const int MaxStalenessFieldNumber = 3;
        /// <summary>
        /// Read data at a timestamp >= `NOW - max_staleness`
        /// seconds. Guarantees that all writes that have committed more
        /// than the specified number of seconds ago are visible. Because
        /// Cloud Spanner chooses the exact timestamp, this mode works even if
        /// the client's local clock is substantially skewed from Cloud Spanner
        /// commit timestamps.
        ///
        /// Useful for reading the freshest data available at a nearby
        /// replica, while bounding the possible staleness if the local
        /// replica has fallen behind.
        ///
        /// Note that this option can only be used in single-use
        /// transactions.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration MaxStaleness {
          get { return timestampBoundCase_ == TimestampBoundOneofCase.MaxStaleness ? (global::Google.Protobuf.WellKnownTypes.Duration) timestampBound_ : null; }
          set {
            timestampBound_ = value;
            timestampBoundCase_ = value == null ? TimestampBoundOneofCase.None : TimestampBoundOneofCase.MaxStaleness;
          }
        }

        /// <summary>Field number for the "read_timestamp" field.</summary>
        public const int ReadTimestampFieldNumber = 4;
        /// <summary>
        /// Executes all reads at the given timestamp. Unlike other modes,
        /// reads at a specific timestamp are repeatable; the same read at
        /// the same timestamp always returns the same data. If the
        /// timestamp is in the future, the read will block until the
        /// specified timestamp, modulo the read's deadline.
        ///
        /// Useful for large scale consistent reads such as mapreduces, or
        /// for coordinating many reads against a consistent snapshot of the
        /// data.
        ///
        /// A timestamp in RFC3339 UTC \"Zulu\" format, accurate to nanoseconds.
        /// Example: `"2014-10-02T15:01:23.045123456Z"`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Timestamp ReadTimestamp {
          get { return timestampBoundCase_ == TimestampBoundOneofCase.ReadTimestamp ? (global::Google.Protobuf.WellKnownTypes.Timestamp) timestampBound_ : null; }
          set {
            timestampBound_ = value;
            timestampBoundCase_ = value == null ? TimestampBoundOneofCase.None : TimestampBoundOneofCase.ReadTimestamp;
          }
        }

        /// <summary>Field number for the "exact_staleness" field.</summary>
        public const int ExactStalenessFieldNumber = 5;
        /// <summary>
        /// Executes all reads at a timestamp that is `exact_staleness`
        /// old. The timestamp is chosen soon after the read is started.
        ///
        /// Guarantees that all writes that have committed more than the
        /// specified number of seconds ago are visible. Because Cloud Spanner
        /// chooses the exact timestamp, this mode works even if the client's
        /// local clock is substantially skewed from Cloud Spanner commit
        /// timestamps.
        ///
        /// Useful for reading at nearby replicas without the distributed
        /// timestamp negotiation overhead of `max_staleness`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration ExactStaleness {
          get { return timestampBoundCase_ == TimestampBoundOneofCase.ExactStaleness ? (global::Google.Protobuf.WellKnownTypes.Duration) timestampBound_ : null; }
          set {
            timestampBound_ = value;
            timestampBoundCase_ = value == null ? TimestampBoundOneofCase.None : TimestampBoundOneofCase.ExactStaleness;
          }
        }

        /// <summary>Field number for the "return_read_timestamp" field.</summary>
        public const int ReturnReadTimestampFieldNumber = 6;
        private bool returnReadTimestamp_;
        /// <summary>
        /// If true, the Cloud Spanner-selected read timestamp is included in
        /// the [Transaction][google.spanner.v1.Transaction] message that describes
        /// the transaction.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool ReturnReadTimestamp {
          get { return returnReadTimestamp_; }
          set {
            returnReadTimestamp_ = value;
          }
        }

        private object timestampBound_;
        /// <summary>Enum of possible cases for the "timestamp_bound" oneof.</summary>
        public enum TimestampBoundOneofCase {
          None = 0,
          Strong = 1,
          MinReadTimestamp = 2,
          MaxStaleness = 3,
          ReadTimestamp = 4,
          ExactStaleness = 5,
        }
        private TimestampBoundOneofCase timestampBoundCase_ = TimestampBoundOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TimestampBoundOneofCase TimestampBoundCase {
          get { return timestampBoundCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearTimestampBound() {
          timestampBoundCase_ = TimestampBoundOneofCase.None;
          timestampBound_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as ReadOnly);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(ReadOnly other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Strong != other.Strong) return false;
          if (!object.Equals(MinReadTimestamp, other.MinReadTimestamp)) return false;
          if (!object.Equals(MaxStaleness, other.MaxStaleness)) return false;
          if (!object.Equals(ReadTimestamp, other.ReadTimestamp)) return false;
          if (!object.Equals(ExactStaleness, other.ExactStaleness)) return false;
          if (ReturnReadTimestamp != other.ReturnReadTimestamp) return false;
          if (TimestampBoundCase != other.TimestampBoundCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasStrong) hash ^= Strong.GetHashCode();
          if (timestampBoundCase_ == TimestampBoundOneofCase.MinReadTimestamp) hash ^= MinReadTimestamp.GetHashCode();
          if (timestampBoundCase_ == TimestampBoundOneofCase.MaxStaleness) hash ^= MaxStaleness.GetHashCode();
          if (timestampBoundCase_ == TimestampBoundOneofCase.ReadTimestamp) hash ^= ReadTimestamp.GetHashCode();
          if (timestampBoundCase_ == TimestampBoundOneofCase.ExactStaleness) hash ^= ExactStaleness.GetHashCode();
          if (ReturnReadTimestamp != false) hash ^= ReturnReadTimestamp.GetHashCode();
          hash ^= (int) timestampBoundCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasStrong) {
            output.WriteRawTag(8);
            output.WriteBool(Strong);
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.MinReadTimestamp) {
            output.WriteRawTag(18);
            output.WriteMessage(MinReadTimestamp);
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.MaxStaleness) {
            output.WriteRawTag(26);
            output.WriteMessage(MaxStaleness);
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.ReadTimestamp) {
            output.WriteRawTag(34);
            output.WriteMessage(ReadTimestamp);
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.ExactStaleness) {
            output.WriteRawTag(42);
            output.WriteMessage(ExactStaleness);
          }
          if (ReturnReadTimestamp != false) {
            output.WriteRawTag(48);
            output.WriteBool(ReturnReadTimestamp);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasStrong) {
            output.WriteRawTag(8);
            output.WriteBool(Strong);
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.MinReadTimestamp) {
            output.WriteRawTag(18);
            output.WriteMessage(MinReadTimestamp);
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.MaxStaleness) {
            output.WriteRawTag(26);
            output.WriteMessage(MaxStaleness);
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.ReadTimestamp) {
            output.WriteRawTag(34);
            output.WriteMessage(ReadTimestamp);
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.ExactStaleness) {
            output.WriteRawTag(42);
            output.WriteMessage(ExactStaleness);
          }
          if (ReturnReadTimestamp != false) {
            output.WriteRawTag(48);
            output.WriteBool(ReturnReadTimestamp);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasStrong) {
            size += 1 + 1;
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.MinReadTimestamp) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(MinReadTimestamp);
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.MaxStaleness) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaxStaleness);
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.ReadTimestamp) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReadTimestamp);
          }
          if (timestampBoundCase_ == TimestampBoundOneofCase.ExactStaleness) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExactStaleness);
          }
          if (ReturnReadTimestamp != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(ReadOnly other) {
          if (other == null) {
            return;
          }
          if (other.ReturnReadTimestamp != false) {
            ReturnReadTimestamp = other.ReturnReadTimestamp;
          }
          switch (other.TimestampBoundCase) {
            case TimestampBoundOneofCase.Strong:
              Strong = other.Strong;
              break;
            case TimestampBoundOneofCase.MinReadTimestamp:
              if (MinReadTimestamp == null) {
                MinReadTimestamp = new global::Google.Protobuf.WellKnownTypes.Timestamp();
              }
              MinReadTimestamp.MergeFrom(other.MinReadTimestamp);
              break;
            case TimestampBoundOneofCase.MaxStaleness:
              if (MaxStaleness == null) {
                MaxStaleness = new global::Google.Protobuf.WellKnownTypes.Duration();
              }
              MaxStaleness.MergeFrom(other.MaxStaleness);
              break;
            case TimestampBoundOneofCase.ReadTimestamp:
              if (ReadTimestamp == null) {
                ReadTimestamp = new global::Google.Protobuf.WellKnownTypes.Timestamp();
              }
              ReadTimestamp.MergeFrom(other.ReadTimestamp);
              break;
            case TimestampBoundOneofCase.ExactStaleness:
              if (ExactStaleness == null) {
                ExactStaleness = new global::Google.Protobuf.WellKnownTypes.Duration();
              }
              ExactStaleness.MergeFrom(other.ExactStaleness);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Strong = input.ReadBool();
                break;
              }
              case 18: {
                global::Google.Protobuf.WellKnownTypes.Timestamp subBuilder = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                if (timestampBoundCase_ == TimestampBoundOneofCase.MinReadTimestamp) {
                  subBuilder.MergeFrom(MinReadTimestamp);
                }
                input.ReadMessage(subBuilder);
                MinReadTimestamp = subBuilder;
                break;
              }
              case 26: {
                global::Google.Protobuf.WellKnownTypes.Duration subBuilder = new global::Google.Protobuf.WellKnownTypes.Duration();
                if (timestampBoundCase_ == TimestampBoundOneofCase.MaxStaleness) {
                  subBuilder.MergeFrom(MaxStaleness);
                }
                input.ReadMessage(subBuilder);
                MaxStaleness = subBuilder;
                break;
              }
              case 34: {
                global::Google.Protobuf.WellKnownTypes.Timestamp subBuilder = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                if (timestampBoundCase_ == TimestampBoundOneofCase.ReadTimestamp) {
                  subBuilder.MergeFrom(ReadTimestamp);
                }
                input.ReadMessage(subBuilder);
                ReadTimestamp = subBuilder;
                break;
              }
              case 42: {
                global::Google.Protobuf.WellKnownTypes.Duration subBuilder = new global::Google.Protobuf.WellKnownTypes.Duration();
                if (timestampBoundCase_ == TimestampBoundOneofCase.ExactStaleness) {
                  subBuilder.MergeFrom(ExactStaleness);
                }
                input.ReadMessage(subBuilder);
                ExactStaleness = subBuilder;
                break;
              }
              case 48: {
                ReturnReadTimestamp = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Strong = input.ReadBool();
                break;
              }
              case 18: {
                global::Google.Protobuf.WellKnownTypes.Timestamp subBuilder = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                if (timestampBoundCase_ == TimestampBoundOneofCase.MinReadTimestamp) {
                  subBuilder.MergeFrom(MinReadTimestamp);
                }
                input.ReadMessage(subBuilder);
                MinReadTimestamp = subBuilder;
                break;
              }
              case 26: {
                global::Google.Protobuf.WellKnownTypes.Duration subBuilder = new global::Google.Protobuf.WellKnownTypes.Duration();
                if (timestampBoundCase_ == TimestampBoundOneofCase.MaxStaleness) {
                  subBuilder.MergeFrom(MaxStaleness);
                }
                input.ReadMessage(subBuilder);
                MaxStaleness = subBuilder;
                break;
              }
              case 34: {
                global::Google.Protobuf.WellKnownTypes.Timestamp subBuilder = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                if (timestampBoundCase_ == TimestampBoundOneofCase.ReadTimestamp) {
                  subBuilder.MergeFrom(ReadTimestamp);
                }
                input.ReadMessage(subBuilder);
                ReadTimestamp = subBuilder;
                break;
              }
              case 42: {
                global::Google.Protobuf.WellKnownTypes.Duration subBuilder = new global::Google.Protobuf.WellKnownTypes.Duration();
                if (timestampBoundCase_ == TimestampBoundOneofCase.ExactStaleness) {
                  subBuilder.MergeFrom(ExactStaleness);
                }
                input.ReadMessage(subBuilder);
                ExactStaleness = subBuilder;
                break;
              }
              case 48: {
                ReturnReadTimestamp = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// A transaction.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Transaction : pb::IMessage<Transaction>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Transaction> _parser = new pb::MessageParser<Transaction>(() => new Transaction());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Transaction> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Spanner.V1.TransactionReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Transaction() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Transaction(Transaction other) : this() {
      id_ = other.id_;
      readTimestamp_ = other.readTimestamp_ != null ? other.readTimestamp_.Clone() : null;
      precommitToken_ = other.precommitToken_ != null ? other.precommitToken_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Transaction Clone() {
      return new Transaction(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private pb::ByteString id_ = pb::ByteString.Empty;
    /// <summary>
    /// `id` may be used to identify the transaction in subsequent
    /// [Read][google.spanner.v1.Spanner.Read],
    /// [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql],
    /// [Commit][google.spanner.v1.Spanner.Commit], or
    /// [Rollback][google.spanner.v1.Spanner.Rollback] calls.
    ///
    /// Single-use read-only transactions do not have IDs, because
    /// single-use transactions do not support multiple requests.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Id {
      get { return id_; }
      set {
        id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "read_timestamp" field.</summary>
    public const int ReadTimestampFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Timestamp readTimestamp_;
    /// <summary>
    /// For snapshot read-only transactions, the read timestamp chosen
    /// for the transaction. Not returned by default: see
    /// [TransactionOptions.ReadOnly.return_read_timestamp][google.spanner.v1.TransactionOptions.ReadOnly.return_read_timestamp].
    ///
    /// A timestamp in RFC3339 UTC \"Zulu\" format, accurate to nanoseconds.
    /// Example: `"2014-10-02T15:01:23.045123456Z"`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp ReadTimestamp {
      get { return readTimestamp_; }
      set {
        readTimestamp_ = value;
      }
    }

    /// <summary>Field number for the "precommit_token" field.</summary>
    public const int PrecommitTokenFieldNumber = 3;
    private global::Google.Cloud.Spanner.V1.MultiplexedSessionPrecommitToken precommitToken_;
    /// <summary>
    /// A precommit token will be included in the response of a BeginTransaction
    /// request if the read-write transaction is on a multiplexed session and
    /// a mutation_key was specified in the
    /// [BeginTransaction][google.spanner.v1.BeginTransactionRequest].
    /// The precommit token with the highest sequence number from this transaction
    /// attempt should be passed to the [Commit][google.spanner.v1.Spanner.Commit]
    /// request for this transaction.
    /// This feature is not yet supported and will result in an UNIMPLEMENTED
    /// error.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.Spanner.V1.MultiplexedSessionPrecommitToken PrecommitToken {
      get { return precommitToken_; }
      set {
        precommitToken_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Transaction);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Transaction other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (!object.Equals(ReadTimestamp, other.ReadTimestamp)) return false;
      if (!object.Equals(PrecommitToken, other.PrecommitToken)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Id.Length != 0) hash ^= Id.GetHashCode();
      if (readTimestamp_ != null) hash ^= ReadTimestamp.GetHashCode();
      if (precommitToken_ != null) hash ^= PrecommitToken.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Id.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(Id);
      }
      if (readTimestamp_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ReadTimestamp);
      }
      if (precommitToken_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(PrecommitToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Id.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(Id);
      }
      if (readTimestamp_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ReadTimestamp);
      }
      if (precommitToken_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(PrecommitToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Id.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Id);
      }
      if (readTimestamp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReadTimestamp);
      }
      if (precommitToken_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PrecommitToken);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Transaction other) {
      if (other == null) {
        return;
      }
      if (other.Id.Length != 0) {
        Id = other.Id;
      }
      if (other.readTimestamp_ != null) {
        if (readTimestamp_ == null) {
          ReadTimestamp = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        ReadTimestamp.MergeFrom(other.ReadTimestamp);
      }
      if (other.precommitToken_ != null) {
        if (precommitToken_ == null) {
          PrecommitToken = new global::Google.Cloud.Spanner.V1.MultiplexedSessionPrecommitToken();
        }
        PrecommitToken.MergeFrom(other.PrecommitToken);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Id = input.ReadBytes();
            break;
          }
          case 18: {
            if (readTimestamp_ == null) {
              ReadTimestamp = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(ReadTimestamp);
            break;
          }
          case 26: {
            if (precommitToken_ == null) {
              PrecommitToken = new global::Google.Cloud.Spanner.V1.MultiplexedSessionPrecommitToken();
            }
            input.ReadMessage(PrecommitToken);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Id = input.ReadBytes();
            break;
          }
          case 18: {
            if (readTimestamp_ == null) {
              ReadTimestamp = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(ReadTimestamp);
            break;
          }
          case 26: {
            if (precommitToken_ == null) {
              PrecommitToken = new global::Google.Cloud.Spanner.V1.MultiplexedSessionPrecommitToken();
            }
            input.ReadMessage(PrecommitToken);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// This message is used to select the transaction in which a
  /// [Read][google.spanner.v1.Spanner.Read] or
  /// [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql] call runs.
  ///
  /// See [TransactionOptions][google.spanner.v1.TransactionOptions] for more
  /// information about transactions.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TransactionSelector : pb::IMessage<TransactionSelector>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TransactionSelector> _parser = new pb::MessageParser<TransactionSelector>(() => new TransactionSelector());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TransactionSelector> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Spanner.V1.TransactionReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TransactionSelector() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TransactionSelector(TransactionSelector other) : this() {
      switch (other.SelectorCase) {
        case SelectorOneofCase.SingleUse:
          SingleUse = other.SingleUse.Clone();
          break;
        case SelectorOneofCase.Id:
          Id = other.Id;
          break;
        case SelectorOneofCase.Begin:
          Begin = other.Begin.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TransactionSelector Clone() {
      return new TransactionSelector(this);
    }

    /// <summary>Field number for the "single_use" field.</summary>
    public const int SingleUseFieldNumber = 1;
    /// <summary>
    /// Execute the read or SQL query in a temporary transaction.
    /// This is the most efficient way to execute a transaction that
    /// consists of a single SQL query.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.Spanner.V1.TransactionOptions SingleUse {
      get { return selectorCase_ == SelectorOneofCase.SingleUse ? (global::Google.Cloud.Spanner.V1.TransactionOptions) selector_ : null; }
      set {
        selector_ = value;
        selectorCase_ = value == null ? SelectorOneofCase.None : SelectorOneofCase.SingleUse;
      }
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 2;
    /// <summary>
    /// Execute the read or SQL query in a previously-started transaction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Id {
      get { return HasId ? (pb::ByteString) selector_ : pb::ByteString.Empty; }
      set {
        selector_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        selectorCase_ = SelectorOneofCase.Id;
      }
    }
    /// <summary>Gets whether the "id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasId {
      get { return selectorCase_ == SelectorOneofCase.Id; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "id" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearId() {
      if (HasId) {
        ClearSelector();
      }
    }

    /// <summary>Field number for the "begin" field.</summary>
    public const int BeginFieldNumber = 3;
    /// <summary>
    /// Begin a new transaction and execute this read or SQL query in
    /// it. The transaction ID of the new transaction is returned in
    /// [ResultSetMetadata.transaction][google.spanner.v1.ResultSetMetadata.transaction],
    /// which is a [Transaction][google.spanner.v1.Transaction].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.Spanner.V1.TransactionOptions Begin {
      get { return selectorCase_ == SelectorOneofCase.Begin ? (global::Google.Cloud.Spanner.V1.TransactionOptions) selector_ : null; }
      set {
        selector_ = value;
        selectorCase_ = value == null ? SelectorOneofCase.None : SelectorOneofCase.Begin;
      }
    }

    private object selector_;
    /// <summary>Enum of possible cases for the "selector" oneof.</summary>
    public enum SelectorOneofCase {
      None = 0,
      SingleUse = 1,
      Id = 2,
      Begin = 3,
    }
    private SelectorOneofCase selectorCase_ = SelectorOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SelectorOneofCase SelectorCase {
      get { return selectorCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSelector() {
      selectorCase_ = SelectorOneofCase.None;
      selector_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TransactionSelector);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TransactionSelector other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(SingleUse, other.SingleUse)) return false;
      if (Id != other.Id) return false;
      if (!object.Equals(Begin, other.Begin)) return false;
      if (SelectorCase != other.SelectorCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (selectorCase_ == SelectorOneofCase.SingleUse) hash ^= SingleUse.GetHashCode();
      if (HasId) hash ^= Id.GetHashCode();
      if (selectorCase_ == SelectorOneofCase.Begin) hash ^= Begin.GetHashCode();
      hash ^= (int) selectorCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (selectorCase_ == SelectorOneofCase.SingleUse) {
        output.WriteRawTag(10);
        output.WriteMessage(SingleUse);
      }
      if (HasId) {
        output.WriteRawTag(18);
        output.WriteBytes(Id);
      }
      if (selectorCase_ == SelectorOneofCase.Begin) {
        output.WriteRawTag(26);
        output.WriteMessage(Begin);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (selectorCase_ == SelectorOneofCase.SingleUse) {
        output.WriteRawTag(10);
        output.WriteMessage(SingleUse);
      }
      if (HasId) {
        output.WriteRawTag(18);
        output.WriteBytes(Id);
      }
      if (selectorCase_ == SelectorOneofCase.Begin) {
        output.WriteRawTag(26);
        output.WriteMessage(Begin);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (selectorCase_ == SelectorOneofCase.SingleUse) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SingleUse);
      }
      if (HasId) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Id);
      }
      if (selectorCase_ == SelectorOneofCase.Begin) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Begin);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TransactionSelector other) {
      if (other == null) {
        return;
      }
      switch (other.SelectorCase) {
        case SelectorOneofCase.SingleUse:
          if (SingleUse == null) {
            SingleUse = new global::Google.Cloud.Spanner.V1.TransactionOptions();
          }
          SingleUse.MergeFrom(other.SingleUse);
          break;
        case SelectorOneofCase.Id:
          Id = other.Id;
          break;
        case SelectorOneofCase.Begin:
          if (Begin == null) {
            Begin = new global::Google.Cloud.Spanner.V1.TransactionOptions();
          }
          Begin.MergeFrom(other.Begin);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Google.Cloud.Spanner.V1.TransactionOptions subBuilder = new global::Google.Cloud.Spanner.V1.TransactionOptions();
            if (selectorCase_ == SelectorOneofCase.SingleUse) {
              subBuilder.MergeFrom(SingleUse);
            }
            input.ReadMessage(subBuilder);
            SingleUse = subBuilder;
            break;
          }
          case 18: {
            Id = input.ReadBytes();
            break;
          }
          case 26: {
            global::Google.Cloud.Spanner.V1.TransactionOptions subBuilder = new global::Google.Cloud.Spanner.V1.TransactionOptions();
            if (selectorCase_ == SelectorOneofCase.Begin) {
              subBuilder.MergeFrom(Begin);
            }
            input.ReadMessage(subBuilder);
            Begin = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::Google.Cloud.Spanner.V1.TransactionOptions subBuilder = new global::Google.Cloud.Spanner.V1.TransactionOptions();
            if (selectorCase_ == SelectorOneofCase.SingleUse) {
              subBuilder.MergeFrom(SingleUse);
            }
            input.ReadMessage(subBuilder);
            SingleUse = subBuilder;
            break;
          }
          case 18: {
            Id = input.ReadBytes();
            break;
          }
          case 26: {
            global::Google.Cloud.Spanner.V1.TransactionOptions subBuilder = new global::Google.Cloud.Spanner.V1.TransactionOptions();
            if (selectorCase_ == SelectorOneofCase.Begin) {
              subBuilder.MergeFrom(Begin);
            }
            input.ReadMessage(subBuilder);
            Begin = subBuilder;
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// When a read-write transaction is executed on a multiplexed session,
  /// this precommit token is sent back to the client
  /// as a part of the [Transaction] message in the BeginTransaction response and
  /// also as a part of the [ResultSet] and [PartialResultSet] responses.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class MultiplexedSessionPrecommitToken : pb::IMessage<MultiplexedSessionPrecommitToken>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MultiplexedSessionPrecommitToken> _parser = new pb::MessageParser<MultiplexedSessionPrecommitToken>(() => new MultiplexedSessionPrecommitToken());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<MultiplexedSessionPrecommitToken> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Spanner.V1.TransactionReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MultiplexedSessionPrecommitToken() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MultiplexedSessionPrecommitToken(MultiplexedSessionPrecommitToken other) : this() {
      precommitToken_ = other.precommitToken_;
      seqNum_ = other.seqNum_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MultiplexedSessionPrecommitToken Clone() {
      return new MultiplexedSessionPrecommitToken(this);
    }

    /// <summary>Field number for the "precommit_token" field.</summary>
    public const int PrecommitTokenFieldNumber = 1;
    private pb::ByteString precommitToken_ = pb::ByteString.Empty;
    /// <summary>
    /// Opaque precommit token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString PrecommitToken {
      get { return precommitToken_; }
      set {
        precommitToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "seq_num" field.</summary>
    public const int SeqNumFieldNumber = 2;
    private int seqNum_;
    /// <summary>
    /// An incrementing seq number is generated on every precommit token
    /// that is returned. Clients should remember the precommit token with the
    /// highest sequence number from the current transaction attempt.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int SeqNum {
      get { return seqNum_; }
      set {
        seqNum_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as MultiplexedSessionPrecommitToken);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(MultiplexedSessionPrecommitToken other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PrecommitToken != other.PrecommitToken) return false;
      if (SeqNum != other.SeqNum) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (PrecommitToken.Length != 0) hash ^= PrecommitToken.GetHashCode();
      if (SeqNum != 0) hash ^= SeqNum.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (PrecommitToken.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(PrecommitToken);
      }
      if (SeqNum != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(SeqNum);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (PrecommitToken.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(PrecommitToken);
      }
      if (SeqNum != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(SeqNum);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (PrecommitToken.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PrecommitToken);
      }
      if (SeqNum != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(SeqNum);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(MultiplexedSessionPrecommitToken other) {
      if (other == null) {
        return;
      }
      if (other.PrecommitToken.Length != 0) {
        PrecommitToken = other.PrecommitToken;
      }
      if (other.SeqNum != 0) {
        SeqNum = other.SeqNum;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            PrecommitToken = input.ReadBytes();
            break;
          }
          case 16: {
            SeqNum = input.ReadInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            PrecommitToken = input.ReadBytes();
            break;
          }
          case 16: {
            SeqNum = input.ReadInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
