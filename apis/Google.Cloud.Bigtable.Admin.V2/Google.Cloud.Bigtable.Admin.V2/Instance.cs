// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/bigtable/admin/v2/instance.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Cloud.Bigtable.Admin.V2 {

  /// <summary>Holder for reflection information generated from google/bigtable/admin/v2/instance.proto</summary>
  public static partial class InstanceReflection {

    #region Descriptor
    /// <summary>File descriptor for google/bigtable/admin/v2/instance.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static InstanceReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cidnb29nbGUvYmlndGFibGUvYWRtaW4vdjIvaW5zdGFuY2UucHJvdG8SGGdv",
            "b2dsZS5iaWd0YWJsZS5hZG1pbi52MhocZ29vZ2xlL2FwaS9hbm5vdGF0aW9u",
            "cy5wcm90bxolZ29vZ2xlL2JpZ3RhYmxlL2FkbWluL3YyL2NvbW1vbi5wcm90",
            "byKUAgoISW5zdGFuY2USDAoEbmFtZRgBIAEoCRIUCgxkaXNwbGF5X25hbWUY",
            "AiABKAkSNwoFc3RhdGUYAyABKA4yKC5nb29nbGUuYmlndGFibGUuYWRtaW4u",
            "djIuSW5zdGFuY2UuU3RhdGUSNQoEdHlwZRgEIAEoDjInLmdvb2dsZS5iaWd0",
            "YWJsZS5hZG1pbi52Mi5JbnN0YW5jZS5UeXBlIjUKBVN0YXRlEhMKD1NUQVRF",
            "X05PVF9LTk9XThAAEgkKBVJFQURZEAESDAoIQ1JFQVRJTkcQAiI9CgRUeXBl",
            "EhQKEFRZUEVfVU5TUEVDSUZJRUQQABIOCgpQUk9EVUNUSU9OEAESDwoLREVW",
            "RUxPUE1FTlQQAiKOAgoHQ2x1c3RlchIMCgRuYW1lGAEgASgJEhAKCGxvY2F0",
            "aW9uGAIgASgJEjYKBXN0YXRlGAMgASgOMicuZ29vZ2xlLmJpZ3RhYmxlLmFk",
            "bWluLnYyLkNsdXN0ZXIuU3RhdGUSEwoLc2VydmVfbm9kZXMYBCABKAUSQwoU",
            "ZGVmYXVsdF9zdG9yYWdlX3R5cGUYBSABKA4yJS5nb29nbGUuYmlndGFibGUu",
            "YWRtaW4udjIuU3RvcmFnZVR5cGUiUQoFU3RhdGUSEwoPU1RBVEVfTk9UX0tO",
            "T1dOEAASCQoFUkVBRFkQARIMCghDUkVBVElORxACEgwKCFJFU0laSU5HEAMS",
            "DAoIRElTQUJMRUQQBEKwAQocY29tLmdvb2dsZS5iaWd0YWJsZS5hZG1pbi52",
            "MkINSW5zdGFuY2VQcm90b1ABWj1nb29nbGUuZ29sYW5nLm9yZy9nZW5wcm90",
            "by9nb29nbGVhcGlzL2JpZ3RhYmxlL2FkbWluL3YyO2FkbWluqgIeR29vZ2xl",
            "LkNsb3VkLkJpZ3RhYmxlLkFkbWluLlYyygIeR29vZ2xlXENsb3VkXEJpZ3Rh",
            "YmxlXEFkbWluXFYyYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.AnnotationsReflection.Descriptor, global::Google.Cloud.Bigtable.Admin.V2.CommonReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Bigtable.Admin.V2.Instance), global::Google.Cloud.Bigtable.Admin.V2.Instance.Parser, new[]{ "Name", "DisplayName", "State", "Type" }, null, new[]{ typeof(global::Google.Cloud.Bigtable.Admin.V2.Instance.Types.State), typeof(global::Google.Cloud.Bigtable.Admin.V2.Instance.Types.Type) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Bigtable.Admin.V2.Cluster), global::Google.Cloud.Bigtable.Admin.V2.Cluster.Parser, new[]{ "Name", "Location", "State", "ServeNodes", "DefaultStorageType" }, null, new[]{ typeof(global::Google.Cloud.Bigtable.Admin.V2.Cluster.Types.State) }, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// A collection of Bigtable [Tables][google.bigtable.admin.v2.Table] and
  /// the resources that serve them.
  /// All tables in an instance are served from a single
  /// [Cluster][google.bigtable.admin.v2.Cluster].
  /// </summary>
  public sealed partial class Instance : pb::IMessage<Instance> {
    private static readonly pb::MessageParser<Instance> _parser = new pb::MessageParser<Instance>(() => new Instance());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Instance> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Bigtable.Admin.V2.InstanceReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Instance() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Instance(Instance other) : this() {
      name_ = other.name_;
      displayName_ = other.displayName_;
      state_ = other.state_;
      type_ = other.type_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Instance Clone() {
      return new Instance(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// (`OutputOnly`)
    /// The unique name of the instance. Values are of the form
    /// `projects/&lt;project>/instances/[a-z][a-z0-9\\-]+[a-z0-9]`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "display_name" field.</summary>
    public const int DisplayNameFieldNumber = 2;
    private string displayName_ = "";
    /// <summary>
    /// The descriptive name for this instance as it appears in UIs.
    /// Can be changed at any time, but should be kept globally unique
    /// to avoid confusion.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DisplayName {
      get { return displayName_; }
      set {
        displayName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "state" field.</summary>
    public const int StateFieldNumber = 3;
    private global::Google.Cloud.Bigtable.Admin.V2.Instance.Types.State state_ = 0;
    /// <summary>
    /// (`OutputOnly`)
    /// The current state of the instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Bigtable.Admin.V2.Instance.Types.State State {
      get { return state_; }
      set {
        state_ = value;
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 4;
    private global::Google.Cloud.Bigtable.Admin.V2.Instance.Types.Type type_ = 0;
    /// <summary>
    /// The type of the instance. Defaults to `PRODUCTION`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Bigtable.Admin.V2.Instance.Types.Type Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Instance);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Instance other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (DisplayName != other.DisplayName) return false;
      if (State != other.State) return false;
      if (Type != other.Type) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (DisplayName.Length != 0) hash ^= DisplayName.GetHashCode();
      if (State != 0) hash ^= State.GetHashCode();
      if (Type != 0) hash ^= Type.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (DisplayName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(DisplayName);
      }
      if (State != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) State);
      }
      if (Type != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Type);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (DisplayName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DisplayName);
      }
      if (State != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) State);
      }
      if (Type != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Instance other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.DisplayName.Length != 0) {
        DisplayName = other.DisplayName;
      }
      if (other.State != 0) {
        State = other.State;
      }
      if (other.Type != 0) {
        Type = other.Type;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            DisplayName = input.ReadString();
            break;
          }
          case 24: {
            state_ = (global::Google.Cloud.Bigtable.Admin.V2.Instance.Types.State) input.ReadEnum();
            break;
          }
          case 32: {
            type_ = (global::Google.Cloud.Bigtable.Admin.V2.Instance.Types.Type) input.ReadEnum();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Instance message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Possible states of an instance.
      /// </summary>
      public enum State {
        /// <summary>
        /// The state of the instance could not be determined.
        /// </summary>
        [pbr::OriginalName("STATE_NOT_KNOWN")] NotKnown = 0,
        /// <summary>
        /// The instance has been successfully created and can serve requests
        /// to its tables.
        /// </summary>
        [pbr::OriginalName("READY")] Ready = 1,
        /// <summary>
        /// The instance is currently being created, and may be destroyed
        /// if the creation process encounters an error.
        /// </summary>
        [pbr::OriginalName("CREATING")] Creating = 2,
      }

      /// <summary>
      /// The type of the instance.
      /// </summary>
      public enum Type {
        /// <summary>
        /// The type of the instance is unspecified. If set when creating an
        /// instance, a `PRODUCTION` instance will be created. If set when updating
        /// an instance, the type will be left unchanged.
        /// </summary>
        [pbr::OriginalName("TYPE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// An instance meant for production use. `serve_nodes` must be set
        /// on the cluster.
        /// </summary>
        [pbr::OriginalName("PRODUCTION")] Production = 1,
        /// <summary>
        /// The instance is meant for development and testing purposes only; it has
        /// no performance or uptime guarantees and is not covered by SLA.
        /// After a development instance is created, it can be upgraded by
        /// updating the instance to type `PRODUCTION`. An instance created
        /// as a production instance cannot be changed to a development instance.
        /// When creating a development instance, `serve_nodes` on the cluster must
        /// not be set.
        /// </summary>
        [pbr::OriginalName("DEVELOPMENT")] Development = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// A resizable group of nodes in a particular cloud location, capable
  /// of serving all [Tables][google.bigtable.admin.v2.Table] in the parent
  /// [Instance][google.bigtable.admin.v2.Instance].
  /// </summary>
  public sealed partial class Cluster : pb::IMessage<Cluster> {
    private static readonly pb::MessageParser<Cluster> _parser = new pb::MessageParser<Cluster>(() => new Cluster());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Cluster> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Bigtable.Admin.V2.InstanceReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Cluster() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Cluster(Cluster other) : this() {
      name_ = other.name_;
      location_ = other.location_;
      state_ = other.state_;
      serveNodes_ = other.serveNodes_;
      defaultStorageType_ = other.defaultStorageType_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Cluster Clone() {
      return new Cluster(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// (`OutputOnly`)
    /// The unique name of the cluster. Values are of the form
    /// `projects/&lt;project>/instances/&lt;instance>/clusters/[a-z][-a-z0-9]*`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "location" field.</summary>
    public const int LocationFieldNumber = 2;
    private string location_ = "";
    /// <summary>
    /// (`CreationOnly`)
    /// The location where this cluster's nodes and storage reside. For best
    /// performance, clients should be located as close as possible to this cluster.
    /// Currently only zones are supported, so values should be of the form
    /// `projects/&lt;project>/locations/&lt;zone>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Location {
      get { return location_; }
      set {
        location_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "state" field.</summary>
    public const int StateFieldNumber = 3;
    private global::Google.Cloud.Bigtable.Admin.V2.Cluster.Types.State state_ = 0;
    /// <summary>
    /// (`OutputOnly`)
    /// The current state of the cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Bigtable.Admin.V2.Cluster.Types.State State {
      get { return state_; }
      set {
        state_ = value;
      }
    }

    /// <summary>Field number for the "serve_nodes" field.</summary>
    public const int ServeNodesFieldNumber = 4;
    private int serveNodes_;
    /// <summary>
    /// The number of nodes allocated to this cluster. More nodes enable higher
    /// throughput and more consistent performance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ServeNodes {
      get { return serveNodes_; }
      set {
        serveNodes_ = value;
      }
    }

    /// <summary>Field number for the "default_storage_type" field.</summary>
    public const int DefaultStorageTypeFieldNumber = 5;
    private global::Google.Cloud.Bigtable.Admin.V2.StorageType defaultStorageType_ = 0;
    /// <summary>
    /// (`CreationOnly`)
    /// The type of storage used by this cluster to serve its
    /// parent instance's tables, unless explicitly overridden.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Bigtable.Admin.V2.StorageType DefaultStorageType {
      get { return defaultStorageType_; }
      set {
        defaultStorageType_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Cluster);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Cluster other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Location != other.Location) return false;
      if (State != other.State) return false;
      if (ServeNodes != other.ServeNodes) return false;
      if (DefaultStorageType != other.DefaultStorageType) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Location.Length != 0) hash ^= Location.GetHashCode();
      if (State != 0) hash ^= State.GetHashCode();
      if (ServeNodes != 0) hash ^= ServeNodes.GetHashCode();
      if (DefaultStorageType != 0) hash ^= DefaultStorageType.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Location.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Location);
      }
      if (State != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) State);
      }
      if (ServeNodes != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(ServeNodes);
      }
      if (DefaultStorageType != 0) {
        output.WriteRawTag(40);
        output.WriteEnum((int) DefaultStorageType);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Location.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Location);
      }
      if (State != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) State);
      }
      if (ServeNodes != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ServeNodes);
      }
      if (DefaultStorageType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DefaultStorageType);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Cluster other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Location.Length != 0) {
        Location = other.Location;
      }
      if (other.State != 0) {
        State = other.State;
      }
      if (other.ServeNodes != 0) {
        ServeNodes = other.ServeNodes;
      }
      if (other.DefaultStorageType != 0) {
        DefaultStorageType = other.DefaultStorageType;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Location = input.ReadString();
            break;
          }
          case 24: {
            state_ = (global::Google.Cloud.Bigtable.Admin.V2.Cluster.Types.State) input.ReadEnum();
            break;
          }
          case 32: {
            ServeNodes = input.ReadInt32();
            break;
          }
          case 40: {
            defaultStorageType_ = (global::Google.Cloud.Bigtable.Admin.V2.StorageType) input.ReadEnum();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Cluster message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Possible states of a cluster.
      /// </summary>
      public enum State {
        /// <summary>
        /// The state of the cluster could not be determined.
        /// </summary>
        [pbr::OriginalName("STATE_NOT_KNOWN")] NotKnown = 0,
        /// <summary>
        /// The cluster has been successfully created and is ready to serve requests.
        /// </summary>
        [pbr::OriginalName("READY")] Ready = 1,
        /// <summary>
        /// The cluster is currently being created, and may be destroyed
        /// if the creation process encounters an error.
        /// A cluster may not be able to serve requests while being created.
        /// </summary>
        [pbr::OriginalName("CREATING")] Creating = 2,
        /// <summary>
        /// The cluster is currently being resized, and may revert to its previous
        /// node count if the process encounters an error.
        /// A cluster is still capable of serving requests while being resized,
        /// but may exhibit performance as if its number of allocated nodes is
        /// between the starting and requested states.
        /// </summary>
        [pbr::OriginalName("RESIZING")] Resizing = 3,
        /// <summary>
        /// The cluster has no backing nodes. The data (tables) still
        /// exist, but no operations can be performed on the cluster.
        /// </summary>
        [pbr::OriginalName("DISABLED")] Disabled = 4,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
