// Copyright 2017, Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using Google.Api.Gax;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

namespace Google.Cloud.Firestore
{
    /// <summary>
    /// An immutable snapshot of complete query results.
    /// </summary>
    public sealed class QuerySnapshot : IReadOnlyList<DocumentSnapshot>, IEquatable<QuerySnapshot>
    {
        private readonly Lazy<IReadOnlyList<DocumentSnapshot>> _lazyDocumentList;
        private readonly Lazy<IReadOnlyList<DocumentChange>> _lazyChangeList;
        private readonly Timestamp? _readTime;

        private QuerySnapshot(Query query, Func<IReadOnlyList<DocumentSnapshot>> documentProvider, Func<IReadOnlyList<DocumentChange>> changesProvider, Timestamp? readTime)
        {
            Query = query;
            _lazyDocumentList = new Lazy<IReadOnlyList<DocumentSnapshot>>(documentProvider, LazyThreadSafetyMode.ExecutionAndPublication);
            _lazyChangeList = new Lazy<IReadOnlyList<DocumentChange>>(changesProvider, LazyThreadSafetyMode.ExecutionAndPublication);
            _readTime = readTime;
        }

        internal static QuerySnapshot ForDocuments(Query query, IReadOnlyList<DocumentSnapshot> documents, Timestamp? readTime) =>
            new QuerySnapshot(query, () => documents, () => new LazyChangeList(documents), readTime);

        internal static QuerySnapshot ForChanges(Query query, IEnumerable<DocumentSnapshot> documentSet, IReadOnlyList<DocumentChange> changes, Timestamp readTime) =>
            new QuerySnapshot(query, () => documentSet.ToList().AsReadOnly(), () => changes, readTime);

        /// <summary>
        /// The query producing this snapshot.
        /// </summary>
        public Query Query { get; }

        /// <summary>
        /// The time at which the snapshot was read.
        /// </summary>
        public Timestamp ReadTime => _readTime ?? throw new InvalidOperationException("No read time available");

        /// <summary>
        /// The documents in the snapshot.
        /// </summary>
        public IReadOnlyList<DocumentSnapshot> Documents => _lazyDocumentList.Value;

        /// <summary>
        /// The changes in the documents.
        /// </summary>
        public IReadOnlyList<DocumentChange> Changes => _lazyChangeList.Value;

        /// <summary>
        /// Returns the document snapshot with the specified index within this query snapshot.
        /// </summary>
        /// <param name="index">The index of the document to return.</param>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="index"/> is less than 0, or greater than or equal to <see cref="Count"/>.</exception>
        /// <returns>The document snapshot with the specified index within this query snapshot.</returns>
        public DocumentSnapshot this[int index] => Documents[index];

        /// <summary>
        /// Returns the number of documents in this query snapshot.
        /// </summary>
        /// <value>The number of documents in this query snapshot.</value>
        public int Count => Documents.Count;

        /// <inheritdoc />
        public IEnumerator<DocumentSnapshot> GetEnumerator() => Documents.GetEnumerator();

        /// <inheritdoc />
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        // TODO: Consider making the equality and hash code methods smarter about not iterating
        // over Changes if we know that it's just autogenerated. (We'd need to keep a flag for that.)

        /// <summary>
        /// Compares this snapshot with another for equality. The documents and query are compared;
        /// the read time is not.
        /// </summary>
        /// <param name="other">The snapshot to compare this one with</param>
        /// <returns><c>true</c> if this snapshot is equal to <paramref name="other"/>; <c>false</c> otherwise.</returns>
        public bool Equals(QuerySnapshot other) =>
            other != null &&
            Query.Equals(other.Query) &&
            GaxEqualityHelpers.ListsEqual(Documents, other.Documents) &&
            GaxEqualityHelpers.ListsEqual(Changes, other.Changes);

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as QuerySnapshot);

        /// <inheritdoc />
        public override int GetHashCode() =>
            GaxEqualityHelpers.CombineHashCodes(Query.GetHashCode(), GaxEqualityHelpers.GetListHashCode(Documents), GaxEqualityHelpers.GetListHashCode(Changes));

        /// <summary>
        /// A lazy read-only list that's a projection over a list of snapshots.
        /// This is used to avoid materializing a whole collection.
        /// </summary>
        private sealed class LazyChangeList : IReadOnlyList<DocumentChange>
        {
            private readonly IReadOnlyList<DocumentSnapshot> _snapshots;

            internal LazyChangeList(IReadOnlyList<DocumentSnapshot> snapshots) => _snapshots = snapshots;

            public DocumentChange this[int index] => CreateChange(_snapshots[index], index);

            public int Count => _snapshots.Count;

            public IEnumerator<DocumentChange> GetEnumerator() => _snapshots.Select(CreateChange).GetEnumerator();

            private DocumentChange CreateChange(DocumentSnapshot doc, int index) =>
                new DocumentChange(doc, DocumentChange.Type.Added, null, index);

            IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
        }
    }
}
