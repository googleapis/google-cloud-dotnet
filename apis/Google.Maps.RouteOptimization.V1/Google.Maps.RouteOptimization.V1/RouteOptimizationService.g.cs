// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/maps/routeoptimization/v1/route_optimization_service.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Maps.RouteOptimization.V1 {

  /// <summary>Holder for reflection information generated from google/maps/routeoptimization/v1/route_optimization_service.proto</summary>
  public static partial class RouteOptimizationServiceReflection {

    #region Descriptor
    /// <summary>File descriptor for google/maps/routeoptimization/v1/route_optimization_service.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static RouteOptimizationServiceReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CkFnb29nbGUvbWFwcy9yb3V0ZW9wdGltaXphdGlvbi92MS9yb3V0ZV9vcHRp",
            "bWl6YXRpb25fc2VydmljZS5wcm90bxIgZ29vZ2xlLm1hcHMucm91dGVvcHRp",
            "bWl6YXRpb24udjEaHGdvb2dsZS9hcGkvYW5ub3RhdGlvbnMucHJvdG8aF2dv",
            "b2dsZS9hcGkvY2xpZW50LnByb3RvGh9nb29nbGUvYXBpL2ZpZWxkX2JlaGF2",
            "aW9yLnByb3RvGiNnb29nbGUvbG9uZ3J1bm5pbmcvb3BlcmF0aW9ucy5wcm90",
            "bxoeZ29vZ2xlL3Byb3RvYnVmL2R1cmF0aW9uLnByb3RvGh9nb29nbGUvcHJv",
            "dG9idWYvdGltZXN0YW1wLnByb3RvGhhnb29nbGUvdHlwZS9sYXRsbmcucHJv",
            "dG8i4AIKGUJhdGNoT3B0aW1pemVUb3Vyc1JlcXVlc3QSEwoGcGFyZW50GAEg",
            "ASgJQgPgQQISaAoNbW9kZWxfY29uZmlncxgCIAMoCzJMLmdvb2dsZS5tYXBz",
            "LnJvdXRlb3B0aW1pemF0aW9uLnYxLkJhdGNoT3B0aW1pemVUb3Vyc1JlcXVl",
            "c3QuQXN5bmNNb2RlbENvbmZpZ0ID4EECGsMBChBBc3luY01vZGVsQ29uZmln",
            "EhkKDGRpc3BsYXlfbmFtZRgBIAEoCUID4EEBEkgKDGlucHV0X2NvbmZpZxgC",
            "IAEoCzItLmdvb2dsZS5tYXBzLnJvdXRlb3B0aW1pemF0aW9uLnYxLklucHV0",
            "Q29uZmlnQgPgQQISSgoNb3V0cHV0X2NvbmZpZxgDIAEoCzIuLmdvb2dsZS5t",
            "YXBzLnJvdXRlb3B0aW1pemF0aW9uLnYxLk91dHB1dENvbmZpZ0ID4EECIhwK",
            "GkJhdGNoT3B0aW1pemVUb3Vyc1Jlc3BvbnNlIhwKGkJhdGNoT3B0aW1pemVU",
            "b3Vyc01ldGFkYXRhIpAJChRPcHRpbWl6ZVRvdXJzUmVxdWVzdBITCgZwYXJl",
            "bnQYASABKAlCA+BBAhIqCgd0aW1lb3V0GAIgASgLMhkuZ29vZ2xlLnByb3Rv",
            "YnVmLkR1cmF0aW9uEj4KBW1vZGVsGAMgASgLMi8uZ29vZ2xlLm1hcHMucm91",
            "dGVvcHRpbWl6YXRpb24udjEuU2hpcG1lbnRNb2RlbBJYCgxzb2x2aW5nX21v",
            "ZGUYBCABKA4yQi5nb29nbGUubWFwcy5yb3V0ZW9wdGltaXphdGlvbi52MS5P",
            "cHRpbWl6ZVRvdXJzUmVxdWVzdC5Tb2x2aW5nTW9kZRJWCgtzZWFyY2hfbW9k",
            "ZRgGIAEoDjJBLmdvb2dsZS5tYXBzLnJvdXRlb3B0aW1pemF0aW9uLnYxLk9w",
            "dGltaXplVG91cnNSZXF1ZXN0LlNlYXJjaE1vZGUSVwoeaW5qZWN0ZWRfZmly",
            "c3Rfc29sdXRpb25fcm91dGVzGAcgAygLMi8uZ29vZ2xlLm1hcHMucm91dGVv",
            "cHRpbWl6YXRpb24udjEuU2hpcG1lbnRSb3V0ZRJiChxpbmplY3RlZF9zb2x1",
            "dGlvbl9jb25zdHJhaW50GAggASgLMjwuZ29vZ2xlLm1hcHMucm91dGVvcHRp",
            "bWl6YXRpb24udjEuSW5qZWN0ZWRTb2x1dGlvbkNvbnN0cmFpbnQSTwoWcmVm",
            "cmVzaF9kZXRhaWxzX3JvdXRlcxgJIAMoCzIvLmdvb2dsZS5tYXBzLnJvdXRl",
            "b3B0aW1pemF0aW9uLnYxLlNoaXBtZW50Um91dGUSMQopaW50ZXJwcmV0X2lu",
            "amVjdGVkX3NvbHV0aW9uc191c2luZ19sYWJlbHMYCiABKAgSHQoVY29uc2lk",
            "ZXJfcm9hZF90cmFmZmljGAsgASgIEhoKEnBvcHVsYXRlX3BvbHlsaW5lcxgM",
            "IAEoCBIlCh1wb3B1bGF0ZV90cmFuc2l0aW9uX3BvbHlsaW5lcxgNIAEoCBI2",
            "Ci5hbGxvd19sYXJnZV9kZWFkbGluZV9kZXNwaXRlX2ludGVycnVwdGlvbl9y",
            "aXNrGA4gASgIEh4KFnVzZV9nZW9kZXNpY19kaXN0YW5jZXMYDyABKAgSJwoa",
            "Z2VvZGVzaWNfbWV0ZXJzX3Blcl9zZWNvbmQYECABKAFIAIgBARIiChVtYXhf",
            "dmFsaWRhdGlvbl9lcnJvcnMYBSABKAVIAYgBARINCgVsYWJlbBgRIAEoCSJZ",
            "CgtTb2x2aW5nTW9kZRIRCg1ERUZBVUxUX1NPTFZFEAASEQoNVkFMSURBVEVf",
            "T05MWRABEiQKIERFVEVDVF9TT01FX0lORkVBU0lCTEVfU0hJUE1FTlRTEAIi",
            "WgoKU2VhcmNoTW9kZRIbChdTRUFSQ0hfTU9ERV9VTlNQRUNJRklFRBAAEg8K",
            "C1JFVFVSTl9GQVNUEAESHgoaQ09OU1VNRV9BTExfQVZBSUxBQkxFX1RJTUUQ",
            "AkIdChtfZ2VvZGVzaWNfbWV0ZXJzX3Blcl9zZWNvbmRCGAoWX21heF92YWxp",
            "ZGF0aW9uX2Vycm9ycyKuBgoVT3B0aW1pemVUb3Vyc1Jlc3BvbnNlEj8KBnJv",
            "dXRlcxgBIAMoCzIvLmdvb2dsZS5tYXBzLnJvdXRlb3B0aW1pemF0aW9uLnYx",
            "LlNoaXBtZW50Um91dGUSFQoNcmVxdWVzdF9sYWJlbBgDIAEoCRJMChFza2lw",
            "cGVkX3NoaXBtZW50cxgEIAMoCzIxLmdvb2dsZS5tYXBzLnJvdXRlb3B0aW1p",
            "emF0aW9uLnYxLlNraXBwZWRTaGlwbWVudBJZChF2YWxpZGF0aW9uX2Vycm9y",
            "cxgFIAMoCzI+Lmdvb2dsZS5tYXBzLnJvdXRlb3B0aW1pemF0aW9uLnYxLk9w",
            "dGltaXplVG91cnNWYWxpZGF0aW9uRXJyb3ISUAoHbWV0cmljcxgGIAEoCzI/",
            "Lmdvb2dsZS5tYXBzLnJvdXRlb3B0aW1pemF0aW9uLnYxLk9wdGltaXplVG91",
            "cnNSZXNwb25zZS5NZXRyaWNzGsEDCgdNZXRyaWNzElUKGGFnZ3JlZ2F0ZWRf",
            "cm91dGVfbWV0cmljcxgBIAEoCzIzLmdvb2dsZS5tYXBzLnJvdXRlb3B0aW1p",
            "emF0aW9uLnYxLkFnZ3JlZ2F0ZWRNZXRyaWNzEigKIHNraXBwZWRfbWFuZGF0",
            "b3J5X3NoaXBtZW50X2NvdW50GAIgASgFEhoKEnVzZWRfdmVoaWNsZV9jb3Vu",
            "dBgDIAEoBRI/ChtlYXJsaWVzdF92ZWhpY2xlX3N0YXJ0X3RpbWUYBCABKAsy",
            "Gi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjsKF2xhdGVzdF92ZWhpY2xl",
            "X2VuZF90aW1lGAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBJZ",
            "CgVjb3N0cxgKIAMoCzJKLmdvb2dsZS5tYXBzLnJvdXRlb3B0aW1pemF0aW9u",
            "LnYxLk9wdGltaXplVG91cnNSZXNwb25zZS5NZXRyaWNzLkNvc3RzRW50cnkS",
            "EgoKdG90YWxfY29zdBgGIAEoARosCgpDb3N0c0VudHJ5EgsKA2tleRgBIAEo",
            "CRINCgV2YWx1ZRgCIAEoAToCOAEiuwoKDVNoaXBtZW50TW9kZWwSPQoJc2hp",
            "cG1lbnRzGAEgAygLMiouZ29vZ2xlLm1hcHMucm91dGVvcHRpbWl6YXRpb24u",
            "djEuU2hpcG1lbnQSOwoIdmVoaWNsZXMYAiADKAsyKS5nb29nbGUubWFwcy5y",
            "b3V0ZW9wdGltaXphdGlvbi52MS5WZWhpY2xlEiAKE21heF9hY3RpdmVfdmVo",
            "aWNsZXMYBCABKAVIAIgBARI1ChFnbG9iYWxfc3RhcnRfdGltZRgFIAEoCzIa",
            "Lmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASMwoPZ2xvYmFsX2VuZF90aW1l",
            "GAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIlCh1nbG9iYWxf",
            "ZHVyYXRpb25fY29zdF9wZXJfaG91chgHIAEoARJqChpkdXJhdGlvbl9kaXN0",
            "YW5jZV9tYXRyaWNlcxgIIAMoCzJGLmdvb2dsZS5tYXBzLnJvdXRlb3B0aW1p",
            "emF0aW9uLnYxLlNoaXBtZW50TW9kZWwuRHVyYXRpb25EaXN0YW5jZU1hdHJp",
            "eBIpCiFkdXJhdGlvbl9kaXN0YW5jZV9tYXRyaXhfc3JjX3RhZ3MYCSADKAkS",
            "KQohZHVyYXRpb25fZGlzdGFuY2VfbWF0cml4X2RzdF90YWdzGAogAygJElUK",
            "FXRyYW5zaXRpb25fYXR0cmlidXRlcxgLIAMoCzI2Lmdvb2dsZS5tYXBzLnJv",
            "dXRlb3B0aW1pemF0aW9uLnYxLlRyYW5zaXRpb25BdHRyaWJ1dGVzEmYKH3No",
            "aXBtZW50X3R5cGVfaW5jb21wYXRpYmlsaXRpZXMYDCADKAsyPS5nb29nbGUu",
            "bWFwcy5yb3V0ZW9wdGltaXphdGlvbi52MS5TaGlwbWVudFR5cGVJbmNvbXBh",
            "dGliaWxpdHkSXQoac2hpcG1lbnRfdHlwZV9yZXF1aXJlbWVudHMYDSADKAsy",
            "OS5nb29nbGUubWFwcy5yb3V0ZW9wdGltaXphdGlvbi52MS5TaGlwbWVudFR5",
            "cGVSZXF1aXJlbWVudBJYChBwcmVjZWRlbmNlX3J1bGVzGA4gAygLMj4uZ29v",
            "Z2xlLm1hcHMucm91dGVvcHRpbWl6YXRpb24udjEuU2hpcG1lbnRNb2RlbC5Q",
            "cmVjZWRlbmNlUnVsZRrSAQoWRHVyYXRpb25EaXN0YW5jZU1hdHJpeBJYCgRy",
            "b3dzGAEgAygLMkouZ29vZ2xlLm1hcHMucm91dGVvcHRpbWl6YXRpb24udjEu",
            "U2hpcG1lbnRNb2RlbC5EdXJhdGlvbkRpc3RhbmNlTWF0cml4LlJvdxIZChF2",
            "ZWhpY2xlX3N0YXJ0X3RhZxgCIAEoCRpDCgNSb3cSLAoJZHVyYXRpb25zGAEg",
            "AygLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEg4KBm1ldGVycxgCIAMo",
            "ARrRAQoOUHJlY2VkZW5jZVJ1bGUSGAoLZmlyc3RfaW5kZXgYASABKAVIAIgB",
            "ARIZChFmaXJzdF9pc19kZWxpdmVyeRgDIAEoCBIZCgxzZWNvbmRfaW5kZXgY",
            "AiABKAVIAYgBARIaChJzZWNvbmRfaXNfZGVsaXZlcnkYBCABKAgSMgoPb2Zm",
            "c2V0X2R1cmF0aW9uGAUgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9u",
            "Qg4KDF9maXJzdF9pbmRleEIPCg1fc2Vjb25kX2luZGV4QhYKFF9tYXhfYWN0",
            "aXZlX3ZlaGljbGVzIrALCghTaGlwbWVudBIUCgxkaXNwbGF5X25hbWUYECAB",
            "KAkSSAoHcGlja3VwcxgBIAMoCzI3Lmdvb2dsZS5tYXBzLnJvdXRlb3B0aW1p",
            "emF0aW9uLnYxLlNoaXBtZW50LlZpc2l0UmVxdWVzdBJLCgpkZWxpdmVyaWVz",
            "GAIgAygLMjcuZ29vZ2xlLm1hcHMucm91dGVvcHRpbWl6YXRpb24udjEuU2hp",
            "cG1lbnQuVmlzaXRSZXF1ZXN0ElEKDGxvYWRfZGVtYW5kcxgOIAMoCzI7Lmdv",
            "b2dsZS5tYXBzLnJvdXRlb3B0aW1pemF0aW9uLnYxLlNoaXBtZW50LkxvYWRE",
            "ZW1hbmRzRW50cnkSGQoMcGVuYWx0eV9jb3N0GAQgASgBSACIAQESHwoXYWxs",
            "b3dlZF92ZWhpY2xlX2luZGljZXMYBSADKAUSGQoRY29zdHNfcGVyX3ZlaGlj",
            "bGUYBiADKAESIQoZY29zdHNfcGVyX3ZlaGljbGVfaW5kaWNlcxgHIAMoBRI1",
            "CihwaWNrdXBfdG9fZGVsaXZlcnlfcmVsYXRpdmVfZGV0b3VyX2xpbWl0GAgg",
            "ASgBSAGIAQESSwoocGlja3VwX3RvX2RlbGl2ZXJ5X2Fic29sdXRlX2RldG91",
            "cl9saW1pdBgJIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhJACh1w",
            "aWNrdXBfdG9fZGVsaXZlcnlfdGltZV9saW1pdBgKIAEoCzIZLmdvb2dsZS5w",
            "cm90b2J1Zi5EdXJhdGlvbhIVCg1zaGlwbWVudF90eXBlGAsgASgJEg0KBWxh",
            "YmVsGAwgASgJEg4KBmlnbm9yZRgNIAEoCBryBAoMVmlzaXRSZXF1ZXN0Ei0K",
            "EGFycml2YWxfbG9jYXRpb24YASABKAsyEy5nb29nbGUudHlwZS5MYXRMbmcS",
            "RAoQYXJyaXZhbF93YXlwb2ludBgCIAEoCzIqLmdvb2dsZS5tYXBzLnJvdXRl",
            "b3B0aW1pemF0aW9uLnYxLldheXBvaW50Ei8KEmRlcGFydHVyZV9sb2NhdGlv",
            "bhgDIAEoCzITLmdvb2dsZS50eXBlLkxhdExuZxJGChJkZXBhcnR1cmVfd2F5",
            "cG9pbnQYBCABKAsyKi5nb29nbGUubWFwcy5yb3V0ZW9wdGltaXphdGlvbi52",
            "MS5XYXlwb2ludBIMCgR0YWdzGAUgAygJEkIKDHRpbWVfd2luZG93cxgGIAMo",
            "CzIsLmdvb2dsZS5tYXBzLnJvdXRlb3B0aW1pemF0aW9uLnYxLlRpbWVXaW5k",
            "b3cSKwoIZHVyYXRpb24YByABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRp",
            "b24SDAoEY29zdBgIIAEoARJeCgxsb2FkX2RlbWFuZHMYDCADKAsySC5nb29n",
            "bGUubWFwcy5yb3V0ZW9wdGltaXphdGlvbi52MS5TaGlwbWVudC5WaXNpdFJl",
            "cXVlc3QuTG9hZERlbWFuZHNFbnRyeRITCgt2aXNpdF90eXBlcxgKIAMoCRIN",
            "CgVsYWJlbBgLIAEoCRpjChBMb2FkRGVtYW5kc0VudHJ5EgsKA2tleRgBIAEo",
            "CRI+CgV2YWx1ZRgCIAEoCzIvLmdvb2dsZS5tYXBzLnJvdXRlb3B0aW1pemF0",
            "aW9uLnYxLlNoaXBtZW50LkxvYWQ6AjgBGhYKBExvYWQSDgoGYW1vdW50GAIg",
            "ASgDGmMKEExvYWREZW1hbmRzRW50cnkSCwoDa2V5GAEgASgJEj4KBXZhbHVl",
            "GAIgASgLMi8uZ29vZ2xlLm1hcHMucm91dGVvcHRpbWl6YXRpb24udjEuU2hp",
            "cG1lbnQuTG9hZDoCOAFCDwoNX3BlbmFsdHlfY29zdEIrCilfcGlja3VwX3Rv",
            "X2RlbGl2ZXJ5X3JlbGF0aXZlX2RldG91cl9saW1pdCKmAgobU2hpcG1lbnRU",
            "eXBlSW5jb21wYXRpYmlsaXR5Eg0KBXR5cGVzGAEgAygJEm8KFGluY29tcGF0",
            "aWJpbGl0eV9tb2RlGAIgASgOMlEuZ29vZ2xlLm1hcHMucm91dGVvcHRpbWl6",
            "YXRpb24udjEuU2hpcG1lbnRUeXBlSW5jb21wYXRpYmlsaXR5LkluY29tcGF0",
            "aWJpbGl0eU1vZGUihgEKE0luY29tcGF0aWJpbGl0eU1vZGUSJAogSU5DT01Q",
            "QVRJQklMSVRZX01PREVfVU5TUEVDSUZJRUQQABIhCh1OT1RfUEVSRk9STUVE",
            "X0JZX1NBTUVfVkVISUNMRRABEiYKIk5PVF9JTl9TQU1FX1ZFSElDTEVfU0lN",
            "VUxUQU5FT1VTTFkQAiLsAgoXU2hpcG1lbnRUeXBlUmVxdWlyZW1lbnQSKwoj",
            "cmVxdWlyZWRfc2hpcG1lbnRfdHlwZV9hbHRlcm5hdGl2ZXMYASADKAkSIAoY",
            "ZGVwZW5kZW50X3NoaXBtZW50X3R5cGVzGAIgAygJEmMKEHJlcXVpcmVtZW50",
            "X21vZGUYAyABKA4ySS5nb29nbGUubWFwcy5yb3V0ZW9wdGltaXphdGlvbi52",
            "MS5TaGlwbWVudFR5cGVSZXF1aXJlbWVudC5SZXF1aXJlbWVudE1vZGUinAEK",
            "D1JlcXVpcmVtZW50TW9kZRIgChxSRVFVSVJFTUVOVF9NT0RFX1VOU1BFQ0lG",
            "SUVEEAASHQoZUEVSRk9STUVEX0JZX1NBTUVfVkVISUNMRRABEiIKHklOX1NB",
            "TUVfVkVISUNMRV9BVF9QSUNLVVBfVElNRRACEiQKIElOX1NBTUVfVkVISUNM",
            "RV9BVF9ERUxJVkVSWV9USU1FEAMibwoOUm91dGVNb2RpZmllcnMSEwoLYXZv",
            "aWRfdG9sbHMYAiABKAgSFgoOYXZvaWRfaGlnaHdheXMYAyABKAgSFQoNYXZv",
            "aWRfZmVycmllcxgEIAEoCBIZCgxhdm9pZF9pbmRvb3IYBSABKAhCA+BBASLR",
            "EwoHVmVoaWNsZRIUCgxkaXNwbGF5X25hbWUYICABKAkSSQoLdHJhdmVsX21v",
            "ZGUYASABKA4yNC5nb29nbGUubWFwcy5yb3V0ZW9wdGltaXphdGlvbi52MS5W",
            "ZWhpY2xlLlRyYXZlbE1vZGUSSQoPcm91dGVfbW9kaWZpZXJzGAIgASgLMjAu",
            "Z29vZ2xlLm1hcHMucm91dGVvcHRpbWl6YXRpb24udjEuUm91dGVNb2RpZmll",
            "cnMSKwoOc3RhcnRfbG9jYXRpb24YAyABKAsyEy5nb29nbGUudHlwZS5MYXRM",
            "bmcSQgoOc3RhcnRfd2F5cG9pbnQYBCABKAsyKi5nb29nbGUubWFwcy5yb3V0",
            "ZW9wdGltaXphdGlvbi52MS5XYXlwb2ludBIpCgxlbmRfbG9jYXRpb24YBSAB",
            "KAsyEy5nb29nbGUudHlwZS5MYXRMbmcSQAoMZW5kX3dheXBvaW50GAYgASgL",
            "MiouZ29vZ2xlLm1hcHMucm91dGVvcHRpbWl6YXRpb24udjEuV2F5cG9pbnQS",
            "EgoKc3RhcnRfdGFncxgHIAMoCRIQCghlbmRfdGFncxgIIAMoCRJIChJzdGFy",
            "dF90aW1lX3dpbmRvd3MYCSADKAsyLC5nb29nbGUubWFwcy5yb3V0ZW9wdGlt",
            "aXphdGlvbi52MS5UaW1lV2luZG93EkYKEGVuZF90aW1lX3dpbmRvd3MYCiAD",
            "KAsyLC5nb29nbGUubWFwcy5yb3V0ZW9wdGltaXphdGlvbi52MS5UaW1lV2lu",
            "ZG93EiUKGHRyYXZlbF9kdXJhdGlvbl9tdWx0aXBsZRgLIAEoAUgAiAEBElMK",
            "EHVubG9hZGluZ19wb2xpY3kYDCABKA4yOS5nb29nbGUubWFwcy5yb3V0ZW9w",
            "dGltaXphdGlvbi52MS5WZWhpY2xlLlVubG9hZGluZ1BvbGljeRJOCgtsb2Fk",
            "X2xpbWl0cxgeIAMoCzI5Lmdvb2dsZS5tYXBzLnJvdXRlb3B0aW1pemF0aW9u",
            "LnYxLlZlaGljbGUuTG9hZExpbWl0c0VudHJ5EhUKDWNvc3RfcGVyX2hvdXIY",
            "ECABKAESHgoWY29zdF9wZXJfdHJhdmVsZWRfaG91chgRIAEoARIaChJjb3N0",
            "X3Blcl9raWxvbWV0ZXIYEiABKAESEgoKZml4ZWRfY29zdBgTIAEoARIeChZ1",
            "c2VkX2lmX3JvdXRlX2lzX2VtcHR5GBQgASgIElUKFHJvdXRlX2R1cmF0aW9u",
            "X2xpbWl0GBUgASgLMjcuZ29vZ2xlLm1hcHMucm91dGVvcHRpbWl6YXRpb24u",
            "djEuVmVoaWNsZS5EdXJhdGlvbkxpbWl0ElYKFXRyYXZlbF9kdXJhdGlvbl9s",
            "aW1pdBgWIAEoCzI3Lmdvb2dsZS5tYXBzLnJvdXRlb3B0aW1pemF0aW9uLnYx",
            "LlZlaGljbGUuRHVyYXRpb25MaW1pdBJNChRyb3V0ZV9kaXN0YW5jZV9saW1p",
            "dBgXIAEoCzIvLmdvb2dsZS5tYXBzLnJvdXRlb3B0aW1pemF0aW9uLnYxLkRp",
            "c3RhbmNlTGltaXQSegojZXh0cmFfdmlzaXRfZHVyYXRpb25fZm9yX3Zpc2l0",
            "X3R5cGUYGCADKAsyTS5nb29nbGUubWFwcy5yb3V0ZW9wdGltaXphdGlvbi52",
            "MS5WZWhpY2xlLkV4dHJhVmlzaXREdXJhdGlvbkZvclZpc2l0VHlwZUVudHJ5",
            "Ej8KCmJyZWFrX3J1bGUYGSABKAsyKy5nb29nbGUubWFwcy5yb3V0ZW9wdGlt",
            "aXphdGlvbi52MS5CcmVha1J1bGUSDQoFbGFiZWwYGyABKAkSDgoGaWdub3Jl",
            "GBwgASgIGtMCCglMb2FkTGltaXQSFQoIbWF4X2xvYWQYASABKANIAIgBARIV",
            "Cg1zb2Z0X21heF9sb2FkGAIgASgDEiQKHGNvc3RfcGVyX3VuaXRfYWJvdmVf",
            "c29mdF9tYXgYAyABKAESWQoTc3RhcnRfbG9hZF9pbnRlcnZhbBgEIAEoCzI8",
            "Lmdvb2dsZS5tYXBzLnJvdXRlb3B0aW1pemF0aW9uLnYxLlZlaGljbGUuTG9h",
            "ZExpbWl0LkludGVydmFsElcKEWVuZF9sb2FkX2ludGVydmFsGAUgASgLMjwu",
            "Z29vZ2xlLm1hcHMucm91dGVvcHRpbWl6YXRpb24udjEuVmVoaWNsZS5Mb2Fk",
            "TGltaXQuSW50ZXJ2YWwaMQoISW50ZXJ2YWwSCwoDbWluGAEgASgDEhAKA21h",
            "eBgCIAEoA0gAiAEBQgYKBF9tYXhCCwoJX21heF9sb2FkGvACCg1EdXJhdGlv",
            "bkxpbWl0Ei8KDG1heF9kdXJhdGlvbhgBIAEoCzIZLmdvb2dsZS5wcm90b2J1",
            "Zi5EdXJhdGlvbhI0ChFzb2Z0X21heF9kdXJhdGlvbhgCIAEoCzIZLmdvb2ds",
            "ZS5wcm90b2J1Zi5EdXJhdGlvbhIpChxjb3N0X3Blcl9ob3VyX2FmdGVyX3Nv",
            "ZnRfbWF4GAMgASgBSACIAQESPgobcXVhZHJhdGljX3NvZnRfbWF4X2R1cmF0",
            "aW9uGAQgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjoKLWNvc3Rf",
            "cGVyX3NxdWFyZV9ob3VyX2FmdGVyX3F1YWRyYXRpY19zb2Z0X21heBgFIAEo",
            "AUgBiAEBQh8KHV9jb3N0X3Blcl9ob3VyX2FmdGVyX3NvZnRfbWF4QjAKLl9j",
            "b3N0X3Blcl9zcXVhcmVfaG91cl9hZnRlcl9xdWFkcmF0aWNfc29mdF9tYXga",
            "ZgoPTG9hZExpbWl0c0VudHJ5EgsKA2tleRgBIAEoCRJCCgV2YWx1ZRgCIAEo",
            "CzIzLmdvb2dsZS5tYXBzLnJvdXRlb3B0aW1pemF0aW9uLnYxLlZlaGljbGUu",
            "TG9hZExpbWl0OgI4ARpgCiNFeHRyYVZpc2l0RHVyYXRpb25Gb3JWaXNpdFR5",
            "cGVFbnRyeRILCgNrZXkYASABKAkSKAoFdmFsdWUYAiABKAsyGS5nb29nbGUu",
            "cHJvdG9idWYuRHVyYXRpb246AjgBIkMKClRyYXZlbE1vZGUSGwoXVFJBVkVM",
            "X01PREVfVU5TUEVDSUZJRUQQABILCgdEUklWSU5HEAESCwoHV0FMS0lORxAC",
            "ImIKD1VubG9hZGluZ1BvbGljeRIgChxVTkxPQURJTkdfUE9MSUNZX1VOU1BF",
            "Q0lGSUVEEAASFQoRTEFTVF9JTl9GSVJTVF9PVVQQARIWChJGSVJTVF9JTl9G",
            "SVJTVF9PVVQQAkIbChlfdHJhdmVsX2R1cmF0aW9uX211bHRpcGxlIoQDCgpU",
            "aW1lV2luZG93Ei4KCnN0YXJ0X3RpbWUYASABKAsyGi5nb29nbGUucHJvdG9i",
            "dWYuVGltZXN0YW1wEiwKCGVuZF90aW1lGAIgASgLMhouZ29vZ2xlLnByb3Rv",
            "YnVmLlRpbWVzdGFtcBIzCg9zb2Z0X3N0YXJ0X3RpbWUYAyABKAsyGi5nb29n",
            "bGUucHJvdG9idWYuVGltZXN0YW1wEjEKDXNvZnRfZW5kX3RpbWUYBCABKAsy",
            "Gi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjEKJGNvc3RfcGVyX2hvdXJf",
            "YmVmb3JlX3NvZnRfc3RhcnRfdGltZRgFIAEoAUgAiAEBEi4KIWNvc3RfcGVy",
            "X2hvdXJfYWZ0ZXJfc29mdF9lbmRfdGltZRgGIAEoAUgBiAEBQicKJV9jb3N0",
            "X3Blcl9ob3VyX2JlZm9yZV9zb2Z0X3N0YXJ0X3RpbWVCJAoiX2Nvc3RfcGVy",
            "X2hvdXJfYWZ0ZXJfc29mdF9lbmRfdGltZSKVAgoNRGlzdGFuY2VMaW1pdBIX",
            "CgptYXhfbWV0ZXJzGAEgASgDSACIAQESHAoPc29mdF9tYXhfbWV0ZXJzGAIg",
            "ASgDSAGIAQESLgohY29zdF9wZXJfa2lsb21ldGVyX2JlbG93X3NvZnRfbWF4",
            "GAQgASgBSAKIAQESLgohY29zdF9wZXJfa2lsb21ldGVyX2Fib3ZlX3NvZnRf",
            "bWF4GAMgASgBSAOIAQFCDQoLX21heF9tZXRlcnNCEgoQX3NvZnRfbWF4X21l",
            "dGVyc0IkCiJfY29zdF9wZXJfa2lsb21ldGVyX2JlbG93X3NvZnRfbWF4QiQK",
            "Il9jb3N0X3Blcl9raWxvbWV0ZXJfYWJvdmVfc29mdF9tYXgiiQIKFFRyYW5z",
            "aXRpb25BdHRyaWJ1dGVzEg8KB3NyY190YWcYASABKAkSGAoQZXhjbHVkZWRf",
            "c3JjX3RhZxgCIAEoCRIPCgdkc3RfdGFnGAMgASgJEhgKEGV4Y2x1ZGVkX2Rz",
            "dF90YWcYBCABKAkSDAoEY29zdBgFIAEoARIaChJjb3N0X3Blcl9raWxvbWV0",
            "ZXIYBiABKAESRwoOZGlzdGFuY2VfbGltaXQYByABKAsyLy5nb29nbGUubWFw",
            "cy5yb3V0ZW9wdGltaXphdGlvbi52MS5EaXN0YW5jZUxpbWl0EigKBWRlbGF5",
            "GAggASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uIooBCghXYXlwb2lu",
            "dBI+Cghsb2NhdGlvbhgBIAEoCzIqLmdvb2dsZS5tYXBzLnJvdXRlb3B0aW1p",
            "emF0aW9uLnYxLkxvY2F0aW9uSAASEgoIcGxhY2VfaWQYAiABKAlIABIZCgxz",
            "aWRlX29mX3JvYWQYAyABKAhCA+BBAUIPCg1sb2NhdGlvbl90eXBlIlIKCExv",
            "Y2F0aW9uEiQKB2xhdF9sbmcYASABKAsyEy5nb29nbGUudHlwZS5MYXRMbmcS",
            "FAoHaGVhZGluZxgCIAEoBUgAiAEBQgoKCF9oZWFkaW5nIpQECglCcmVha1J1",
            "bGUSUAoOYnJlYWtfcmVxdWVzdHMYASADKAsyOC5nb29nbGUubWFwcy5yb3V0",
            "ZW9wdGltaXphdGlvbi52MS5CcmVha1J1bGUuQnJlYWtSZXF1ZXN0El4KFWZy",
            "ZXF1ZW5jeV9jb25zdHJhaW50cxgCIAMoCzI/Lmdvb2dsZS5tYXBzLnJvdXRl",
            "b3B0aW1pemF0aW9uLnYxLkJyZWFrUnVsZS5GcmVxdWVuY3lDb25zdHJhaW50",
            "Gr4BCgxCcmVha1JlcXVlc3QSPAoTZWFybGllc3Rfc3RhcnRfdGltZRgBIAEo",
            "CzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCA+BBAhI6ChFsYXRlc3Rf",
            "c3RhcnRfdGltZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBC",
            "A+BBAhI0CgxtaW5fZHVyYXRpb24YAyABKAsyGS5nb29nbGUucHJvdG9idWYu",
            "RHVyYXRpb25CA+BBAhqTAQoTRnJlcXVlbmN5Q29uc3RyYWludBI6ChJtaW5f",
            "YnJlYWtfZHVyYXRpb24YASABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRp",
            "b25CA+BBAhJAChhtYXhfaW50ZXJfYnJlYWtfZHVyYXRpb24YAiABKAsyGS5n",
            "b29nbGUucHJvdG9idWYuRHVyYXRpb25CA+BBAiKAEAoNU2hpcG1lbnRSb3V0",
            "ZRIVCg12ZWhpY2xlX2luZGV4GAEgASgFEhUKDXZlaGljbGVfbGFiZWwYAiAB",
            "KAkSNgoSdmVoaWNsZV9zdGFydF90aW1lGAUgASgLMhouZ29vZ2xlLnByb3Rv",
            "YnVmLlRpbWVzdGFtcBI0ChB2ZWhpY2xlX2VuZF90aW1lGAYgASgLMhouZ29v",
            "Z2xlLnByb3RvYnVmLlRpbWVzdGFtcBJFCgZ2aXNpdHMYByADKAsyNS5nb29n",
            "bGUubWFwcy5yb3V0ZW9wdGltaXphdGlvbi52MS5TaGlwbWVudFJvdXRlLlZp",
            "c2l0Ek8KC3RyYW5zaXRpb25zGAggAygLMjouZ29vZ2xlLm1hcHMucm91dGVv",
            "cHRpbWl6YXRpb24udjEuU2hpcG1lbnRSb3V0ZS5UcmFuc2l0aW9uEiMKG2hh",
            "c190cmFmZmljX2luZmVhc2liaWxpdGllcxgJIAEoCBJXCg5yb3V0ZV9wb2x5",
            "bGluZRgKIAEoCzI/Lmdvb2dsZS5tYXBzLnJvdXRlb3B0aW1pemF0aW9uLnYx",
            "LlNoaXBtZW50Um91dGUuRW5jb2RlZFBvbHlsaW5lEkUKBmJyZWFrcxgLIAMo",
            "CzI1Lmdvb2dsZS5tYXBzLnJvdXRlb3B0aW1pemF0aW9uLnYxLlNoaXBtZW50",
            "Um91dGUuQnJlYWsSRAoHbWV0cmljcxgMIAEoCzIzLmdvb2dsZS5tYXBzLnJv",
            "dXRlb3B0aW1pemF0aW9uLnYxLkFnZ3JlZ2F0ZWRNZXRyaWNzElQKC3JvdXRl",
            "X2Nvc3RzGBEgAygLMj8uZ29vZ2xlLm1hcHMucm91dGVvcHRpbWl6YXRpb24u",
            "djEuU2hpcG1lbnRSb3V0ZS5Sb3V0ZUNvc3RzRW50cnkSGAoQcm91dGVfdG90",
            "YWxfY29zdBgSIAEoARqaAwoFVmlzaXQSFgoOc2hpcG1lbnRfaW5kZXgYASAB",
            "KAUSEQoJaXNfcGlja3VwGAIgASgIEhsKE3Zpc2l0X3JlcXVlc3RfaW5kZXgY",
            "AyABKAUSLgoKc3RhcnRfdGltZRgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5U",
            "aW1lc3RhbXASXAoMbG9hZF9kZW1hbmRzGAsgAygLMkYuZ29vZ2xlLm1hcHMu",
            "cm91dGVvcHRpbWl6YXRpb24udjEuU2hpcG1lbnRSb3V0ZS5WaXNpdC5Mb2Fk",
            "RGVtYW5kc0VudHJ5EikKBmRldG91chgGIAEoCzIZLmdvb2dsZS5wcm90b2J1",
            "Zi5EdXJhdGlvbhIWCg5zaGlwbWVudF9sYWJlbBgHIAEoCRITCgt2aXNpdF9s",
            "YWJlbBgIIAEoCRpjChBMb2FkRGVtYW5kc0VudHJ5EgsKA2tleRgBIAEoCRI+",
            "CgV2YWx1ZRgCIAEoCzIvLmdvb2dsZS5tYXBzLnJvdXRlb3B0aW1pemF0aW9u",
            "LnYxLlNoaXBtZW50LkxvYWQ6AjgBGscFCgpUcmFuc2l0aW9uEjIKD3RyYXZl",
            "bF9kdXJhdGlvbhgBIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhIe",
            "ChZ0cmF2ZWxfZGlzdGFuY2VfbWV0ZXJzGAIgASgBEiAKGHRyYWZmaWNfaW5m",
            "b191bmF2YWlsYWJsZRgDIAEoCBIxCg5kZWxheV9kdXJhdGlvbhgEIAEoCzIZ",
            "Lmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhIxCg5icmVha19kdXJhdGlvbhgF",
            "IAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhIwCg13YWl0X2R1cmF0",
            "aW9uGAYgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjEKDnRvdGFs",
            "X2R1cmF0aW9uGAcgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEi4K",
            "CnN0YXJ0X3RpbWUYCCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1w",
            "ElcKDnJvdXRlX3BvbHlsaW5lGAkgASgLMj8uZ29vZ2xlLm1hcHMucm91dGVv",
            "cHRpbWl6YXRpb24udjEuU2hpcG1lbnRSb3V0ZS5FbmNvZGVkUG9seWxpbmUS",
            "GAoLcm91dGVfdG9rZW4YDCABKAlCA+BBAxJjCg12ZWhpY2xlX2xvYWRzGAsg",
            "AygLMkwuZ29vZ2xlLm1hcHMucm91dGVvcHRpbWl6YXRpb24udjEuU2hpcG1l",
            "bnRSb3V0ZS5UcmFuc2l0aW9uLlZlaGljbGVMb2Fkc0VudHJ5GnAKEVZlaGlj",
            "bGVMb2Fkc0VudHJ5EgsKA2tleRgBIAEoCRJKCgV2YWx1ZRgCIAEoCzI7Lmdv",
            "b2dsZS5tYXBzLnJvdXRlb3B0aW1pemF0aW9uLnYxLlNoaXBtZW50Um91dGUu",
            "VmVoaWNsZUxvYWQ6AjgBGh0KC1ZlaGljbGVMb2FkEg4KBmFtb3VudBgBIAEo",
            "AxohCg9FbmNvZGVkUG9seWxpbmUSDgoGcG9pbnRzGAEgASgJGmQKBUJyZWFr",
            "Ei4KCnN0YXJ0X3RpbWUYASABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0",
            "YW1wEisKCGR1cmF0aW9uGAIgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0",
            "aW9uGjEKD1JvdXRlQ29zdHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUY",
            "AiABKAE6AjgBIoYFCg9Ta2lwcGVkU2hpcG1lbnQSDQoFaW5kZXgYASABKAUS",
            "DQoFbGFiZWwYAiABKAkSSQoHcmVhc29ucxgDIAMoCzI4Lmdvb2dsZS5tYXBz",
            "LnJvdXRlb3B0aW1pemF0aW9uLnYxLlNraXBwZWRTaGlwbWVudC5SZWFzb24a",
            "iQQKBlJlYXNvbhJLCgRjb2RlGAEgASgOMj0uZ29vZ2xlLm1hcHMucm91dGVv",
            "cHRpbWl6YXRpb24udjEuU2tpcHBlZFNoaXBtZW50LlJlYXNvbi5Db2RlEiIK",
            "FWV4YW1wbGVfdmVoaWNsZV9pbmRleBgCIAEoBUgAiAEBEiYKHmV4YW1wbGVf",
            "ZXhjZWVkZWRfY2FwYWNpdHlfdHlwZRgDIAEoCSLLAgoEQ29kZRIUChBDT0RF",
            "X1VOU1BFQ0lGSUVEEAASDgoKTk9fVkVISUNMRRABEiMKH0RFTUFORF9FWENF",
            "RURTX1ZFSElDTEVfQ0FQQUNJVFkQAhI1CjFDQU5OT1RfQkVfUEVSRk9STUVE",
            "X1dJVEhJTl9WRUhJQ0xFX0RJU1RBTkNFX0xJTUlUEAMSNQoxQ0FOTk9UX0JF",
            "X1BFUkZPUk1FRF9XSVRISU5fVkVISUNMRV9EVVJBVElPTl9MSU1JVBAEEjwK",
            "OENBTk5PVF9CRV9QRVJGT1JNRURfV0lUSElOX1ZFSElDTEVfVFJBVkVMX0RV",
            "UkFUSU9OX0xJTUlUEAUSMwovQ0FOTk9UX0JFX1BFUkZPUk1FRF9XSVRISU5f",
            "VkVISUNMRV9USU1FX1dJTkRPV1MQBhIXChNWRUhJQ0xFX05PVF9BTExPV0VE",
            "EAdCGAoWX2V4YW1wbGVfdmVoaWNsZV9pbmRleCLLBAoRQWdncmVnYXRlZE1l",
            "dHJpY3MSIAoYcGVyZm9ybWVkX3NoaXBtZW50X2NvdW50GAEgASgFEjIKD3Ry",
            "YXZlbF9kdXJhdGlvbhgCIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlv",
            "bhIwCg13YWl0X2R1cmF0aW9uGAMgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1",
            "cmF0aW9uEjEKDmRlbGF5X2R1cmF0aW9uGAQgASgLMhkuZ29vZ2xlLnByb3Rv",
            "YnVmLkR1cmF0aW9uEjEKDmJyZWFrX2R1cmF0aW9uGAUgASgLMhkuZ29vZ2xl",
            "LnByb3RvYnVmLkR1cmF0aW9uEjEKDnZpc2l0X2R1cmF0aW9uGAYgASgLMhku",
            "Z29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjEKDnRvdGFsX2R1cmF0aW9uGAcg",
            "ASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEh4KFnRyYXZlbF9kaXN0",
            "YW5jZV9tZXRlcnMYCCABKAESVAoJbWF4X2xvYWRzGAkgAygLMkEuZ29vZ2xl",
            "Lm1hcHMucm91dGVvcHRpbWl6YXRpb24udjEuQWdncmVnYXRlZE1ldHJpY3Mu",
            "TWF4TG9hZHNFbnRyeRpsCg1NYXhMb2Fkc0VudHJ5EgsKA2tleRgBIAEoCRJK",
            "CgV2YWx1ZRgCIAEoCzI7Lmdvb2dsZS5tYXBzLnJvdXRlb3B0aW1pemF0aW9u",
            "LnYxLlNoaXBtZW50Um91dGUuVmVoaWNsZUxvYWQ6AjgBIrMGChpJbmplY3Rl",
            "ZFNvbHV0aW9uQ29uc3RyYWludBI/CgZyb3V0ZXMYASADKAsyLy5nb29nbGUu",
            "bWFwcy5yb3V0ZW9wdGltaXphdGlvbi52MS5TaGlwbWVudFJvdXRlEkwKEXNr",
            "aXBwZWRfc2hpcG1lbnRzGAIgAygLMjEuZ29vZ2xlLm1hcHMucm91dGVvcHRp",
            "bWl6YXRpb24udjEuU2tpcHBlZFNoaXBtZW50EnEKFmNvbnN0cmFpbnRfcmVs",
            "YXhhdGlvbnMYAyADKAsyUS5nb29nbGUubWFwcy5yb3V0ZW9wdGltaXphdGlv",
            "bi52MS5JbmplY3RlZFNvbHV0aW9uQ29uc3RyYWludC5Db25zdHJhaW50UmVs",
            "YXhhdGlvbhqSBAoUQ29uc3RyYWludFJlbGF4YXRpb24ScQoLcmVsYXhhdGlv",
            "bnMYASADKAsyXC5nb29nbGUubWFwcy5yb3V0ZW9wdGltaXphdGlvbi52MS5J",
            "bmplY3RlZFNvbHV0aW9uQ29uc3RyYWludC5Db25zdHJhaW50UmVsYXhhdGlv",
            "bi5SZWxheGF0aW9uEhcKD3ZlaGljbGVfaW5kaWNlcxgCIAMoBRrtAgoKUmVs",
            "YXhhdGlvbhJxCgVsZXZlbBgBIAEoDjJiLmdvb2dsZS5tYXBzLnJvdXRlb3B0",
            "aW1pemF0aW9uLnYxLkluamVjdGVkU29sdXRpb25Db25zdHJhaW50LkNvbnN0",
            "cmFpbnRSZWxheGF0aW9uLlJlbGF4YXRpb24uTGV2ZWwSMgoOdGhyZXNob2xk",
            "X3RpbWUYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEh0KFXRo",
            "cmVzaG9sZF92aXNpdF9jb3VudBgDIAEoBSKYAQoFTGV2ZWwSFQoRTEVWRUxf",
            "VU5TUEVDSUZJRUQQABIlCiFSRUxBWF9WSVNJVF9USU1FU19BRlRFUl9USFJF",
            "U0hPTEQQARIyCi5SRUxBWF9WSVNJVF9USU1FU19BTkRfU0VRVUVOQ0VfQUZU",
            "RVJfVEhSRVNIT0xEEAISHQoZUkVMQVhfQUxMX0FGVEVSX1RIUkVTSE9MRBAD",
            "IoUDChxPcHRpbWl6ZVRvdXJzVmFsaWRhdGlvbkVycm9yEgwKBGNvZGUYASAB",
            "KAUSFAoMZGlzcGxheV9uYW1lGAIgASgJEl0KBmZpZWxkcxgDIAMoCzJNLmdv",
            "b2dsZS5tYXBzLnJvdXRlb3B0aW1pemF0aW9uLnYxLk9wdGltaXplVG91cnNW",
            "YWxpZGF0aW9uRXJyb3IuRmllbGRSZWZlcmVuY2USFQoNZXJyb3JfbWVzc2Fn",
            "ZRgEIAEoCRIYChBvZmZlbmRpbmdfdmFsdWVzGAUgASgJGrABCg5GaWVsZFJl",
            "ZmVyZW5jZRIMCgRuYW1lGAEgASgJEg8KBWluZGV4GAIgASgFSAASDQoDa2V5",
            "GAQgASgJSAASYAoJc3ViX2ZpZWxkGAMgASgLMk0uZ29vZ2xlLm1hcHMucm91",
            "dGVvcHRpbWl6YXRpb24udjEuT3B0aW1pemVUb3Vyc1ZhbGlkYXRpb25FcnJv",
            "ci5GaWVsZFJlZmVyZW5jZUIOCgxpbmRleF9vcl9rZXkiogEKC0lucHV0Q29u",
            "ZmlnEkEKCmdjc19zb3VyY2UYASABKAsyKy5nb29nbGUubWFwcy5yb3V0ZW9w",
            "dGltaXphdGlvbi52MS5HY3NTb3VyY2VIABJGCgtkYXRhX2Zvcm1hdBgCIAEo",
            "DjIsLmdvb2dsZS5tYXBzLnJvdXRlb3B0aW1pemF0aW9uLnYxLkRhdGFGb3Jt",
            "YXRCA+BBAkIICgZzb3VyY2UisgEKDE91dHB1dENvbmZpZxJLCg9nY3NfZGVz",
            "dGluYXRpb24YASABKAsyMC5nb29nbGUubWFwcy5yb3V0ZW9wdGltaXphdGlv",
            "bi52MS5HY3NEZXN0aW5hdGlvbkgAEkYKC2RhdGFfZm9ybWF0GAIgASgOMiwu",
            "Z29vZ2xlLm1hcHMucm91dGVvcHRpbWl6YXRpb24udjEuRGF0YUZvcm1hdEID",
            "4EECQg0KC2Rlc3RpbmF0aW9uIh0KCUdjc1NvdXJjZRIQCgN1cmkYASABKAlC",
            "A+BBAiIiCg5HY3NEZXN0aW5hdGlvbhIQCgN1cmkYASABKAlCA+BBAipDCgpE",
            "YXRhRm9ybWF0EhsKF0RBVEFfRk9STUFUX1VOU1BFQ0lGSUVEEAASCAoESlNP",
            "ThABEg4KClBST1RPX1RFWFQQAjL5BAoRUm91dGVPcHRpbWl6YXRpb24S6gEK",
            "DU9wdGltaXplVG91cnMSNi5nb29nbGUubWFwcy5yb3V0ZW9wdGltaXphdGlv",
            "bi52MS5PcHRpbWl6ZVRvdXJzUmVxdWVzdBo3Lmdvb2dsZS5tYXBzLnJvdXRl",
            "b3B0aW1pemF0aW9uLnYxLk9wdGltaXplVG91cnNSZXNwb25zZSJogtPkkwJi",
            "IjEvdjEve3BhcmVudD1wcm9qZWN0cy8qL2xvY2F0aW9ucy8qfTpvcHRpbWl6",
            "ZVRvdXJzOgEqWioiJS92MS97cGFyZW50PXByb2plY3RzLyp9Om9wdGltaXpl",
            "VG91cnM6ASoSoAIKEkJhdGNoT3B0aW1pemVUb3VycxI7Lmdvb2dsZS5tYXBz",
            "LnJvdXRlb3B0aW1pemF0aW9uLnYxLkJhdGNoT3B0aW1pemVUb3Vyc1JlcXVl",
            "c3QaHS5nb29nbGUubG9uZ3J1bm5pbmcuT3BlcmF0aW9uIq0BykE4ChpCYXRj",
            "aE9wdGltaXplVG91cnNSZXNwb25zZRIaQmF0Y2hPcHRpbWl6ZVRvdXJzTWV0",
            "YWRhdGGC0+STAmwiNi92MS97cGFyZW50PXByb2plY3RzLyovbG9jYXRpb25z",
            "Lyp9OmJhdGNoT3B0aW1pemVUb3VyczoBKlovIiovdjEve3BhcmVudD1wcm9q",
            "ZWN0cy8qfTpiYXRjaE9wdGltaXplVG91cnM6ASoaVMpBIHJvdXRlb3B0aW1p",
            "emF0aW9uLmdvb2dsZWFwaXMuY29t0kEuaHR0cHM6Ly93d3cuZ29vZ2xlYXBp",
            "cy5jb20vYXV0aC9jbG91ZC1wbGF0Zm9ybUKNAgokY29tLmdvb2dsZS5tYXBz",
            "LnJvdXRlb3B0aW1pemF0aW9uLnYxQh1Sb3V0ZU9wdGltaXphdGlvblNlcnZp",
            "Y2VQcm90b1ABWlhjbG91ZC5nb29nbGUuY29tL2dvL21hcHMvcm91dGVvcHRp",
            "bWl6YXRpb24vYXBpdjEvcm91dGVvcHRpbWl6YXRpb25wYjtyb3V0ZW9wdGlt",
            "aXphdGlvbnBiqgIgR29vZ2xlLk1hcHMuUm91dGVPcHRpbWl6YXRpb24uVjHK",
            "AiBHb29nbGVcTWFwc1xSb3V0ZU9wdGltaXphdGlvblxWMeoCI0dvb2dsZTo6",
            "TWFwczo6Um91dGVPcHRpbWl6YXRpb246OlYxYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.AnnotationsReflection.Descriptor, global::Google.Api.ClientReflection.Descriptor, global::Google.Api.FieldBehaviorReflection.Descriptor, global::Google.LongRunning.OperationsReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, global::Google.Type.LatlngReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Google.Maps.RouteOptimization.V1.DataFormat), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.BatchOptimizeToursRequest), global::Google.Maps.RouteOptimization.V1.BatchOptimizeToursRequest.Parser, new[]{ "Parent", "ModelConfigs" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.BatchOptimizeToursRequest.Types.AsyncModelConfig), global::Google.Maps.RouteOptimization.V1.BatchOptimizeToursRequest.Types.AsyncModelConfig.Parser, new[]{ "DisplayName", "InputConfig", "OutputConfig" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.BatchOptimizeToursResponse), global::Google.Maps.RouteOptimization.V1.BatchOptimizeToursResponse.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.BatchOptimizeToursMetadata), global::Google.Maps.RouteOptimization.V1.BatchOptimizeToursMetadata.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest), global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest.Parser, new[]{ "Parent", "Timeout", "Model", "SolvingMode", "SearchMode", "InjectedFirstSolutionRoutes", "InjectedSolutionConstraint", "RefreshDetailsRoutes", "InterpretInjectedSolutionsUsingLabels", "ConsiderRoadTraffic", "PopulatePolylines", "PopulateTransitionPolylines", "AllowLargeDeadlineDespiteInterruptionRisk", "UseGeodesicDistances", "GeodesicMetersPerSecond", "MaxValidationErrors", "Label" }, new[]{ "GeodesicMetersPerSecond", "MaxValidationErrors" }, new[]{ typeof(global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest.Types.SolvingMode), typeof(global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest.Types.SearchMode) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.OptimizeToursResponse), global::Google.Maps.RouteOptimization.V1.OptimizeToursResponse.Parser, new[]{ "Routes", "RequestLabel", "SkippedShipments", "ValidationErrors", "Metrics" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.OptimizeToursResponse.Types.Metrics), global::Google.Maps.RouteOptimization.V1.OptimizeToursResponse.Types.Metrics.Parser, new[]{ "AggregatedRouteMetrics", "SkippedMandatoryShipmentCount", "UsedVehicleCount", "EarliestVehicleStartTime", "LatestVehicleEndTime", "Costs", "TotalCost" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, })}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.ShipmentModel), global::Google.Maps.RouteOptimization.V1.ShipmentModel.Parser, new[]{ "Shipments", "Vehicles", "MaxActiveVehicles", "GlobalStartTime", "GlobalEndTime", "GlobalDurationCostPerHour", "DurationDistanceMatrices", "DurationDistanceMatrixSrcTags", "DurationDistanceMatrixDstTags", "TransitionAttributes", "ShipmentTypeIncompatibilities", "ShipmentTypeRequirements", "PrecedenceRules" }, new[]{ "MaxActiveVehicles" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.ShipmentModel.Types.DurationDistanceMatrix), global::Google.Maps.RouteOptimization.V1.ShipmentModel.Types.DurationDistanceMatrix.Parser, new[]{ "Rows", "VehicleStartTag" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.ShipmentModel.Types.DurationDistanceMatrix.Types.Row), global::Google.Maps.RouteOptimization.V1.ShipmentModel.Types.DurationDistanceMatrix.Types.Row.Parser, new[]{ "Durations", "Meters" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.ShipmentModel.Types.PrecedenceRule), global::Google.Maps.RouteOptimization.V1.ShipmentModel.Types.PrecedenceRule.Parser, new[]{ "FirstIndex", "FirstIsDelivery", "SecondIndex", "SecondIsDelivery", "OffsetDuration" }, new[]{ "FirstIndex", "SecondIndex" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.Shipment), global::Google.Maps.RouteOptimization.V1.Shipment.Parser, new[]{ "DisplayName", "Pickups", "Deliveries", "LoadDemands", "PenaltyCost", "AllowedVehicleIndices", "CostsPerVehicle", "CostsPerVehicleIndices", "PickupToDeliveryRelativeDetourLimit", "PickupToDeliveryAbsoluteDetourLimit", "PickupToDeliveryTimeLimit", "ShipmentType", "Label", "Ignore" }, new[]{ "PenaltyCost", "PickupToDeliveryRelativeDetourLimit" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.Shipment.Types.VisitRequest), global::Google.Maps.RouteOptimization.V1.Shipment.Types.VisitRequest.Parser, new[]{ "ArrivalLocation", "ArrivalWaypoint", "DepartureLocation", "DepartureWaypoint", "Tags", "TimeWindows", "Duration", "Cost", "LoadDemands", "VisitTypes", "Label" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.Shipment.Types.Load), global::Google.Maps.RouteOptimization.V1.Shipment.Types.Load.Parser, new[]{ "Amount" }, null, null, null, null),
            null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.ShipmentTypeIncompatibility), global::Google.Maps.RouteOptimization.V1.ShipmentTypeIncompatibility.Parser, new[]{ "Types_", "IncompatibilityMode" }, null, new[]{ typeof(global::Google.Maps.RouteOptimization.V1.ShipmentTypeIncompatibility.Types.IncompatibilityMode) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.ShipmentTypeRequirement), global::Google.Maps.RouteOptimization.V1.ShipmentTypeRequirement.Parser, new[]{ "RequiredShipmentTypeAlternatives", "DependentShipmentTypes", "RequirementMode" }, null, new[]{ typeof(global::Google.Maps.RouteOptimization.V1.ShipmentTypeRequirement.Types.RequirementMode) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.RouteModifiers), global::Google.Maps.RouteOptimization.V1.RouteModifiers.Parser, new[]{ "AvoidTolls", "AvoidHighways", "AvoidFerries", "AvoidIndoor" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.Vehicle), global::Google.Maps.RouteOptimization.V1.Vehicle.Parser, new[]{ "DisplayName", "TravelMode", "RouteModifiers", "StartLocation", "StartWaypoint", "EndLocation", "EndWaypoint", "StartTags", "EndTags", "StartTimeWindows", "EndTimeWindows", "TravelDurationMultiple", "UnloadingPolicy", "LoadLimits", "CostPerHour", "CostPerTraveledHour", "CostPerKilometer", "FixedCost", "UsedIfRouteIsEmpty", "RouteDurationLimit", "TravelDurationLimit", "RouteDistanceLimit", "ExtraVisitDurationForVisitType", "BreakRule", "Label", "Ignore" }, new[]{ "TravelDurationMultiple" }, new[]{ typeof(global::Google.Maps.RouteOptimization.V1.Vehicle.Types.TravelMode), typeof(global::Google.Maps.RouteOptimization.V1.Vehicle.Types.UnloadingPolicy) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.Vehicle.Types.LoadLimit), global::Google.Maps.RouteOptimization.V1.Vehicle.Types.LoadLimit.Parser, new[]{ "MaxLoad", "SoftMaxLoad", "CostPerUnitAboveSoftMax", "StartLoadInterval", "EndLoadInterval" }, new[]{ "MaxLoad" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.Vehicle.Types.LoadLimit.Types.Interval), global::Google.Maps.RouteOptimization.V1.Vehicle.Types.LoadLimit.Types.Interval.Parser, new[]{ "Min", "Max" }, new[]{ "Max" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.Vehicle.Types.DurationLimit), global::Google.Maps.RouteOptimization.V1.Vehicle.Types.DurationLimit.Parser, new[]{ "MaxDuration", "SoftMaxDuration", "CostPerHourAfterSoftMax", "QuadraticSoftMaxDuration", "CostPerSquareHourAfterQuadraticSoftMax" }, new[]{ "CostPerHourAfterSoftMax", "CostPerSquareHourAfterQuadraticSoftMax" }, null, null, null),
            null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.TimeWindow), global::Google.Maps.RouteOptimization.V1.TimeWindow.Parser, new[]{ "StartTime", "EndTime", "SoftStartTime", "SoftEndTime", "CostPerHourBeforeSoftStartTime", "CostPerHourAfterSoftEndTime" }, new[]{ "CostPerHourBeforeSoftStartTime", "CostPerHourAfterSoftEndTime" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.DistanceLimit), global::Google.Maps.RouteOptimization.V1.DistanceLimit.Parser, new[]{ "MaxMeters", "SoftMaxMeters", "CostPerKilometerBelowSoftMax", "CostPerKilometerAboveSoftMax" }, new[]{ "MaxMeters", "SoftMaxMeters", "CostPerKilometerBelowSoftMax", "CostPerKilometerAboveSoftMax" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.TransitionAttributes), global::Google.Maps.RouteOptimization.V1.TransitionAttributes.Parser, new[]{ "SrcTag", "ExcludedSrcTag", "DstTag", "ExcludedDstTag", "Cost", "CostPerKilometer", "DistanceLimit", "Delay" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.Waypoint), global::Google.Maps.RouteOptimization.V1.Waypoint.Parser, new[]{ "Location", "PlaceId", "SideOfRoad" }, new[]{ "LocationType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.Location), global::Google.Maps.RouteOptimization.V1.Location.Parser, new[]{ "LatLng", "Heading" }, new[]{ "Heading" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.BreakRule), global::Google.Maps.RouteOptimization.V1.BreakRule.Parser, new[]{ "BreakRequests", "FrequencyConstraints" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.BreakRule.Types.BreakRequest), global::Google.Maps.RouteOptimization.V1.BreakRule.Types.BreakRequest.Parser, new[]{ "EarliestStartTime", "LatestStartTime", "MinDuration" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.BreakRule.Types.FrequencyConstraint), global::Google.Maps.RouteOptimization.V1.BreakRule.Types.FrequencyConstraint.Parser, new[]{ "MinBreakDuration", "MaxInterBreakDuration" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.ShipmentRoute), global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Parser, new[]{ "VehicleIndex", "VehicleLabel", "VehicleStartTime", "VehicleEndTime", "Visits", "Transitions", "HasTrafficInfeasibilities", "RoutePolyline", "Breaks", "Metrics", "RouteCosts", "RouteTotalCost" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.Visit), global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.Visit.Parser, new[]{ "ShipmentIndex", "IsPickup", "VisitRequestIndex", "StartTime", "LoadDemands", "Detour", "ShipmentLabel", "VisitLabel" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.Transition), global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.Transition.Parser, new[]{ "TravelDuration", "TravelDistanceMeters", "TrafficInfoUnavailable", "DelayDuration", "BreakDuration", "WaitDuration", "TotalDuration", "StartTime", "RoutePolyline", "RouteToken", "VehicleLoads" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.VehicleLoad), global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.VehicleLoad.Parser, new[]{ "Amount" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.EncodedPolyline), global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.EncodedPolyline.Parser, new[]{ "Points" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.Break), global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.Break.Parser, new[]{ "StartTime", "Duration" }, null, null, null, null),
            null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.SkippedShipment), global::Google.Maps.RouteOptimization.V1.SkippedShipment.Parser, new[]{ "Index", "Label", "Reasons" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.SkippedShipment.Types.Reason), global::Google.Maps.RouteOptimization.V1.SkippedShipment.Types.Reason.Parser, new[]{ "Code", "ExampleVehicleIndex", "ExampleExceededCapacityType" }, new[]{ "ExampleVehicleIndex" }, new[]{ typeof(global::Google.Maps.RouteOptimization.V1.SkippedShipment.Types.Reason.Types.Code) }, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.AggregatedMetrics), global::Google.Maps.RouteOptimization.V1.AggregatedMetrics.Parser, new[]{ "PerformedShipmentCount", "TravelDuration", "WaitDuration", "DelayDuration", "BreakDuration", "VisitDuration", "TotalDuration", "TravelDistanceMeters", "MaxLoads" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint), global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Parser, new[]{ "Routes", "SkippedShipments", "ConstraintRelaxations" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation), global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation.Parser, new[]{ "Relaxations", "VehicleIndices" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation.Types.Relaxation), global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation.Types.Relaxation.Parser, new[]{ "Level", "ThresholdTime", "ThresholdVisitCount" }, null, new[]{ typeof(global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation.Types.Relaxation.Types.Level) }, null, null)})}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.OptimizeToursValidationError), global::Google.Maps.RouteOptimization.V1.OptimizeToursValidationError.Parser, new[]{ "Code", "DisplayName", "Fields", "ErrorMessage", "OffendingValues" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.OptimizeToursValidationError.Types.FieldReference), global::Google.Maps.RouteOptimization.V1.OptimizeToursValidationError.Types.FieldReference.Parser, new[]{ "Name", "Index", "Key", "SubField" }, new[]{ "IndexOrKey" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.InputConfig), global::Google.Maps.RouteOptimization.V1.InputConfig.Parser, new[]{ "GcsSource", "DataFormat" }, new[]{ "Source" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.OutputConfig), global::Google.Maps.RouteOptimization.V1.OutputConfig.Parser, new[]{ "GcsDestination", "DataFormat" }, new[]{ "Destination" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.GcsSource), global::Google.Maps.RouteOptimization.V1.GcsSource.Parser, new[]{ "Uri" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.RouteOptimization.V1.GcsDestination), global::Google.Maps.RouteOptimization.V1.GcsDestination.Parser, new[]{ "Uri" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// Data formats for input and output files.
  /// </summary>
  public enum DataFormat {
    /// <summary>
    /// Invalid value, format must not be UNSPECIFIED.
    /// </summary>
    [pbr::OriginalName("DATA_FORMAT_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// JavaScript Object Notation.
    /// </summary>
    [pbr::OriginalName("JSON")] Json = 1,
    /// <summary>
    /// Protocol Buffers text format.  See
    /// https://protobuf.dev/reference/protobuf/textformat-spec/
    /// </summary>
    [pbr::OriginalName("PROTO_TEXT")] ProtoText = 2,
  }

  #endregion

  #region Messages
  /// <summary>
  /// Request to batch optimize tours as an asynchronous operation.
  /// Each input file should contain one `OptimizeToursRequest`, and each output
  /// file will contain one `OptimizeToursResponse`. The request contains
  /// information to read/write and parse the files. All the input and output files
  /// should be under the same project.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class BatchOptimizeToursRequest : pb::IMessage<BatchOptimizeToursRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<BatchOptimizeToursRequest> _parser = new pb::MessageParser<BatchOptimizeToursRequest>(() => new BatchOptimizeToursRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<BatchOptimizeToursRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BatchOptimizeToursRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BatchOptimizeToursRequest(BatchOptimizeToursRequest other) : this() {
      parent_ = other.parent_;
      modelConfigs_ = other.modelConfigs_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BatchOptimizeToursRequest Clone() {
      return new BatchOptimizeToursRequest(this);
    }

    /// <summary>Field number for the "parent" field.</summary>
    public const int ParentFieldNumber = 1;
    private string parent_ = "";
    /// <summary>
    /// Required. Target project and location to make a call.
    ///
    /// Format:
    /// * `projects/{project-id}`
    /// * `projects/{project-id}/locations/{location-id}`
    ///
    /// If no location is specified, a region will be chosen automatically.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Parent {
      get { return parent_; }
      set {
        parent_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "model_configs" field.</summary>
    public const int ModelConfigsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.BatchOptimizeToursRequest.Types.AsyncModelConfig> _repeated_modelConfigs_codec
        = pb::FieldCodec.ForMessage(18, global::Google.Maps.RouteOptimization.V1.BatchOptimizeToursRequest.Types.AsyncModelConfig.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.BatchOptimizeToursRequest.Types.AsyncModelConfig> modelConfigs_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.BatchOptimizeToursRequest.Types.AsyncModelConfig>();
    /// <summary>
    /// Required. Input/Output information each purchase model, such as file paths
    /// and data formats.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.BatchOptimizeToursRequest.Types.AsyncModelConfig> ModelConfigs {
      get { return modelConfigs_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as BatchOptimizeToursRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(BatchOptimizeToursRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Parent != other.Parent) return false;
      if(!modelConfigs_.Equals(other.modelConfigs_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Parent.Length != 0) hash ^= Parent.GetHashCode();
      hash ^= modelConfigs_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Parent.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Parent);
      }
      modelConfigs_.WriteTo(output, _repeated_modelConfigs_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Parent.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Parent);
      }
      modelConfigs_.WriteTo(ref output, _repeated_modelConfigs_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Parent.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Parent);
      }
      size += modelConfigs_.CalculateSize(_repeated_modelConfigs_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(BatchOptimizeToursRequest other) {
      if (other == null) {
        return;
      }
      if (other.Parent.Length != 0) {
        Parent = other.Parent;
      }
      modelConfigs_.Add(other.modelConfigs_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Parent = input.ReadString();
            break;
          }
          case 18: {
            modelConfigs_.AddEntriesFrom(input, _repeated_modelConfigs_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Parent = input.ReadString();
            break;
          }
          case 18: {
            modelConfigs_.AddEntriesFrom(ref input, _repeated_modelConfigs_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the BatchOptimizeToursRequest message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Information for solving one optimization model asynchronously.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class AsyncModelConfig : pb::IMessage<AsyncModelConfig>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<AsyncModelConfig> _parser = new pb::MessageParser<AsyncModelConfig>(() => new AsyncModelConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<AsyncModelConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.RouteOptimization.V1.BatchOptimizeToursRequest.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public AsyncModelConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public AsyncModelConfig(AsyncModelConfig other) : this() {
          displayName_ = other.displayName_;
          inputConfig_ = other.inputConfig_ != null ? other.inputConfig_.Clone() : null;
          outputConfig_ = other.outputConfig_ != null ? other.outputConfig_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public AsyncModelConfig Clone() {
          return new AsyncModelConfig(this);
        }

        /// <summary>Field number for the "display_name" field.</summary>
        public const int DisplayNameFieldNumber = 1;
        private string displayName_ = "";
        /// <summary>
        /// Optional. User defined model name, can be used as alias by users to keep
        /// track of models.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string DisplayName {
          get { return displayName_; }
          set {
            displayName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "input_config" field.</summary>
        public const int InputConfigFieldNumber = 2;
        private global::Google.Maps.RouteOptimization.V1.InputConfig inputConfig_;
        /// <summary>
        /// Required. Information about the input model.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Maps.RouteOptimization.V1.InputConfig InputConfig {
          get { return inputConfig_; }
          set {
            inputConfig_ = value;
          }
        }

        /// <summary>Field number for the "output_config" field.</summary>
        public const int OutputConfigFieldNumber = 3;
        private global::Google.Maps.RouteOptimization.V1.OutputConfig outputConfig_;
        /// <summary>
        /// Required. The desired output location information.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Maps.RouteOptimization.V1.OutputConfig OutputConfig {
          get { return outputConfig_; }
          set {
            outputConfig_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as AsyncModelConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(AsyncModelConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (DisplayName != other.DisplayName) return false;
          if (!object.Equals(InputConfig, other.InputConfig)) return false;
          if (!object.Equals(OutputConfig, other.OutputConfig)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (DisplayName.Length != 0) hash ^= DisplayName.GetHashCode();
          if (inputConfig_ != null) hash ^= InputConfig.GetHashCode();
          if (outputConfig_ != null) hash ^= OutputConfig.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (DisplayName.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(DisplayName);
          }
          if (inputConfig_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(InputConfig);
          }
          if (outputConfig_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(OutputConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (DisplayName.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(DisplayName);
          }
          if (inputConfig_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(InputConfig);
          }
          if (outputConfig_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(OutputConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (DisplayName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(DisplayName);
          }
          if (inputConfig_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(InputConfig);
          }
          if (outputConfig_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(OutputConfig);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(AsyncModelConfig other) {
          if (other == null) {
            return;
          }
          if (other.DisplayName.Length != 0) {
            DisplayName = other.DisplayName;
          }
          if (other.inputConfig_ != null) {
            if (inputConfig_ == null) {
              InputConfig = new global::Google.Maps.RouteOptimization.V1.InputConfig();
            }
            InputConfig.MergeFrom(other.InputConfig);
          }
          if (other.outputConfig_ != null) {
            if (outputConfig_ == null) {
              OutputConfig = new global::Google.Maps.RouteOptimization.V1.OutputConfig();
            }
            OutputConfig.MergeFrom(other.OutputConfig);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                DisplayName = input.ReadString();
                break;
              }
              case 18: {
                if (inputConfig_ == null) {
                  InputConfig = new global::Google.Maps.RouteOptimization.V1.InputConfig();
                }
                input.ReadMessage(InputConfig);
                break;
              }
              case 26: {
                if (outputConfig_ == null) {
                  OutputConfig = new global::Google.Maps.RouteOptimization.V1.OutputConfig();
                }
                input.ReadMessage(OutputConfig);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                DisplayName = input.ReadString();
                break;
              }
              case 18: {
                if (inputConfig_ == null) {
                  InputConfig = new global::Google.Maps.RouteOptimization.V1.InputConfig();
                }
                input.ReadMessage(InputConfig);
                break;
              }
              case 26: {
                if (outputConfig_ == null) {
                  OutputConfig = new global::Google.Maps.RouteOptimization.V1.OutputConfig();
                }
                input.ReadMessage(OutputConfig);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Response to a `BatchOptimizeToursRequest`. This is returned in
  /// the Long Running Operation after the operation is complete.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class BatchOptimizeToursResponse : pb::IMessage<BatchOptimizeToursResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<BatchOptimizeToursResponse> _parser = new pb::MessageParser<BatchOptimizeToursResponse>(() => new BatchOptimizeToursResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<BatchOptimizeToursResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BatchOptimizeToursResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BatchOptimizeToursResponse(BatchOptimizeToursResponse other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BatchOptimizeToursResponse Clone() {
      return new BatchOptimizeToursResponse(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as BatchOptimizeToursResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(BatchOptimizeToursResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(BatchOptimizeToursResponse other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Operation metadata for `BatchOptimizeToursRequest` calls.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class BatchOptimizeToursMetadata : pb::IMessage<BatchOptimizeToursMetadata>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<BatchOptimizeToursMetadata> _parser = new pb::MessageParser<BatchOptimizeToursMetadata>(() => new BatchOptimizeToursMetadata());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<BatchOptimizeToursMetadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BatchOptimizeToursMetadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BatchOptimizeToursMetadata(BatchOptimizeToursMetadata other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BatchOptimizeToursMetadata Clone() {
      return new BatchOptimizeToursMetadata(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as BatchOptimizeToursMetadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(BatchOptimizeToursMetadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(BatchOptimizeToursMetadata other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Request to be given to a tour optimization solver which defines the
  /// shipment model to solve as well as optimization parameters.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class OptimizeToursRequest : pb::IMessage<OptimizeToursRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OptimizeToursRequest> _parser = new pb::MessageParser<OptimizeToursRequest>(() => new OptimizeToursRequest());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<OptimizeToursRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OptimizeToursRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OptimizeToursRequest(OptimizeToursRequest other) : this() {
      _hasBits0 = other._hasBits0;
      parent_ = other.parent_;
      timeout_ = other.timeout_ != null ? other.timeout_.Clone() : null;
      model_ = other.model_ != null ? other.model_.Clone() : null;
      solvingMode_ = other.solvingMode_;
      searchMode_ = other.searchMode_;
      injectedFirstSolutionRoutes_ = other.injectedFirstSolutionRoutes_.Clone();
      injectedSolutionConstraint_ = other.injectedSolutionConstraint_ != null ? other.injectedSolutionConstraint_.Clone() : null;
      refreshDetailsRoutes_ = other.refreshDetailsRoutes_.Clone();
      interpretInjectedSolutionsUsingLabels_ = other.interpretInjectedSolutionsUsingLabels_;
      considerRoadTraffic_ = other.considerRoadTraffic_;
      populatePolylines_ = other.populatePolylines_;
      populateTransitionPolylines_ = other.populateTransitionPolylines_;
      allowLargeDeadlineDespiteInterruptionRisk_ = other.allowLargeDeadlineDespiteInterruptionRisk_;
      useGeodesicDistances_ = other.useGeodesicDistances_;
      geodesicMetersPerSecond_ = other.geodesicMetersPerSecond_;
      maxValidationErrors_ = other.maxValidationErrors_;
      label_ = other.label_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OptimizeToursRequest Clone() {
      return new OptimizeToursRequest(this);
    }

    /// <summary>Field number for the "parent" field.</summary>
    public const int ParentFieldNumber = 1;
    private string parent_ = "";
    /// <summary>
    /// Required. Target project or location to make a call.
    ///
    /// Format:
    /// * `projects/{project-id}`
    /// * `projects/{project-id}/locations/{location-id}`
    ///
    /// If no location is specified, a region will be chosen automatically.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Parent {
      get { return parent_; }
      set {
        parent_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "timeout" field.</summary>
    public const int TimeoutFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Duration timeout_;
    /// <summary>
    /// If this timeout is set, the server returns a response before the timeout
    /// period has elapsed or the server deadline for synchronous requests is
    /// reached, whichever is sooner.
    ///
    /// For asynchronous requests, the server will generate a solution (if
    /// possible) before the timeout has elapsed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration Timeout {
      get { return timeout_; }
      set {
        timeout_ = value;
      }
    }

    /// <summary>Field number for the "model" field.</summary>
    public const int ModelFieldNumber = 3;
    private global::Google.Maps.RouteOptimization.V1.ShipmentModel model_;
    /// <summary>
    /// Shipment model to solve.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.ShipmentModel Model {
      get { return model_; }
      set {
        model_ = value;
      }
    }

    /// <summary>Field number for the "solving_mode" field.</summary>
    public const int SolvingModeFieldNumber = 4;
    private global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest.Types.SolvingMode solvingMode_ = global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest.Types.SolvingMode.DefaultSolve;
    /// <summary>
    /// By default, the solving mode is `DEFAULT_SOLVE` (0).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest.Types.SolvingMode SolvingMode {
      get { return solvingMode_; }
      set {
        solvingMode_ = value;
      }
    }

    /// <summary>Field number for the "search_mode" field.</summary>
    public const int SearchModeFieldNumber = 6;
    private global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest.Types.SearchMode searchMode_ = global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest.Types.SearchMode.Unspecified;
    /// <summary>
    /// Search mode used to solve the request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest.Types.SearchMode SearchMode {
      get { return searchMode_; }
      set {
        searchMode_ = value;
      }
    }

    /// <summary>Field number for the "injected_first_solution_routes" field.</summary>
    public const int InjectedFirstSolutionRoutesFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.ShipmentRoute> _repeated_injectedFirstSolutionRoutes_codec
        = pb::FieldCodec.ForMessage(58, global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentRoute> injectedFirstSolutionRoutes_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentRoute>();
    /// <summary>
    /// Guide the optimization algorithm in finding a first solution that is
    /// similar to a previous solution.
    ///
    /// The model is constrained when the first solution is built.
    /// Any shipments not performed on a route are implicitly skipped in the first
    /// solution, but they may be performed in successive solutions.
    ///
    /// The solution must satisfy some basic validity assumptions:
    ///
    ///   * for all routes, `vehicle_index` must be in range and not be duplicated.
    ///   * for all visits, `shipment_index` and `visit_request_index` must be
    ///     in range.
    ///   * a shipment may only be referenced on one route.
    ///   * the pickup of a pickup-delivery shipment must be performed before
    ///     the delivery.
    ///   * no more than one pickup alternative or delivery alternative of
    ///     a shipment may be performed.
    ///   * for all routes, times are increasing (i.e., `vehicle_start_time
    ///     &lt;= visits[0].start_time &lt;= visits[1].start_time ...
    ///     &lt;= vehicle_end_time`).
    ///   * a shipment may only be performed on a vehicle that is allowed. A
    ///     vehicle is allowed if
    ///     [Shipment.allowed_vehicle_indices][google.maps.routeoptimization.v1.Shipment.allowed_vehicle_indices]
    ///     is empty or its `vehicle_index` is included in
    ///     [Shipment.allowed_vehicle_indices][google.maps.routeoptimization.v1.Shipment.allowed_vehicle_indices].
    ///
    /// If the injected solution is not feasible, a validation error is not
    /// necessarily returned and an error indicating infeasibility may be returned
    /// instead.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentRoute> InjectedFirstSolutionRoutes {
      get { return injectedFirstSolutionRoutes_; }
    }

    /// <summary>Field number for the "injected_solution_constraint" field.</summary>
    public const int InjectedSolutionConstraintFieldNumber = 8;
    private global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint injectedSolutionConstraint_;
    /// <summary>
    /// Constrain the optimization algorithm to find a final solution that is
    /// similar to a previous solution. For example, this may be used to freeze
    /// portions of routes which have already been completed or which are to be
    /// completed but must not be modified.
    ///
    /// If the injected solution is not feasible, a validation error is not
    /// necessarily returned and an error indicating infeasibility may be returned
    /// instead.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint InjectedSolutionConstraint {
      get { return injectedSolutionConstraint_; }
      set {
        injectedSolutionConstraint_ = value;
      }
    }

    /// <summary>Field number for the "refresh_details_routes" field.</summary>
    public const int RefreshDetailsRoutesFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.ShipmentRoute> _repeated_refreshDetailsRoutes_codec
        = pb::FieldCodec.ForMessage(74, global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentRoute> refreshDetailsRoutes_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentRoute>();
    /// <summary>
    /// If non-empty, the given routes will be refreshed, without modifying their
    /// underlying sequence of visits or travel times: only other details will be
    /// updated. This does not solve the model.
    ///
    /// As of 2020/11, this only populates the polylines of non-empty routes and
    /// requires that `populate_polylines` is true.
    ///
    /// The `route_polyline` fields of the passed-in routes may be inconsistent
    /// with route `transitions`.
    ///
    /// This field must not be used together with `injected_first_solution_routes`
    /// or `injected_solution_constraint`.
    ///
    /// `Shipment.ignore` and `Vehicle.ignore` have no effect on the behavior.
    /// Polylines are still populated between all visits in all non-empty routes
    /// regardless of whether the related shipments or vehicles are ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentRoute> RefreshDetailsRoutes {
      get { return refreshDetailsRoutes_; }
    }

    /// <summary>Field number for the "interpret_injected_solutions_using_labels" field.</summary>
    public const int InterpretInjectedSolutionsUsingLabelsFieldNumber = 10;
    private bool interpretInjectedSolutionsUsingLabels_;
    /// <summary>
    /// If true:
    ///
    ///   * uses
    ///   [ShipmentRoute.vehicle_label][google.maps.routeoptimization.v1.ShipmentRoute.vehicle_label]
    ///   instead of `vehicle_index` to
    ///     match routes in an injected solution with vehicles in the request;
    ///     reuses the mapping of original
    ///     [ShipmentRoute.vehicle_index][google.maps.routeoptimization.v1.ShipmentRoute.vehicle_index]
    ///     to new
    ///     [ShipmentRoute.vehicle_index][google.maps.routeoptimization.v1.ShipmentRoute.vehicle_index]
    ///     to update
    ///     [ConstraintRelaxation.vehicle_indices][google.maps.routeoptimization.v1.InjectedSolutionConstraint.ConstraintRelaxation.vehicle_indices]
    ///     if non-empty, but the mapping must be unambiguous (i.e., multiple
    ///     `ShipmentRoute`s must not share the same original `vehicle_index`).
    ///   * uses
    ///   [ShipmentRoute.Visit.shipment_label][google.maps.routeoptimization.v1.ShipmentRoute.Visit.shipment_label]
    ///   instead of `shipment_index`
    ///     to match visits in an injected solution with shipments in the request;
    ///   * uses
    ///   [SkippedShipment.label][google.maps.routeoptimization.v1.SkippedShipment.label]
    ///   instead of
    ///   [SkippedShipment.index][google.maps.routeoptimization.v1.SkippedShipment.index]
    ///   to
    ///     match skipped shipments in the injected solution with request
    ///     shipments.
    ///
    /// This interpretation applies to the `injected_first_solution_routes`,
    /// `injected_solution_constraint`, and `refresh_details_routes` fields.
    /// It can be used when shipment or vehicle indices in the request have
    /// changed since the solution was created, perhaps because shipments or
    /// vehicles have been removed from or added to the request.
    ///
    /// If true, labels in the following categories must appear at most once in
    /// their category:
    ///
    ///   * [Vehicle.label][google.maps.routeoptimization.v1.Vehicle.label] in the
    ///   request;
    ///   * [Shipment.label][google.maps.routeoptimization.v1.Shipment.label] in
    ///   the request;
    ///   * [ShipmentRoute.vehicle_label][google.maps.routeoptimization.v1.ShipmentRoute.vehicle_label] in the injected solution;
    ///   * [SkippedShipment.label][google.maps.routeoptimization.v1.SkippedShipment.label] and [ShipmentRoute.Visit.shipment_label][google.maps.routeoptimization.v1.ShipmentRoute.Visit.shipment_label] in
    ///     the injected solution (except pickup/delivery visit pairs, whose
    ///     `shipment_label` must appear twice).
    ///
    /// If a `vehicle_label` in the injected solution does not correspond to a
    /// request vehicle, the corresponding route is removed from the solution
    /// along with its visits. If a `shipment_label` in the injected solution does
    /// not correspond to a request shipment, the corresponding visit is removed
    /// from the solution. If a
    /// [SkippedShipment.label][google.maps.routeoptimization.v1.SkippedShipment.label]
    /// in the injected solution does not correspond to a request shipment, the
    /// `SkippedShipment` is removed from the solution.
    ///
    /// Removing route visits or entire routes from an injected solution may
    /// have an effect on the implied constraints, which may lead to change in
    /// solution, validation errors, or infeasibility.
    ///
    /// NOTE: The caller must ensure that each
    /// [Vehicle.label][google.maps.routeoptimization.v1.Vehicle.label] (resp.
    /// [Shipment.label][google.maps.routeoptimization.v1.Shipment.label]) uniquely
    /// identifies a vehicle (resp. shipment) entity used across the two relevant
    /// requests: the past request that produced the `OptimizeToursResponse` used
    /// in the injected solution and the current request that includes the injected
    /// solution. The uniqueness checks described above are not enough to guarantee
    /// this requirement.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool InterpretInjectedSolutionsUsingLabels {
      get { return interpretInjectedSolutionsUsingLabels_; }
      set {
        interpretInjectedSolutionsUsingLabels_ = value;
      }
    }

    /// <summary>Field number for the "consider_road_traffic" field.</summary>
    public const int ConsiderRoadTrafficFieldNumber = 11;
    private bool considerRoadTraffic_;
    /// <summary>
    /// Consider traffic estimation in calculating `ShipmentRoute` fields
    /// [Transition.travel_duration][google.maps.routeoptimization.v1.ShipmentRoute.Transition.travel_duration],
    /// [Visit.start_time][google.maps.routeoptimization.v1.ShipmentRoute.Visit.start_time],
    /// and `vehicle_end_time`; in setting the
    /// [ShipmentRoute.has_traffic_infeasibilities][google.maps.routeoptimization.v1.ShipmentRoute.has_traffic_infeasibilities]
    /// field, and in calculating the
    /// [OptimizeToursResponse.total_cost][google.maps.routeoptimization.v1.OptimizeToursResponse.total_cost]
    /// field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ConsiderRoadTraffic {
      get { return considerRoadTraffic_; }
      set {
        considerRoadTraffic_ = value;
      }
    }

    /// <summary>Field number for the "populate_polylines" field.</summary>
    public const int PopulatePolylinesFieldNumber = 12;
    private bool populatePolylines_;
    /// <summary>
    /// If true, polylines will be populated in response `ShipmentRoute`s.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool PopulatePolylines {
      get { return populatePolylines_; }
      set {
        populatePolylines_ = value;
      }
    }

    /// <summary>Field number for the "populate_transition_polylines" field.</summary>
    public const int PopulateTransitionPolylinesFieldNumber = 13;
    private bool populateTransitionPolylines_;
    /// <summary>
    /// If true, polylines and route tokens will be populated in response
    /// [ShipmentRoute.transitions][google.maps.routeoptimization.v1.ShipmentRoute.transitions].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool PopulateTransitionPolylines {
      get { return populateTransitionPolylines_; }
      set {
        populateTransitionPolylines_ = value;
      }
    }

    /// <summary>Field number for the "allow_large_deadline_despite_interruption_risk" field.</summary>
    public const int AllowLargeDeadlineDespiteInterruptionRiskFieldNumber = 14;
    private bool allowLargeDeadlineDespiteInterruptionRisk_;
    /// <summary>
    /// If this is set, then the request can have a deadline
    /// (see https://grpc.io/blog/deadlines) of up to 60 minutes.
    /// Otherwise, the maximum deadline is only 30 minutes.
    /// Note that long-lived requests have a significantly larger (but still small)
    /// risk of interruption.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AllowLargeDeadlineDespiteInterruptionRisk {
      get { return allowLargeDeadlineDespiteInterruptionRisk_; }
      set {
        allowLargeDeadlineDespiteInterruptionRisk_ = value;
      }
    }

    /// <summary>Field number for the "use_geodesic_distances" field.</summary>
    public const int UseGeodesicDistancesFieldNumber = 15;
    private bool useGeodesicDistances_;
    /// <summary>
    /// If true, travel distances will be computed using geodesic distances instead
    /// of Google Maps distances, and travel times will be computed using geodesic
    /// distances with a speed defined by `geodesic_meters_per_second`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool UseGeodesicDistances {
      get { return useGeodesicDistances_; }
      set {
        useGeodesicDistances_ = value;
      }
    }

    /// <summary>Field number for the "geodesic_meters_per_second" field.</summary>
    public const int GeodesicMetersPerSecondFieldNumber = 16;
    private readonly static double GeodesicMetersPerSecondDefaultValue = 0D;

    private double geodesicMetersPerSecond_;
    /// <summary>
    /// When `use_geodesic_distances` is true, this field must be set and defines
    /// the speed applied to compute travel times. Its value must be at least 1.0
    /// meters/seconds.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double GeodesicMetersPerSecond {
      get { if ((_hasBits0 & 2) != 0) { return geodesicMetersPerSecond_; } else { return GeodesicMetersPerSecondDefaultValue; } }
      set {
        _hasBits0 |= 2;
        geodesicMetersPerSecond_ = value;
      }
    }
    /// <summary>Gets whether the "geodesic_meters_per_second" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGeodesicMetersPerSecond {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "geodesic_meters_per_second" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGeodesicMetersPerSecond() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "max_validation_errors" field.</summary>
    public const int MaxValidationErrorsFieldNumber = 5;
    private readonly static int MaxValidationErrorsDefaultValue = 0;

    private int maxValidationErrors_;
    /// <summary>
    /// Truncates the number of validation errors returned. These errors are
    /// typically attached to an INVALID_ARGUMENT error payload as a BadRequest
    /// error detail (https://cloud.google.com/apis/design/errors#error_details),
    /// unless solving_mode=VALIDATE_ONLY: see the
    /// [OptimizeToursResponse.validation_errors][google.maps.routeoptimization.v1.OptimizeToursResponse.validation_errors]
    /// field.
    /// This defaults to 100 and is capped at 10,000.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MaxValidationErrors {
      get { if ((_hasBits0 & 1) != 0) { return maxValidationErrors_; } else { return MaxValidationErrorsDefaultValue; } }
      set {
        _hasBits0 |= 1;
        maxValidationErrors_ = value;
      }
    }
    /// <summary>Gets whether the "max_validation_errors" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxValidationErrors {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "max_validation_errors" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxValidationErrors() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "label" field.</summary>
    public const int LabelFieldNumber = 17;
    private string label_ = "";
    /// <summary>
    /// Label that may be used to identify this request, reported back in the
    /// [OptimizeToursResponse.request_label][google.maps.routeoptimization.v1.OptimizeToursResponse.request_label].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Label {
      get { return label_; }
      set {
        label_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as OptimizeToursRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(OptimizeToursRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Parent != other.Parent) return false;
      if (!object.Equals(Timeout, other.Timeout)) return false;
      if (!object.Equals(Model, other.Model)) return false;
      if (SolvingMode != other.SolvingMode) return false;
      if (SearchMode != other.SearchMode) return false;
      if(!injectedFirstSolutionRoutes_.Equals(other.injectedFirstSolutionRoutes_)) return false;
      if (!object.Equals(InjectedSolutionConstraint, other.InjectedSolutionConstraint)) return false;
      if(!refreshDetailsRoutes_.Equals(other.refreshDetailsRoutes_)) return false;
      if (InterpretInjectedSolutionsUsingLabels != other.InterpretInjectedSolutionsUsingLabels) return false;
      if (ConsiderRoadTraffic != other.ConsiderRoadTraffic) return false;
      if (PopulatePolylines != other.PopulatePolylines) return false;
      if (PopulateTransitionPolylines != other.PopulateTransitionPolylines) return false;
      if (AllowLargeDeadlineDespiteInterruptionRisk != other.AllowLargeDeadlineDespiteInterruptionRisk) return false;
      if (UseGeodesicDistances != other.UseGeodesicDistances) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(GeodesicMetersPerSecond, other.GeodesicMetersPerSecond)) return false;
      if (MaxValidationErrors != other.MaxValidationErrors) return false;
      if (Label != other.Label) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Parent.Length != 0) hash ^= Parent.GetHashCode();
      if (timeout_ != null) hash ^= Timeout.GetHashCode();
      if (model_ != null) hash ^= Model.GetHashCode();
      if (SolvingMode != global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest.Types.SolvingMode.DefaultSolve) hash ^= SolvingMode.GetHashCode();
      if (SearchMode != global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest.Types.SearchMode.Unspecified) hash ^= SearchMode.GetHashCode();
      hash ^= injectedFirstSolutionRoutes_.GetHashCode();
      if (injectedSolutionConstraint_ != null) hash ^= InjectedSolutionConstraint.GetHashCode();
      hash ^= refreshDetailsRoutes_.GetHashCode();
      if (InterpretInjectedSolutionsUsingLabels != false) hash ^= InterpretInjectedSolutionsUsingLabels.GetHashCode();
      if (ConsiderRoadTraffic != false) hash ^= ConsiderRoadTraffic.GetHashCode();
      if (PopulatePolylines != false) hash ^= PopulatePolylines.GetHashCode();
      if (PopulateTransitionPolylines != false) hash ^= PopulateTransitionPolylines.GetHashCode();
      if (AllowLargeDeadlineDespiteInterruptionRisk != false) hash ^= AllowLargeDeadlineDespiteInterruptionRisk.GetHashCode();
      if (UseGeodesicDistances != false) hash ^= UseGeodesicDistances.GetHashCode();
      if (HasGeodesicMetersPerSecond) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(GeodesicMetersPerSecond);
      if (HasMaxValidationErrors) hash ^= MaxValidationErrors.GetHashCode();
      if (Label.Length != 0) hash ^= Label.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Parent.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Parent);
      }
      if (timeout_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Timeout);
      }
      if (model_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Model);
      }
      if (SolvingMode != global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest.Types.SolvingMode.DefaultSolve) {
        output.WriteRawTag(32);
        output.WriteEnum((int) SolvingMode);
      }
      if (HasMaxValidationErrors) {
        output.WriteRawTag(40);
        output.WriteInt32(MaxValidationErrors);
      }
      if (SearchMode != global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest.Types.SearchMode.Unspecified) {
        output.WriteRawTag(48);
        output.WriteEnum((int) SearchMode);
      }
      injectedFirstSolutionRoutes_.WriteTo(output, _repeated_injectedFirstSolutionRoutes_codec);
      if (injectedSolutionConstraint_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(InjectedSolutionConstraint);
      }
      refreshDetailsRoutes_.WriteTo(output, _repeated_refreshDetailsRoutes_codec);
      if (InterpretInjectedSolutionsUsingLabels != false) {
        output.WriteRawTag(80);
        output.WriteBool(InterpretInjectedSolutionsUsingLabels);
      }
      if (ConsiderRoadTraffic != false) {
        output.WriteRawTag(88);
        output.WriteBool(ConsiderRoadTraffic);
      }
      if (PopulatePolylines != false) {
        output.WriteRawTag(96);
        output.WriteBool(PopulatePolylines);
      }
      if (PopulateTransitionPolylines != false) {
        output.WriteRawTag(104);
        output.WriteBool(PopulateTransitionPolylines);
      }
      if (AllowLargeDeadlineDespiteInterruptionRisk != false) {
        output.WriteRawTag(112);
        output.WriteBool(AllowLargeDeadlineDespiteInterruptionRisk);
      }
      if (UseGeodesicDistances != false) {
        output.WriteRawTag(120);
        output.WriteBool(UseGeodesicDistances);
      }
      if (HasGeodesicMetersPerSecond) {
        output.WriteRawTag(129, 1);
        output.WriteDouble(GeodesicMetersPerSecond);
      }
      if (Label.Length != 0) {
        output.WriteRawTag(138, 1);
        output.WriteString(Label);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Parent.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Parent);
      }
      if (timeout_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Timeout);
      }
      if (model_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Model);
      }
      if (SolvingMode != global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest.Types.SolvingMode.DefaultSolve) {
        output.WriteRawTag(32);
        output.WriteEnum((int) SolvingMode);
      }
      if (HasMaxValidationErrors) {
        output.WriteRawTag(40);
        output.WriteInt32(MaxValidationErrors);
      }
      if (SearchMode != global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest.Types.SearchMode.Unspecified) {
        output.WriteRawTag(48);
        output.WriteEnum((int) SearchMode);
      }
      injectedFirstSolutionRoutes_.WriteTo(ref output, _repeated_injectedFirstSolutionRoutes_codec);
      if (injectedSolutionConstraint_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(InjectedSolutionConstraint);
      }
      refreshDetailsRoutes_.WriteTo(ref output, _repeated_refreshDetailsRoutes_codec);
      if (InterpretInjectedSolutionsUsingLabels != false) {
        output.WriteRawTag(80);
        output.WriteBool(InterpretInjectedSolutionsUsingLabels);
      }
      if (ConsiderRoadTraffic != false) {
        output.WriteRawTag(88);
        output.WriteBool(ConsiderRoadTraffic);
      }
      if (PopulatePolylines != false) {
        output.WriteRawTag(96);
        output.WriteBool(PopulatePolylines);
      }
      if (PopulateTransitionPolylines != false) {
        output.WriteRawTag(104);
        output.WriteBool(PopulateTransitionPolylines);
      }
      if (AllowLargeDeadlineDespiteInterruptionRisk != false) {
        output.WriteRawTag(112);
        output.WriteBool(AllowLargeDeadlineDespiteInterruptionRisk);
      }
      if (UseGeodesicDistances != false) {
        output.WriteRawTag(120);
        output.WriteBool(UseGeodesicDistances);
      }
      if (HasGeodesicMetersPerSecond) {
        output.WriteRawTag(129, 1);
        output.WriteDouble(GeodesicMetersPerSecond);
      }
      if (Label.Length != 0) {
        output.WriteRawTag(138, 1);
        output.WriteString(Label);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Parent.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Parent);
      }
      if (timeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Timeout);
      }
      if (model_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Model);
      }
      if (SolvingMode != global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest.Types.SolvingMode.DefaultSolve) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SolvingMode);
      }
      if (SearchMode != global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest.Types.SearchMode.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SearchMode);
      }
      size += injectedFirstSolutionRoutes_.CalculateSize(_repeated_injectedFirstSolutionRoutes_codec);
      if (injectedSolutionConstraint_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(InjectedSolutionConstraint);
      }
      size += refreshDetailsRoutes_.CalculateSize(_repeated_refreshDetailsRoutes_codec);
      if (InterpretInjectedSolutionsUsingLabels != false) {
        size += 1 + 1;
      }
      if (ConsiderRoadTraffic != false) {
        size += 1 + 1;
      }
      if (PopulatePolylines != false) {
        size += 1 + 1;
      }
      if (PopulateTransitionPolylines != false) {
        size += 1 + 1;
      }
      if (AllowLargeDeadlineDespiteInterruptionRisk != false) {
        size += 1 + 1;
      }
      if (UseGeodesicDistances != false) {
        size += 1 + 1;
      }
      if (HasGeodesicMetersPerSecond) {
        size += 2 + 8;
      }
      if (HasMaxValidationErrors) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxValidationErrors);
      }
      if (Label.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Label);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(OptimizeToursRequest other) {
      if (other == null) {
        return;
      }
      if (other.Parent.Length != 0) {
        Parent = other.Parent;
      }
      if (other.timeout_ != null) {
        if (timeout_ == null) {
          Timeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Timeout.MergeFrom(other.Timeout);
      }
      if (other.model_ != null) {
        if (model_ == null) {
          Model = new global::Google.Maps.RouteOptimization.V1.ShipmentModel();
        }
        Model.MergeFrom(other.Model);
      }
      if (other.SolvingMode != global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest.Types.SolvingMode.DefaultSolve) {
        SolvingMode = other.SolvingMode;
      }
      if (other.SearchMode != global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest.Types.SearchMode.Unspecified) {
        SearchMode = other.SearchMode;
      }
      injectedFirstSolutionRoutes_.Add(other.injectedFirstSolutionRoutes_);
      if (other.injectedSolutionConstraint_ != null) {
        if (injectedSolutionConstraint_ == null) {
          InjectedSolutionConstraint = new global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint();
        }
        InjectedSolutionConstraint.MergeFrom(other.InjectedSolutionConstraint);
      }
      refreshDetailsRoutes_.Add(other.refreshDetailsRoutes_);
      if (other.InterpretInjectedSolutionsUsingLabels != false) {
        InterpretInjectedSolutionsUsingLabels = other.InterpretInjectedSolutionsUsingLabels;
      }
      if (other.ConsiderRoadTraffic != false) {
        ConsiderRoadTraffic = other.ConsiderRoadTraffic;
      }
      if (other.PopulatePolylines != false) {
        PopulatePolylines = other.PopulatePolylines;
      }
      if (other.PopulateTransitionPolylines != false) {
        PopulateTransitionPolylines = other.PopulateTransitionPolylines;
      }
      if (other.AllowLargeDeadlineDespiteInterruptionRisk != false) {
        AllowLargeDeadlineDespiteInterruptionRisk = other.AllowLargeDeadlineDespiteInterruptionRisk;
      }
      if (other.UseGeodesicDistances != false) {
        UseGeodesicDistances = other.UseGeodesicDistances;
      }
      if (other.HasGeodesicMetersPerSecond) {
        GeodesicMetersPerSecond = other.GeodesicMetersPerSecond;
      }
      if (other.HasMaxValidationErrors) {
        MaxValidationErrors = other.MaxValidationErrors;
      }
      if (other.Label.Length != 0) {
        Label = other.Label;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Parent = input.ReadString();
            break;
          }
          case 18: {
            if (timeout_ == null) {
              Timeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Timeout);
            break;
          }
          case 26: {
            if (model_ == null) {
              Model = new global::Google.Maps.RouteOptimization.V1.ShipmentModel();
            }
            input.ReadMessage(Model);
            break;
          }
          case 32: {
            SolvingMode = (global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest.Types.SolvingMode) input.ReadEnum();
            break;
          }
          case 40: {
            MaxValidationErrors = input.ReadInt32();
            break;
          }
          case 48: {
            SearchMode = (global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest.Types.SearchMode) input.ReadEnum();
            break;
          }
          case 58: {
            injectedFirstSolutionRoutes_.AddEntriesFrom(input, _repeated_injectedFirstSolutionRoutes_codec);
            break;
          }
          case 66: {
            if (injectedSolutionConstraint_ == null) {
              InjectedSolutionConstraint = new global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint();
            }
            input.ReadMessage(InjectedSolutionConstraint);
            break;
          }
          case 74: {
            refreshDetailsRoutes_.AddEntriesFrom(input, _repeated_refreshDetailsRoutes_codec);
            break;
          }
          case 80: {
            InterpretInjectedSolutionsUsingLabels = input.ReadBool();
            break;
          }
          case 88: {
            ConsiderRoadTraffic = input.ReadBool();
            break;
          }
          case 96: {
            PopulatePolylines = input.ReadBool();
            break;
          }
          case 104: {
            PopulateTransitionPolylines = input.ReadBool();
            break;
          }
          case 112: {
            AllowLargeDeadlineDespiteInterruptionRisk = input.ReadBool();
            break;
          }
          case 120: {
            UseGeodesicDistances = input.ReadBool();
            break;
          }
          case 129: {
            GeodesicMetersPerSecond = input.ReadDouble();
            break;
          }
          case 138: {
            Label = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Parent = input.ReadString();
            break;
          }
          case 18: {
            if (timeout_ == null) {
              Timeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Timeout);
            break;
          }
          case 26: {
            if (model_ == null) {
              Model = new global::Google.Maps.RouteOptimization.V1.ShipmentModel();
            }
            input.ReadMessage(Model);
            break;
          }
          case 32: {
            SolvingMode = (global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest.Types.SolvingMode) input.ReadEnum();
            break;
          }
          case 40: {
            MaxValidationErrors = input.ReadInt32();
            break;
          }
          case 48: {
            SearchMode = (global::Google.Maps.RouteOptimization.V1.OptimizeToursRequest.Types.SearchMode) input.ReadEnum();
            break;
          }
          case 58: {
            injectedFirstSolutionRoutes_.AddEntriesFrom(ref input, _repeated_injectedFirstSolutionRoutes_codec);
            break;
          }
          case 66: {
            if (injectedSolutionConstraint_ == null) {
              InjectedSolutionConstraint = new global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint();
            }
            input.ReadMessage(InjectedSolutionConstraint);
            break;
          }
          case 74: {
            refreshDetailsRoutes_.AddEntriesFrom(ref input, _repeated_refreshDetailsRoutes_codec);
            break;
          }
          case 80: {
            InterpretInjectedSolutionsUsingLabels = input.ReadBool();
            break;
          }
          case 88: {
            ConsiderRoadTraffic = input.ReadBool();
            break;
          }
          case 96: {
            PopulatePolylines = input.ReadBool();
            break;
          }
          case 104: {
            PopulateTransitionPolylines = input.ReadBool();
            break;
          }
          case 112: {
            AllowLargeDeadlineDespiteInterruptionRisk = input.ReadBool();
            break;
          }
          case 120: {
            UseGeodesicDistances = input.ReadBool();
            break;
          }
          case 129: {
            GeodesicMetersPerSecond = input.ReadDouble();
            break;
          }
          case 138: {
            Label = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the OptimizeToursRequest message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Defines how the solver should handle the request. In all modes but
      /// `VALIDATE_ONLY`, if the request is invalid, you will receive an
      /// `INVALID_REQUEST` error. See
      /// [max_validation_errors][google.maps.routeoptimization.v1.OptimizeToursRequest.max_validation_errors]
      /// to cap the number of errors returned.
      /// </summary>
      public enum SolvingMode {
        /// <summary>
        /// Solve the model. Warnings may be issued in
        /// [OptimizeToursResponse.validation_errors][google.cloud.optimization.v1.OptimizeToursResponse.validation_errors].
        /// </summary>
        [pbr::OriginalName("DEFAULT_SOLVE")] DefaultSolve = 0,
        /// <summary>
        /// Only validates the model without solving it: populates as many
        /// [OptimizeToursResponse.validation_errors][google.maps.routeoptimization.v1.OptimizeToursResponse.validation_errors]
        /// as possible.
        /// </summary>
        [pbr::OriginalName("VALIDATE_ONLY")] ValidateOnly = 1,
        /// <summary>
        /// Only populates
        /// [OptimizeToursResponse.validation_errors][google.maps.routeoptimization.v1.OptimizeToursResponse.validation_errors]
        /// or
        /// [OptimizeToursResponse.skipped_shipments][google.maps.routeoptimization.v1.OptimizeToursResponse.skipped_shipments],
        /// and doesn't actually solve the rest of the request (`status` and `routes`
        /// are unset in the response).
        /// If infeasibilities in `injected_solution_constraint` routes are detected
        /// they are populated in the
        /// [OptimizeToursResponse.validation_errors][google.maps.routeoptimization.v1.OptimizeToursResponse.validation_errors]
        /// field and
        /// [OptimizeToursResponse.skipped_shipments][google.maps.routeoptimization.v1.OptimizeToursResponse.skipped_shipments]
        /// is left empty.
        ///
        /// *IMPORTANT*: not all infeasible shipments are returned here, but only the
        /// ones that are detected as infeasible during preprocessing.
        /// </summary>
        [pbr::OriginalName("DETECT_SOME_INFEASIBLE_SHIPMENTS")] DetectSomeInfeasibleShipments = 2,
      }

      /// <summary>
      /// Mode defining the behavior of the search, trading off latency versus
      /// solution quality. In all modes, the global request deadline is enforced.
      /// </summary>
      public enum SearchMode {
        /// <summary>
        /// Unspecified search mode, equivalent to `RETURN_FAST`.
        /// </summary>
        [pbr::OriginalName("SEARCH_MODE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Stop the search after finding the first good solution.
        /// </summary>
        [pbr::OriginalName("RETURN_FAST")] ReturnFast = 1,
        /// <summary>
        /// Spend all the available time to search for better solutions.
        /// </summary>
        [pbr::OriginalName("CONSUME_ALL_AVAILABLE_TIME")] ConsumeAllAvailableTime = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// Response after solving a tour optimization problem containing the routes
  /// followed by each vehicle, the shipments which have been skipped and the
  /// overall cost of the solution.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class OptimizeToursResponse : pb::IMessage<OptimizeToursResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OptimizeToursResponse> _parser = new pb::MessageParser<OptimizeToursResponse>(() => new OptimizeToursResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<OptimizeToursResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OptimizeToursResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OptimizeToursResponse(OptimizeToursResponse other) : this() {
      routes_ = other.routes_.Clone();
      requestLabel_ = other.requestLabel_;
      skippedShipments_ = other.skippedShipments_.Clone();
      validationErrors_ = other.validationErrors_.Clone();
      metrics_ = other.metrics_ != null ? other.metrics_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OptimizeToursResponse Clone() {
      return new OptimizeToursResponse(this);
    }

    /// <summary>Field number for the "routes" field.</summary>
    public const int RoutesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.ShipmentRoute> _repeated_routes_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentRoute> routes_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentRoute>();
    /// <summary>
    /// Routes computed for each vehicle; the i-th route corresponds to the i-th
    /// vehicle in the model.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentRoute> Routes {
      get { return routes_; }
    }

    /// <summary>Field number for the "request_label" field.</summary>
    public const int RequestLabelFieldNumber = 3;
    private string requestLabel_ = "";
    /// <summary>
    /// Copy of the
    /// [OptimizeToursRequest.label][google.maps.routeoptimization.v1.OptimizeToursRequest.label],
    /// if a label was specified in the request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RequestLabel {
      get { return requestLabel_; }
      set {
        requestLabel_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "skipped_shipments" field.</summary>
    public const int SkippedShipmentsFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.SkippedShipment> _repeated_skippedShipments_codec
        = pb::FieldCodec.ForMessage(34, global::Google.Maps.RouteOptimization.V1.SkippedShipment.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.SkippedShipment> skippedShipments_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.SkippedShipment>();
    /// <summary>
    /// The list of all shipments skipped.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.SkippedShipment> SkippedShipments {
      get { return skippedShipments_; }
    }

    /// <summary>Field number for the "validation_errors" field.</summary>
    public const int ValidationErrorsFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.OptimizeToursValidationError> _repeated_validationErrors_codec
        = pb::FieldCodec.ForMessage(42, global::Google.Maps.RouteOptimization.V1.OptimizeToursValidationError.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.OptimizeToursValidationError> validationErrors_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.OptimizeToursValidationError>();
    /// <summary>
    /// List of all the validation errors that we were able to detect
    /// independently. See the "MULTIPLE ERRORS" explanation for the
    /// [OptimizeToursValidationError][google.maps.routeoptimization.v1.OptimizeToursValidationError]
    /// message. Instead of errors, this will include warnings in the case
    /// `solving_mode` is `DEFAULT_SOLVE`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.OptimizeToursValidationError> ValidationErrors {
      get { return validationErrors_; }
    }

    /// <summary>Field number for the "metrics" field.</summary>
    public const int MetricsFieldNumber = 6;
    private global::Google.Maps.RouteOptimization.V1.OptimizeToursResponse.Types.Metrics metrics_;
    /// <summary>
    /// Duration, distance and usage metrics for this solution.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.OptimizeToursResponse.Types.Metrics Metrics {
      get { return metrics_; }
      set {
        metrics_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as OptimizeToursResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(OptimizeToursResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!routes_.Equals(other.routes_)) return false;
      if (RequestLabel != other.RequestLabel) return false;
      if(!skippedShipments_.Equals(other.skippedShipments_)) return false;
      if(!validationErrors_.Equals(other.validationErrors_)) return false;
      if (!object.Equals(Metrics, other.Metrics)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= routes_.GetHashCode();
      if (RequestLabel.Length != 0) hash ^= RequestLabel.GetHashCode();
      hash ^= skippedShipments_.GetHashCode();
      hash ^= validationErrors_.GetHashCode();
      if (metrics_ != null) hash ^= Metrics.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      routes_.WriteTo(output, _repeated_routes_codec);
      if (RequestLabel.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(RequestLabel);
      }
      skippedShipments_.WriteTo(output, _repeated_skippedShipments_codec);
      validationErrors_.WriteTo(output, _repeated_validationErrors_codec);
      if (metrics_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Metrics);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      routes_.WriteTo(ref output, _repeated_routes_codec);
      if (RequestLabel.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(RequestLabel);
      }
      skippedShipments_.WriteTo(ref output, _repeated_skippedShipments_codec);
      validationErrors_.WriteTo(ref output, _repeated_validationErrors_codec);
      if (metrics_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Metrics);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += routes_.CalculateSize(_repeated_routes_codec);
      if (RequestLabel.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RequestLabel);
      }
      size += skippedShipments_.CalculateSize(_repeated_skippedShipments_codec);
      size += validationErrors_.CalculateSize(_repeated_validationErrors_codec);
      if (metrics_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metrics);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(OptimizeToursResponse other) {
      if (other == null) {
        return;
      }
      routes_.Add(other.routes_);
      if (other.RequestLabel.Length != 0) {
        RequestLabel = other.RequestLabel;
      }
      skippedShipments_.Add(other.skippedShipments_);
      validationErrors_.Add(other.validationErrors_);
      if (other.metrics_ != null) {
        if (metrics_ == null) {
          Metrics = new global::Google.Maps.RouteOptimization.V1.OptimizeToursResponse.Types.Metrics();
        }
        Metrics.MergeFrom(other.Metrics);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            routes_.AddEntriesFrom(input, _repeated_routes_codec);
            break;
          }
          case 26: {
            RequestLabel = input.ReadString();
            break;
          }
          case 34: {
            skippedShipments_.AddEntriesFrom(input, _repeated_skippedShipments_codec);
            break;
          }
          case 42: {
            validationErrors_.AddEntriesFrom(input, _repeated_validationErrors_codec);
            break;
          }
          case 50: {
            if (metrics_ == null) {
              Metrics = new global::Google.Maps.RouteOptimization.V1.OptimizeToursResponse.Types.Metrics();
            }
            input.ReadMessage(Metrics);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            routes_.AddEntriesFrom(ref input, _repeated_routes_codec);
            break;
          }
          case 26: {
            RequestLabel = input.ReadString();
            break;
          }
          case 34: {
            skippedShipments_.AddEntriesFrom(ref input, _repeated_skippedShipments_codec);
            break;
          }
          case 42: {
            validationErrors_.AddEntriesFrom(ref input, _repeated_validationErrors_codec);
            break;
          }
          case 50: {
            if (metrics_ == null) {
              Metrics = new global::Google.Maps.RouteOptimization.V1.OptimizeToursResponse.Types.Metrics();
            }
            input.ReadMessage(Metrics);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the OptimizeToursResponse message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Overall metrics, aggregated over all routes.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class Metrics : pb::IMessage<Metrics>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Metrics> _parser = new pb::MessageParser<Metrics>(() => new Metrics());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Metrics> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.RouteOptimization.V1.OptimizeToursResponse.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Metrics() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Metrics(Metrics other) : this() {
          aggregatedRouteMetrics_ = other.aggregatedRouteMetrics_ != null ? other.aggregatedRouteMetrics_.Clone() : null;
          skippedMandatoryShipmentCount_ = other.skippedMandatoryShipmentCount_;
          usedVehicleCount_ = other.usedVehicleCount_;
          earliestVehicleStartTime_ = other.earliestVehicleStartTime_ != null ? other.earliestVehicleStartTime_.Clone() : null;
          latestVehicleEndTime_ = other.latestVehicleEndTime_ != null ? other.latestVehicleEndTime_.Clone() : null;
          costs_ = other.costs_.Clone();
          totalCost_ = other.totalCost_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Metrics Clone() {
          return new Metrics(this);
        }

        /// <summary>Field number for the "aggregated_route_metrics" field.</summary>
        public const int AggregatedRouteMetricsFieldNumber = 1;
        private global::Google.Maps.RouteOptimization.V1.AggregatedMetrics aggregatedRouteMetrics_;
        /// <summary>
        /// Aggregated over the routes. Each metric is the sum (or max, for loads)
        /// over all
        /// [ShipmentRoute.metrics][google.maps.routeoptimization.v1.ShipmentRoute.metrics]
        /// fields of the same name.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Maps.RouteOptimization.V1.AggregatedMetrics AggregatedRouteMetrics {
          get { return aggregatedRouteMetrics_; }
          set {
            aggregatedRouteMetrics_ = value;
          }
        }

        /// <summary>Field number for the "skipped_mandatory_shipment_count" field.</summary>
        public const int SkippedMandatoryShipmentCountFieldNumber = 2;
        private int skippedMandatoryShipmentCount_;
        /// <summary>
        /// Number of mandatory shipments skipped.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int SkippedMandatoryShipmentCount {
          get { return skippedMandatoryShipmentCount_; }
          set {
            skippedMandatoryShipmentCount_ = value;
          }
        }

        /// <summary>Field number for the "used_vehicle_count" field.</summary>
        public const int UsedVehicleCountFieldNumber = 3;
        private int usedVehicleCount_;
        /// <summary>
        /// Number of vehicles used. Note: if a vehicle route is empty and
        /// [Vehicle.used_if_route_is_empty][google.maps.routeoptimization.v1.Vehicle.used_if_route_is_empty]
        /// is true, the vehicle is considered used.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int UsedVehicleCount {
          get { return usedVehicleCount_; }
          set {
            usedVehicleCount_ = value;
          }
        }

        /// <summary>Field number for the "earliest_vehicle_start_time" field.</summary>
        public const int EarliestVehicleStartTimeFieldNumber = 4;
        private global::Google.Protobuf.WellKnownTypes.Timestamp earliestVehicleStartTime_;
        /// <summary>
        /// The earliest start time for a used vehicle, computed as the minimum over
        /// all used vehicles of
        /// [ShipmentRoute.vehicle_start_time][google.maps.routeoptimization.v1.ShipmentRoute.vehicle_start_time].
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Timestamp EarliestVehicleStartTime {
          get { return earliestVehicleStartTime_; }
          set {
            earliestVehicleStartTime_ = value;
          }
        }

        /// <summary>Field number for the "latest_vehicle_end_time" field.</summary>
        public const int LatestVehicleEndTimeFieldNumber = 5;
        private global::Google.Protobuf.WellKnownTypes.Timestamp latestVehicleEndTime_;
        /// <summary>
        /// The latest end time for a used vehicle, computed as the maximum over all
        /// used vehicles of
        /// [ShipmentRoute.vehicle_end_time][google.maps.routeoptimization.v1.ShipmentRoute.vehicle_end_time].
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Timestamp LatestVehicleEndTime {
          get { return latestVehicleEndTime_; }
          set {
            latestVehicleEndTime_ = value;
          }
        }

        /// <summary>Field number for the "costs" field.</summary>
        public const int CostsFieldNumber = 10;
        private static readonly pbc::MapField<string, double>.Codec _map_costs_codec
            = new pbc::MapField<string, double>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForDouble(17, 0D), 82);
        private readonly pbc::MapField<string, double> costs_ = new pbc::MapField<string, double>();
        /// <summary>
        /// Cost of the solution, broken down by cost-related request fields.
        /// The keys are proto paths, relative to the input OptimizeToursRequest,
        /// e.g. "model.shipments.pickups.cost", and the values are the total cost
        /// generated by the corresponding cost field, aggregated over the whole
        /// solution. In other words, costs["model.shipments.pickups.cost"] is the
        /// sum of all pickup costs over the solution. All costs defined in the model
        /// are reported in detail here with the exception of costs related to
        /// TransitionAttributes that are only reported in an aggregated way as of
        /// 2022/01.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::MapField<string, double> Costs {
          get { return costs_; }
        }

        /// <summary>Field number for the "total_cost" field.</summary>
        public const int TotalCostFieldNumber = 6;
        private double totalCost_;
        /// <summary>
        /// Total cost of the solution. The sum of all values in the costs map.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public double TotalCost {
          get { return totalCost_; }
          set {
            totalCost_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Metrics);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Metrics other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(AggregatedRouteMetrics, other.AggregatedRouteMetrics)) return false;
          if (SkippedMandatoryShipmentCount != other.SkippedMandatoryShipmentCount) return false;
          if (UsedVehicleCount != other.UsedVehicleCount) return false;
          if (!object.Equals(EarliestVehicleStartTime, other.EarliestVehicleStartTime)) return false;
          if (!object.Equals(LatestVehicleEndTime, other.LatestVehicleEndTime)) return false;
          if (!Costs.Equals(other.Costs)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(TotalCost, other.TotalCost)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (aggregatedRouteMetrics_ != null) hash ^= AggregatedRouteMetrics.GetHashCode();
          if (SkippedMandatoryShipmentCount != 0) hash ^= SkippedMandatoryShipmentCount.GetHashCode();
          if (UsedVehicleCount != 0) hash ^= UsedVehicleCount.GetHashCode();
          if (earliestVehicleStartTime_ != null) hash ^= EarliestVehicleStartTime.GetHashCode();
          if (latestVehicleEndTime_ != null) hash ^= LatestVehicleEndTime.GetHashCode();
          hash ^= Costs.GetHashCode();
          if (TotalCost != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(TotalCost);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (aggregatedRouteMetrics_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(AggregatedRouteMetrics);
          }
          if (SkippedMandatoryShipmentCount != 0) {
            output.WriteRawTag(16);
            output.WriteInt32(SkippedMandatoryShipmentCount);
          }
          if (UsedVehicleCount != 0) {
            output.WriteRawTag(24);
            output.WriteInt32(UsedVehicleCount);
          }
          if (earliestVehicleStartTime_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(EarliestVehicleStartTime);
          }
          if (latestVehicleEndTime_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(LatestVehicleEndTime);
          }
          if (TotalCost != 0D) {
            output.WriteRawTag(49);
            output.WriteDouble(TotalCost);
          }
          costs_.WriteTo(output, _map_costs_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (aggregatedRouteMetrics_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(AggregatedRouteMetrics);
          }
          if (SkippedMandatoryShipmentCount != 0) {
            output.WriteRawTag(16);
            output.WriteInt32(SkippedMandatoryShipmentCount);
          }
          if (UsedVehicleCount != 0) {
            output.WriteRawTag(24);
            output.WriteInt32(UsedVehicleCount);
          }
          if (earliestVehicleStartTime_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(EarliestVehicleStartTime);
          }
          if (latestVehicleEndTime_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(LatestVehicleEndTime);
          }
          if (TotalCost != 0D) {
            output.WriteRawTag(49);
            output.WriteDouble(TotalCost);
          }
          costs_.WriteTo(ref output, _map_costs_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (aggregatedRouteMetrics_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(AggregatedRouteMetrics);
          }
          if (SkippedMandatoryShipmentCount != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(SkippedMandatoryShipmentCount);
          }
          if (UsedVehicleCount != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(UsedVehicleCount);
          }
          if (earliestVehicleStartTime_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(EarliestVehicleStartTime);
          }
          if (latestVehicleEndTime_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(LatestVehicleEndTime);
          }
          size += costs_.CalculateSize(_map_costs_codec);
          if (TotalCost != 0D) {
            size += 1 + 8;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Metrics other) {
          if (other == null) {
            return;
          }
          if (other.aggregatedRouteMetrics_ != null) {
            if (aggregatedRouteMetrics_ == null) {
              AggregatedRouteMetrics = new global::Google.Maps.RouteOptimization.V1.AggregatedMetrics();
            }
            AggregatedRouteMetrics.MergeFrom(other.AggregatedRouteMetrics);
          }
          if (other.SkippedMandatoryShipmentCount != 0) {
            SkippedMandatoryShipmentCount = other.SkippedMandatoryShipmentCount;
          }
          if (other.UsedVehicleCount != 0) {
            UsedVehicleCount = other.UsedVehicleCount;
          }
          if (other.earliestVehicleStartTime_ != null) {
            if (earliestVehicleStartTime_ == null) {
              EarliestVehicleStartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            EarliestVehicleStartTime.MergeFrom(other.EarliestVehicleStartTime);
          }
          if (other.latestVehicleEndTime_ != null) {
            if (latestVehicleEndTime_ == null) {
              LatestVehicleEndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            LatestVehicleEndTime.MergeFrom(other.LatestVehicleEndTime);
          }
          costs_.MergeFrom(other.costs_);
          if (other.TotalCost != 0D) {
            TotalCost = other.TotalCost;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (aggregatedRouteMetrics_ == null) {
                  AggregatedRouteMetrics = new global::Google.Maps.RouteOptimization.V1.AggregatedMetrics();
                }
                input.ReadMessage(AggregatedRouteMetrics);
                break;
              }
              case 16: {
                SkippedMandatoryShipmentCount = input.ReadInt32();
                break;
              }
              case 24: {
                UsedVehicleCount = input.ReadInt32();
                break;
              }
              case 34: {
                if (earliestVehicleStartTime_ == null) {
                  EarliestVehicleStartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(EarliestVehicleStartTime);
                break;
              }
              case 42: {
                if (latestVehicleEndTime_ == null) {
                  LatestVehicleEndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(LatestVehicleEndTime);
                break;
              }
              case 49: {
                TotalCost = input.ReadDouble();
                break;
              }
              case 82: {
                costs_.AddEntriesFrom(input, _map_costs_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (aggregatedRouteMetrics_ == null) {
                  AggregatedRouteMetrics = new global::Google.Maps.RouteOptimization.V1.AggregatedMetrics();
                }
                input.ReadMessage(AggregatedRouteMetrics);
                break;
              }
              case 16: {
                SkippedMandatoryShipmentCount = input.ReadInt32();
                break;
              }
              case 24: {
                UsedVehicleCount = input.ReadInt32();
                break;
              }
              case 34: {
                if (earliestVehicleStartTime_ == null) {
                  EarliestVehicleStartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(EarliestVehicleStartTime);
                break;
              }
              case 42: {
                if (latestVehicleEndTime_ == null) {
                  LatestVehicleEndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(LatestVehicleEndTime);
                break;
              }
              case 49: {
                TotalCost = input.ReadDouble();
                break;
              }
              case 82: {
                costs_.AddEntriesFrom(ref input, _map_costs_codec);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// A shipment model contains a set of shipments which must be performed by a
  /// set of vehicles, while minimizing the overall cost, which is the sum of:
  ///
  /// * the cost of routing the vehicles (sum of cost per total time, cost per
  ///   travel time, and fixed cost over all vehicles).
  /// * the unperformed shipment penalties.
  /// * the cost of the global duration of the shipments
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ShipmentModel : pb::IMessage<ShipmentModel>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ShipmentModel> _parser = new pb::MessageParser<ShipmentModel>(() => new ShipmentModel());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ShipmentModel> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ShipmentModel() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ShipmentModel(ShipmentModel other) : this() {
      _hasBits0 = other._hasBits0;
      shipments_ = other.shipments_.Clone();
      vehicles_ = other.vehicles_.Clone();
      maxActiveVehicles_ = other.maxActiveVehicles_;
      globalStartTime_ = other.globalStartTime_ != null ? other.globalStartTime_.Clone() : null;
      globalEndTime_ = other.globalEndTime_ != null ? other.globalEndTime_.Clone() : null;
      globalDurationCostPerHour_ = other.globalDurationCostPerHour_;
      durationDistanceMatrices_ = other.durationDistanceMatrices_.Clone();
      durationDistanceMatrixSrcTags_ = other.durationDistanceMatrixSrcTags_.Clone();
      durationDistanceMatrixDstTags_ = other.durationDistanceMatrixDstTags_.Clone();
      transitionAttributes_ = other.transitionAttributes_.Clone();
      shipmentTypeIncompatibilities_ = other.shipmentTypeIncompatibilities_.Clone();
      shipmentTypeRequirements_ = other.shipmentTypeRequirements_.Clone();
      precedenceRules_ = other.precedenceRules_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ShipmentModel Clone() {
      return new ShipmentModel(this);
    }

    /// <summary>Field number for the "shipments" field.</summary>
    public const int ShipmentsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.Shipment> _repeated_shipments_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Maps.RouteOptimization.V1.Shipment.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.Shipment> shipments_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.Shipment>();
    /// <summary>
    /// Set of shipments which must be performed in the model.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.Shipment> Shipments {
      get { return shipments_; }
    }

    /// <summary>Field number for the "vehicles" field.</summary>
    public const int VehiclesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.Vehicle> _repeated_vehicles_codec
        = pb::FieldCodec.ForMessage(18, global::Google.Maps.RouteOptimization.V1.Vehicle.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.Vehicle> vehicles_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.Vehicle>();
    /// <summary>
    /// Set of vehicles which can be used to perform visits.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.Vehicle> Vehicles {
      get { return vehicles_; }
    }

    /// <summary>Field number for the "max_active_vehicles" field.</summary>
    public const int MaxActiveVehiclesFieldNumber = 4;
    private readonly static int MaxActiveVehiclesDefaultValue = 0;

    private int maxActiveVehicles_;
    /// <summary>
    /// Constrains the maximum number of active vehicles. A vehicle is active if
    /// its route performs at least one shipment. This can be used to limit the
    /// number of routes in the case where there are fewer drivers than
    /// vehicles and that the fleet of vehicles is heterogeneous. The optimization
    /// will then select the best subset of vehicles to use.
    /// Must be strictly positive.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MaxActiveVehicles {
      get { if ((_hasBits0 & 1) != 0) { return maxActiveVehicles_; } else { return MaxActiveVehiclesDefaultValue; } }
      set {
        _hasBits0 |= 1;
        maxActiveVehicles_ = value;
      }
    }
    /// <summary>Gets whether the "max_active_vehicles" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxActiveVehicles {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "max_active_vehicles" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxActiveVehicles() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "global_start_time" field.</summary>
    public const int GlobalStartTimeFieldNumber = 5;
    private global::Google.Protobuf.WellKnownTypes.Timestamp globalStartTime_;
    /// <summary>
    /// Global start and end time of the model: no times outside of this range
    /// can be considered valid.
    ///
    /// The model's time span must be less than a year, i.e. the `global_end_time`
    /// and the `global_start_time` must be within 31536000 seconds of each other.
    ///
    /// When using `cost_per_*hour` fields, you might want to set this window to a
    /// smaller interval to increase performance (eg. if you model a single day,
    /// you should set the global time limits to that day).
    /// If unset, 00:00:00 UTC, January 1, 1970 (i.e. seconds: 0, nanos: 0) is used
    /// as default.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp GlobalStartTime {
      get { return globalStartTime_; }
      set {
        globalStartTime_ = value;
      }
    }

    /// <summary>Field number for the "global_end_time" field.</summary>
    public const int GlobalEndTimeFieldNumber = 6;
    private global::Google.Protobuf.WellKnownTypes.Timestamp globalEndTime_;
    /// <summary>
    /// If unset, 00:00:00 UTC, January 1, 1971 (i.e. seconds: 31536000, nanos: 0)
    /// is used as default.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp GlobalEndTime {
      get { return globalEndTime_; }
      set {
        globalEndTime_ = value;
      }
    }

    /// <summary>Field number for the "global_duration_cost_per_hour" field.</summary>
    public const int GlobalDurationCostPerHourFieldNumber = 7;
    private double globalDurationCostPerHour_;
    /// <summary>
    /// The "global duration" of the overall plan is the difference between the
    /// earliest effective start time and the latest effective end time of
    /// all vehicles. Users can assign a cost per hour to that quantity to try
    /// and optimize for earliest job completion, for example. This cost must be in
    /// the same unit as
    /// [Shipment.penalty_cost][google.maps.routeoptimization.v1.Shipment.penalty_cost].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double GlobalDurationCostPerHour {
      get { return globalDurationCostPerHour_; }
      set {
        globalDurationCostPerHour_ = value;
      }
    }

    /// <summary>Field number for the "duration_distance_matrices" field.</summary>
    public const int DurationDistanceMatricesFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.ShipmentModel.Types.DurationDistanceMatrix> _repeated_durationDistanceMatrices_codec
        = pb::FieldCodec.ForMessage(66, global::Google.Maps.RouteOptimization.V1.ShipmentModel.Types.DurationDistanceMatrix.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentModel.Types.DurationDistanceMatrix> durationDistanceMatrices_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentModel.Types.DurationDistanceMatrix>();
    /// <summary>
    /// Specifies duration and distance matrices used in the model. If this field
    /// is empty, Google Maps or geodesic distances will be used instead, depending
    /// on the value of the `use_geodesic_distances` field. If it is not empty,
    /// `use_geodesic_distances` cannot be true and neither
    /// `duration_distance_matrix_src_tags` nor `duration_distance_matrix_dst_tags`
    /// can be empty.
    ///
    /// Usage examples:
    ///
    /// * There are two locations: locA and locB.
    /// * 1 vehicle starting its route at locA and ending it at locA.
    /// * 1 pickup visit request at locB.
    ///
    /// ```
    /// model {
    ///   vehicles { start_tags: "locA"  end_tags: "locA" }
    ///   shipments { pickups { tags: "locB" } }
    ///   duration_distance_matrix_src_tags: "locA"
    ///   duration_distance_matrix_src_tags: "locB"
    ///   duration_distance_matrix_dst_tags: "locA"
    ///   duration_distance_matrix_dst_tags: "locB"
    ///   duration_distance_matrices {
    ///     rows {  # from: locA
    ///       durations { seconds: 0 }   meters: 0    # to: locA
    ///       durations { seconds: 100 } meters: 1000 # to: locB
    ///     }
    ///     rows {  # from: locB
    ///       durations { seconds: 102 } meters: 990 # to: locA
    ///       durations { seconds: 0 }   meters: 0   # to: locB
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// * There are three locations: locA, locB and locC.
    /// * 1 vehicle starting its route at locA and ending it at locB, using
    ///   matrix "fast".
    /// * 1 vehicle starting its route at locB and ending it at locB, using
    ///   matrix "slow".
    /// * 1 vehicle starting its route at locB and ending it at locB, using
    ///   matrix "fast".
    /// * 1 pickup visit request at locC.
    ///
    /// ```
    /// model {
    ///   vehicles { start_tags: "locA" end_tags: "locB" start_tags: "fast" }
    ///   vehicles { start_tags: "locB" end_tags: "locB" start_tags: "slow" }
    ///   vehicles { start_tags: "locB" end_tags: "locB" start_tags: "fast" }
    ///   shipments { pickups { tags: "locC" } }
    ///   duration_distance_matrix_src_tags: "locA"
    ///   duration_distance_matrix_src_tags: "locB"
    ///   duration_distance_matrix_src_tags: "locC"
    ///   duration_distance_matrix_dst_tags: "locB"
    ///   duration_distance_matrix_dst_tags: "locC"
    ///   duration_distance_matrices {
    ///     vehicle_start_tag: "fast"
    ///     rows {  # from: locA
    ///       durations { seconds: 1000 } meters: 2000 # to: locB
    ///       durations { seconds: 600 }  meters: 1000 # to: locC
    ///     }
    ///     rows {  # from: locB
    ///       durations { seconds: 0 }   meters: 0    # to: locB
    ///       durations { seconds: 700 } meters: 1200 # to: locC
    ///     }
    ///     rows {  # from: locC
    ///       durations { seconds: 702 } meters: 1190 # to: locB
    ///       durations { seconds: 0 }   meters: 0    # to: locC
    ///     }
    ///   }
    ///   duration_distance_matrices {
    ///     vehicle_start_tag: "slow"
    ///     rows {  # from: locA
    ///       durations { seconds: 1800 } meters: 2001 # to: locB
    ///       durations { seconds: 900 }  meters: 1002 # to: locC
    ///     }
    ///     rows {  # from: locB
    ///       durations { seconds: 0 }    meters: 0    # to: locB
    ///       durations { seconds: 1000 } meters: 1202 # to: locC
    ///     }
    ///     rows {  # from: locC
    ///       durations { seconds: 1001 } meters: 1195 # to: locB
    ///       durations { seconds: 0 }    meters: 0    # to: locC
    ///     }
    ///   }
    /// }
    /// ```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentModel.Types.DurationDistanceMatrix> DurationDistanceMatrices {
      get { return durationDistanceMatrices_; }
    }

    /// <summary>Field number for the "duration_distance_matrix_src_tags" field.</summary>
    public const int DurationDistanceMatrixSrcTagsFieldNumber = 9;
    private static readonly pb::FieldCodec<string> _repeated_durationDistanceMatrixSrcTags_codec
        = pb::FieldCodec.ForString(74);
    private readonly pbc::RepeatedField<string> durationDistanceMatrixSrcTags_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Tags defining the sources of the duration and distance matrices;
    /// `duration_distance_matrices(i).rows(j)` defines durations and distances
    /// from visits with tag `duration_distance_matrix_src_tags(j)` to other visits
    /// in matrix i.
    ///
    /// Tags correspond to
    /// [VisitRequest.tags][google.maps.routeoptimization.v1.Shipment.VisitRequest.tags]
    /// or
    /// [Vehicle.start_tags][google.maps.routeoptimization.v1.Vehicle.start_tags].
    /// A given `VisitRequest` or `Vehicle` must match exactly one tag in this
    /// field. Note that a `Vehicle`'s source, destination and matrix tags may be
    /// the same; similarly a `VisitRequest`'s source and destination tags may be
    /// the same. All tags must be different and cannot be empty strings. If this
    /// field is not empty, then `duration_distance_matrices` must not be empty.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> DurationDistanceMatrixSrcTags {
      get { return durationDistanceMatrixSrcTags_; }
    }

    /// <summary>Field number for the "duration_distance_matrix_dst_tags" field.</summary>
    public const int DurationDistanceMatrixDstTagsFieldNumber = 10;
    private static readonly pb::FieldCodec<string> _repeated_durationDistanceMatrixDstTags_codec
        = pb::FieldCodec.ForString(82);
    private readonly pbc::RepeatedField<string> durationDistanceMatrixDstTags_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Tags defining the destinations of the duration and distance matrices;
    /// `duration_distance_matrices(i).rows(j).durations(k)` (resp.
    /// `duration_distance_matrices(i).rows(j).meters(k))` defines the duration
    /// (resp. the distance) of the travel from visits with tag
    /// `duration_distance_matrix_src_tags(j)` to visits with tag
    /// `duration_distance_matrix_dst_tags(k)` in matrix i.
    ///
    /// Tags correspond to
    /// [VisitRequest.tags][google.maps.routeoptimization.v1.Shipment.VisitRequest.tags]
    /// or
    /// [Vehicle.start_tags][google.maps.routeoptimization.v1.Vehicle.start_tags].
    /// A given `VisitRequest` or `Vehicle` must match exactly one tag in this
    /// field. Note that a `Vehicle`'s source, destination and matrix tags may be
    /// the same; similarly a `VisitRequest`'s source and destination tags may be
    /// the same. All tags must be different and cannot be empty strings. If this
    /// field is not empty, then `duration_distance_matrices` must not be empty.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> DurationDistanceMatrixDstTags {
      get { return durationDistanceMatrixDstTags_; }
    }

    /// <summary>Field number for the "transition_attributes" field.</summary>
    public const int TransitionAttributesFieldNumber = 11;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.TransitionAttributes> _repeated_transitionAttributes_codec
        = pb::FieldCodec.ForMessage(90, global::Google.Maps.RouteOptimization.V1.TransitionAttributes.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.TransitionAttributes> transitionAttributes_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.TransitionAttributes>();
    /// <summary>
    /// Transition attributes added to the model.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.TransitionAttributes> TransitionAttributes {
      get { return transitionAttributes_; }
    }

    /// <summary>Field number for the "shipment_type_incompatibilities" field.</summary>
    public const int ShipmentTypeIncompatibilitiesFieldNumber = 12;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.ShipmentTypeIncompatibility> _repeated_shipmentTypeIncompatibilities_codec
        = pb::FieldCodec.ForMessage(98, global::Google.Maps.RouteOptimization.V1.ShipmentTypeIncompatibility.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentTypeIncompatibility> shipmentTypeIncompatibilities_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentTypeIncompatibility>();
    /// <summary>
    /// Sets of incompatible shipment_types (see `ShipmentTypeIncompatibility`).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentTypeIncompatibility> ShipmentTypeIncompatibilities {
      get { return shipmentTypeIncompatibilities_; }
    }

    /// <summary>Field number for the "shipment_type_requirements" field.</summary>
    public const int ShipmentTypeRequirementsFieldNumber = 13;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.ShipmentTypeRequirement> _repeated_shipmentTypeRequirements_codec
        = pb::FieldCodec.ForMessage(106, global::Google.Maps.RouteOptimization.V1.ShipmentTypeRequirement.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentTypeRequirement> shipmentTypeRequirements_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentTypeRequirement>();
    /// <summary>
    /// Sets of `shipment_type` requirements (see `ShipmentTypeRequirement`).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentTypeRequirement> ShipmentTypeRequirements {
      get { return shipmentTypeRequirements_; }
    }

    /// <summary>Field number for the "precedence_rules" field.</summary>
    public const int PrecedenceRulesFieldNumber = 14;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.ShipmentModel.Types.PrecedenceRule> _repeated_precedenceRules_codec
        = pb::FieldCodec.ForMessage(114, global::Google.Maps.RouteOptimization.V1.ShipmentModel.Types.PrecedenceRule.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentModel.Types.PrecedenceRule> precedenceRules_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentModel.Types.PrecedenceRule>();
    /// <summary>
    /// Set of precedence rules which must be enforced in the model.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentModel.Types.PrecedenceRule> PrecedenceRules {
      get { return precedenceRules_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ShipmentModel);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ShipmentModel other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!shipments_.Equals(other.shipments_)) return false;
      if(!vehicles_.Equals(other.vehicles_)) return false;
      if (MaxActiveVehicles != other.MaxActiveVehicles) return false;
      if (!object.Equals(GlobalStartTime, other.GlobalStartTime)) return false;
      if (!object.Equals(GlobalEndTime, other.GlobalEndTime)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(GlobalDurationCostPerHour, other.GlobalDurationCostPerHour)) return false;
      if(!durationDistanceMatrices_.Equals(other.durationDistanceMatrices_)) return false;
      if(!durationDistanceMatrixSrcTags_.Equals(other.durationDistanceMatrixSrcTags_)) return false;
      if(!durationDistanceMatrixDstTags_.Equals(other.durationDistanceMatrixDstTags_)) return false;
      if(!transitionAttributes_.Equals(other.transitionAttributes_)) return false;
      if(!shipmentTypeIncompatibilities_.Equals(other.shipmentTypeIncompatibilities_)) return false;
      if(!shipmentTypeRequirements_.Equals(other.shipmentTypeRequirements_)) return false;
      if(!precedenceRules_.Equals(other.precedenceRules_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= shipments_.GetHashCode();
      hash ^= vehicles_.GetHashCode();
      if (HasMaxActiveVehicles) hash ^= MaxActiveVehicles.GetHashCode();
      if (globalStartTime_ != null) hash ^= GlobalStartTime.GetHashCode();
      if (globalEndTime_ != null) hash ^= GlobalEndTime.GetHashCode();
      if (GlobalDurationCostPerHour != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(GlobalDurationCostPerHour);
      hash ^= durationDistanceMatrices_.GetHashCode();
      hash ^= durationDistanceMatrixSrcTags_.GetHashCode();
      hash ^= durationDistanceMatrixDstTags_.GetHashCode();
      hash ^= transitionAttributes_.GetHashCode();
      hash ^= shipmentTypeIncompatibilities_.GetHashCode();
      hash ^= shipmentTypeRequirements_.GetHashCode();
      hash ^= precedenceRules_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      shipments_.WriteTo(output, _repeated_shipments_codec);
      vehicles_.WriteTo(output, _repeated_vehicles_codec);
      if (HasMaxActiveVehicles) {
        output.WriteRawTag(32);
        output.WriteInt32(MaxActiveVehicles);
      }
      if (globalStartTime_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(GlobalStartTime);
      }
      if (globalEndTime_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(GlobalEndTime);
      }
      if (GlobalDurationCostPerHour != 0D) {
        output.WriteRawTag(57);
        output.WriteDouble(GlobalDurationCostPerHour);
      }
      durationDistanceMatrices_.WriteTo(output, _repeated_durationDistanceMatrices_codec);
      durationDistanceMatrixSrcTags_.WriteTo(output, _repeated_durationDistanceMatrixSrcTags_codec);
      durationDistanceMatrixDstTags_.WriteTo(output, _repeated_durationDistanceMatrixDstTags_codec);
      transitionAttributes_.WriteTo(output, _repeated_transitionAttributes_codec);
      shipmentTypeIncompatibilities_.WriteTo(output, _repeated_shipmentTypeIncompatibilities_codec);
      shipmentTypeRequirements_.WriteTo(output, _repeated_shipmentTypeRequirements_codec);
      precedenceRules_.WriteTo(output, _repeated_precedenceRules_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      shipments_.WriteTo(ref output, _repeated_shipments_codec);
      vehicles_.WriteTo(ref output, _repeated_vehicles_codec);
      if (HasMaxActiveVehicles) {
        output.WriteRawTag(32);
        output.WriteInt32(MaxActiveVehicles);
      }
      if (globalStartTime_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(GlobalStartTime);
      }
      if (globalEndTime_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(GlobalEndTime);
      }
      if (GlobalDurationCostPerHour != 0D) {
        output.WriteRawTag(57);
        output.WriteDouble(GlobalDurationCostPerHour);
      }
      durationDistanceMatrices_.WriteTo(ref output, _repeated_durationDistanceMatrices_codec);
      durationDistanceMatrixSrcTags_.WriteTo(ref output, _repeated_durationDistanceMatrixSrcTags_codec);
      durationDistanceMatrixDstTags_.WriteTo(ref output, _repeated_durationDistanceMatrixDstTags_codec);
      transitionAttributes_.WriteTo(ref output, _repeated_transitionAttributes_codec);
      shipmentTypeIncompatibilities_.WriteTo(ref output, _repeated_shipmentTypeIncompatibilities_codec);
      shipmentTypeRequirements_.WriteTo(ref output, _repeated_shipmentTypeRequirements_codec);
      precedenceRules_.WriteTo(ref output, _repeated_precedenceRules_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += shipments_.CalculateSize(_repeated_shipments_codec);
      size += vehicles_.CalculateSize(_repeated_vehicles_codec);
      if (HasMaxActiveVehicles) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxActiveVehicles);
      }
      if (globalStartTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(GlobalStartTime);
      }
      if (globalEndTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(GlobalEndTime);
      }
      if (GlobalDurationCostPerHour != 0D) {
        size += 1 + 8;
      }
      size += durationDistanceMatrices_.CalculateSize(_repeated_durationDistanceMatrices_codec);
      size += durationDistanceMatrixSrcTags_.CalculateSize(_repeated_durationDistanceMatrixSrcTags_codec);
      size += durationDistanceMatrixDstTags_.CalculateSize(_repeated_durationDistanceMatrixDstTags_codec);
      size += transitionAttributes_.CalculateSize(_repeated_transitionAttributes_codec);
      size += shipmentTypeIncompatibilities_.CalculateSize(_repeated_shipmentTypeIncompatibilities_codec);
      size += shipmentTypeRequirements_.CalculateSize(_repeated_shipmentTypeRequirements_codec);
      size += precedenceRules_.CalculateSize(_repeated_precedenceRules_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ShipmentModel other) {
      if (other == null) {
        return;
      }
      shipments_.Add(other.shipments_);
      vehicles_.Add(other.vehicles_);
      if (other.HasMaxActiveVehicles) {
        MaxActiveVehicles = other.MaxActiveVehicles;
      }
      if (other.globalStartTime_ != null) {
        if (globalStartTime_ == null) {
          GlobalStartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        GlobalStartTime.MergeFrom(other.GlobalStartTime);
      }
      if (other.globalEndTime_ != null) {
        if (globalEndTime_ == null) {
          GlobalEndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        GlobalEndTime.MergeFrom(other.GlobalEndTime);
      }
      if (other.GlobalDurationCostPerHour != 0D) {
        GlobalDurationCostPerHour = other.GlobalDurationCostPerHour;
      }
      durationDistanceMatrices_.Add(other.durationDistanceMatrices_);
      durationDistanceMatrixSrcTags_.Add(other.durationDistanceMatrixSrcTags_);
      durationDistanceMatrixDstTags_.Add(other.durationDistanceMatrixDstTags_);
      transitionAttributes_.Add(other.transitionAttributes_);
      shipmentTypeIncompatibilities_.Add(other.shipmentTypeIncompatibilities_);
      shipmentTypeRequirements_.Add(other.shipmentTypeRequirements_);
      precedenceRules_.Add(other.precedenceRules_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            shipments_.AddEntriesFrom(input, _repeated_shipments_codec);
            break;
          }
          case 18: {
            vehicles_.AddEntriesFrom(input, _repeated_vehicles_codec);
            break;
          }
          case 32: {
            MaxActiveVehicles = input.ReadInt32();
            break;
          }
          case 42: {
            if (globalStartTime_ == null) {
              GlobalStartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(GlobalStartTime);
            break;
          }
          case 50: {
            if (globalEndTime_ == null) {
              GlobalEndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(GlobalEndTime);
            break;
          }
          case 57: {
            GlobalDurationCostPerHour = input.ReadDouble();
            break;
          }
          case 66: {
            durationDistanceMatrices_.AddEntriesFrom(input, _repeated_durationDistanceMatrices_codec);
            break;
          }
          case 74: {
            durationDistanceMatrixSrcTags_.AddEntriesFrom(input, _repeated_durationDistanceMatrixSrcTags_codec);
            break;
          }
          case 82: {
            durationDistanceMatrixDstTags_.AddEntriesFrom(input, _repeated_durationDistanceMatrixDstTags_codec);
            break;
          }
          case 90: {
            transitionAttributes_.AddEntriesFrom(input, _repeated_transitionAttributes_codec);
            break;
          }
          case 98: {
            shipmentTypeIncompatibilities_.AddEntriesFrom(input, _repeated_shipmentTypeIncompatibilities_codec);
            break;
          }
          case 106: {
            shipmentTypeRequirements_.AddEntriesFrom(input, _repeated_shipmentTypeRequirements_codec);
            break;
          }
          case 114: {
            precedenceRules_.AddEntriesFrom(input, _repeated_precedenceRules_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            shipments_.AddEntriesFrom(ref input, _repeated_shipments_codec);
            break;
          }
          case 18: {
            vehicles_.AddEntriesFrom(ref input, _repeated_vehicles_codec);
            break;
          }
          case 32: {
            MaxActiveVehicles = input.ReadInt32();
            break;
          }
          case 42: {
            if (globalStartTime_ == null) {
              GlobalStartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(GlobalStartTime);
            break;
          }
          case 50: {
            if (globalEndTime_ == null) {
              GlobalEndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(GlobalEndTime);
            break;
          }
          case 57: {
            GlobalDurationCostPerHour = input.ReadDouble();
            break;
          }
          case 66: {
            durationDistanceMatrices_.AddEntriesFrom(ref input, _repeated_durationDistanceMatrices_codec);
            break;
          }
          case 74: {
            durationDistanceMatrixSrcTags_.AddEntriesFrom(ref input, _repeated_durationDistanceMatrixSrcTags_codec);
            break;
          }
          case 82: {
            durationDistanceMatrixDstTags_.AddEntriesFrom(ref input, _repeated_durationDistanceMatrixDstTags_codec);
            break;
          }
          case 90: {
            transitionAttributes_.AddEntriesFrom(ref input, _repeated_transitionAttributes_codec);
            break;
          }
          case 98: {
            shipmentTypeIncompatibilities_.AddEntriesFrom(ref input, _repeated_shipmentTypeIncompatibilities_codec);
            break;
          }
          case 106: {
            shipmentTypeRequirements_.AddEntriesFrom(ref input, _repeated_shipmentTypeRequirements_codec);
            break;
          }
          case 114: {
            precedenceRules_.AddEntriesFrom(ref input, _repeated_precedenceRules_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ShipmentModel message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Specifies a duration and distance matrix from visit and vehicle start
      /// locations to visit and vehicle end locations.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class DurationDistanceMatrix : pb::IMessage<DurationDistanceMatrix>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<DurationDistanceMatrix> _parser = new pb::MessageParser<DurationDistanceMatrix>(() => new DurationDistanceMatrix());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<DurationDistanceMatrix> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.RouteOptimization.V1.ShipmentModel.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DurationDistanceMatrix() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DurationDistanceMatrix(DurationDistanceMatrix other) : this() {
          rows_ = other.rows_.Clone();
          vehicleStartTag_ = other.vehicleStartTag_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DurationDistanceMatrix Clone() {
          return new DurationDistanceMatrix(this);
        }

        /// <summary>Field number for the "rows" field.</summary>
        public const int RowsFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.ShipmentModel.Types.DurationDistanceMatrix.Types.Row> _repeated_rows_codec
            = pb::FieldCodec.ForMessage(10, global::Google.Maps.RouteOptimization.V1.ShipmentModel.Types.DurationDistanceMatrix.Types.Row.Parser);
        private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentModel.Types.DurationDistanceMatrix.Types.Row> rows_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentModel.Types.DurationDistanceMatrix.Types.Row>();
        /// <summary>
        /// Specifies the rows of the duration and distance matrix. It must have as
        /// many elements as
        /// [ShipmentModel.duration_distance_matrix_src_tags][google.maps.routeoptimization.v1.ShipmentModel.duration_distance_matrix_src_tags].
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentModel.Types.DurationDistanceMatrix.Types.Row> Rows {
          get { return rows_; }
        }

        /// <summary>Field number for the "vehicle_start_tag" field.</summary>
        public const int VehicleStartTagFieldNumber = 2;
        private string vehicleStartTag_ = "";
        /// <summary>
        /// Tag defining to which vehicles this duration and distance matrix applies.
        /// If empty, this applies to all vehicles, and there can only be a single
        /// matrix.
        ///
        /// Each vehicle start must match exactly one matrix, i.e. exactly one of
        /// their `start_tags` field must match the `vehicle_start_tag` of a matrix
        /// (and of that matrix only).
        ///
        /// All matrices must have a different `vehicle_start_tag`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string VehicleStartTag {
          get { return vehicleStartTag_; }
          set {
            vehicleStartTag_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as DurationDistanceMatrix);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(DurationDistanceMatrix other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!rows_.Equals(other.rows_)) return false;
          if (VehicleStartTag != other.VehicleStartTag) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= rows_.GetHashCode();
          if (VehicleStartTag.Length != 0) hash ^= VehicleStartTag.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          rows_.WriteTo(output, _repeated_rows_codec);
          if (VehicleStartTag.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(VehicleStartTag);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          rows_.WriteTo(ref output, _repeated_rows_codec);
          if (VehicleStartTag.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(VehicleStartTag);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          size += rows_.CalculateSize(_repeated_rows_codec);
          if (VehicleStartTag.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(VehicleStartTag);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(DurationDistanceMatrix other) {
          if (other == null) {
            return;
          }
          rows_.Add(other.rows_);
          if (other.VehicleStartTag.Length != 0) {
            VehicleStartTag = other.VehicleStartTag;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                rows_.AddEntriesFrom(input, _repeated_rows_codec);
                break;
              }
              case 18: {
                VehicleStartTag = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                rows_.AddEntriesFrom(ref input, _repeated_rows_codec);
                break;
              }
              case 18: {
                VehicleStartTag = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the DurationDistanceMatrix message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// Specifies a row of the duration and distance matrix.
          /// </summary>
          [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
          public sealed partial class Row : pb::IMessage<Row>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<Row> _parser = new pb::MessageParser<Row>(() => new Row());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<Row> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Maps.RouteOptimization.V1.ShipmentModel.Types.DurationDistanceMatrix.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Row() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Row(Row other) : this() {
              durations_ = other.durations_.Clone();
              meters_ = other.meters_.Clone();
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Row Clone() {
              return new Row(this);
            }

            /// <summary>Field number for the "durations" field.</summary>
            public const int DurationsFieldNumber = 1;
            private static readonly pb::FieldCodec<global::Google.Protobuf.WellKnownTypes.Duration> _repeated_durations_codec
                = pb::FieldCodec.ForMessage(10, global::Google.Protobuf.WellKnownTypes.Duration.Parser);
            private readonly pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Duration> durations_ = new pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Duration>();
            /// <summary>
            /// Duration values for a given row. It must have as many elements as
            /// [ShipmentModel.duration_distance_matrix_dst_tags][google.maps.routeoptimization.v1.ShipmentModel.duration_distance_matrix_dst_tags].
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Duration> Durations {
              get { return durations_; }
            }

            /// <summary>Field number for the "meters" field.</summary>
            public const int MetersFieldNumber = 2;
            private static readonly pb::FieldCodec<double> _repeated_meters_codec
                = pb::FieldCodec.ForDouble(18);
            private readonly pbc::RepeatedField<double> meters_ = new pbc::RepeatedField<double>();
            /// <summary>
            /// Distance values for a given row. If no costs or constraints refer to
            /// distances in the model, this can be left empty; otherwise it must have
            /// as many elements as `durations`.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public pbc::RepeatedField<double> Meters {
              get { return meters_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as Row);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(Row other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if(!durations_.Equals(other.durations_)) return false;
              if(!meters_.Equals(other.meters_)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              hash ^= durations_.GetHashCode();
              hash ^= meters_.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              durations_.WriteTo(output, _repeated_durations_codec);
              meters_.WriteTo(output, _repeated_meters_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              durations_.WriteTo(ref output, _repeated_durations_codec);
              meters_.WriteTo(ref output, _repeated_meters_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              size += durations_.CalculateSize(_repeated_durations_codec);
              size += meters_.CalculateSize(_repeated_meters_codec);
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(Row other) {
              if (other == null) {
                return;
              }
              durations_.Add(other.durations_);
              meters_.Add(other.meters_);
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    durations_.AddEntriesFrom(input, _repeated_durations_codec);
                    break;
                  }
                  case 18:
                  case 17: {
                    meters_.AddEntriesFrom(input, _repeated_meters_codec);
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    durations_.AddEntriesFrom(ref input, _repeated_durations_codec);
                    break;
                  }
                  case 18:
                  case 17: {
                    meters_.AddEntriesFrom(ref input, _repeated_meters_codec);
                    break;
                  }
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

      /// <summary>
      /// A precedence rule between two events (each event is the pickup or the
      /// delivery of a shipment): the "second" event has to start at least
      /// `offset_duration` after "first" has started.
      ///
      /// Several precedences can refer to the same (or related) events, e.g.,
      /// "pickup of B happens after delivery of A" and "pickup of C happens after
      /// pickup of B".
      ///
      /// Furthermore, precedences only apply when both shipments are performed and
      /// are otherwise ignored.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class PrecedenceRule : pb::IMessage<PrecedenceRule>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<PrecedenceRule> _parser = new pb::MessageParser<PrecedenceRule>(() => new PrecedenceRule());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<PrecedenceRule> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.RouteOptimization.V1.ShipmentModel.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PrecedenceRule() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PrecedenceRule(PrecedenceRule other) : this() {
          _hasBits0 = other._hasBits0;
          firstIndex_ = other.firstIndex_;
          firstIsDelivery_ = other.firstIsDelivery_;
          secondIndex_ = other.secondIndex_;
          secondIsDelivery_ = other.secondIsDelivery_;
          offsetDuration_ = other.offsetDuration_ != null ? other.offsetDuration_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PrecedenceRule Clone() {
          return new PrecedenceRule(this);
        }

        /// <summary>Field number for the "first_index" field.</summary>
        public const int FirstIndexFieldNumber = 1;
        private readonly static int FirstIndexDefaultValue = 0;

        private int firstIndex_;
        /// <summary>
        /// Shipment index of the "first" event. This field must be specified.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int FirstIndex {
          get { if ((_hasBits0 & 1) != 0) { return firstIndex_; } else { return FirstIndexDefaultValue; } }
          set {
            _hasBits0 |= 1;
            firstIndex_ = value;
          }
        }
        /// <summary>Gets whether the "first_index" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasFirstIndex {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "first_index" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearFirstIndex() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "first_is_delivery" field.</summary>
        public const int FirstIsDeliveryFieldNumber = 3;
        private bool firstIsDelivery_;
        /// <summary>
        /// Indicates if the "first" event is a delivery.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool FirstIsDelivery {
          get { return firstIsDelivery_; }
          set {
            firstIsDelivery_ = value;
          }
        }

        /// <summary>Field number for the "second_index" field.</summary>
        public const int SecondIndexFieldNumber = 2;
        private readonly static int SecondIndexDefaultValue = 0;

        private int secondIndex_;
        /// <summary>
        /// Shipment index of the "second" event. This field must be specified.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int SecondIndex {
          get { if ((_hasBits0 & 2) != 0) { return secondIndex_; } else { return SecondIndexDefaultValue; } }
          set {
            _hasBits0 |= 2;
            secondIndex_ = value;
          }
        }
        /// <summary>Gets whether the "second_index" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasSecondIndex {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "second_index" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearSecondIndex() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "second_is_delivery" field.</summary>
        public const int SecondIsDeliveryFieldNumber = 4;
        private bool secondIsDelivery_;
        /// <summary>
        /// Indicates if the "second" event is a delivery.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool SecondIsDelivery {
          get { return secondIsDelivery_; }
          set {
            secondIsDelivery_ = value;
          }
        }

        /// <summary>Field number for the "offset_duration" field.</summary>
        public const int OffsetDurationFieldNumber = 5;
        private global::Google.Protobuf.WellKnownTypes.Duration offsetDuration_;
        /// <summary>
        /// The offset between the "first" and "second" event. It can be negative.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration OffsetDuration {
          get { return offsetDuration_; }
          set {
            offsetDuration_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as PrecedenceRule);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(PrecedenceRule other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (FirstIndex != other.FirstIndex) return false;
          if (FirstIsDelivery != other.FirstIsDelivery) return false;
          if (SecondIndex != other.SecondIndex) return false;
          if (SecondIsDelivery != other.SecondIsDelivery) return false;
          if (!object.Equals(OffsetDuration, other.OffsetDuration)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasFirstIndex) hash ^= FirstIndex.GetHashCode();
          if (FirstIsDelivery != false) hash ^= FirstIsDelivery.GetHashCode();
          if (HasSecondIndex) hash ^= SecondIndex.GetHashCode();
          if (SecondIsDelivery != false) hash ^= SecondIsDelivery.GetHashCode();
          if (offsetDuration_ != null) hash ^= OffsetDuration.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasFirstIndex) {
            output.WriteRawTag(8);
            output.WriteInt32(FirstIndex);
          }
          if (HasSecondIndex) {
            output.WriteRawTag(16);
            output.WriteInt32(SecondIndex);
          }
          if (FirstIsDelivery != false) {
            output.WriteRawTag(24);
            output.WriteBool(FirstIsDelivery);
          }
          if (SecondIsDelivery != false) {
            output.WriteRawTag(32);
            output.WriteBool(SecondIsDelivery);
          }
          if (offsetDuration_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(OffsetDuration);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasFirstIndex) {
            output.WriteRawTag(8);
            output.WriteInt32(FirstIndex);
          }
          if (HasSecondIndex) {
            output.WriteRawTag(16);
            output.WriteInt32(SecondIndex);
          }
          if (FirstIsDelivery != false) {
            output.WriteRawTag(24);
            output.WriteBool(FirstIsDelivery);
          }
          if (SecondIsDelivery != false) {
            output.WriteRawTag(32);
            output.WriteBool(SecondIsDelivery);
          }
          if (offsetDuration_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(OffsetDuration);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasFirstIndex) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(FirstIndex);
          }
          if (FirstIsDelivery != false) {
            size += 1 + 1;
          }
          if (HasSecondIndex) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(SecondIndex);
          }
          if (SecondIsDelivery != false) {
            size += 1 + 1;
          }
          if (offsetDuration_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(OffsetDuration);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(PrecedenceRule other) {
          if (other == null) {
            return;
          }
          if (other.HasFirstIndex) {
            FirstIndex = other.FirstIndex;
          }
          if (other.FirstIsDelivery != false) {
            FirstIsDelivery = other.FirstIsDelivery;
          }
          if (other.HasSecondIndex) {
            SecondIndex = other.SecondIndex;
          }
          if (other.SecondIsDelivery != false) {
            SecondIsDelivery = other.SecondIsDelivery;
          }
          if (other.offsetDuration_ != null) {
            if (offsetDuration_ == null) {
              OffsetDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            OffsetDuration.MergeFrom(other.OffsetDuration);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                FirstIndex = input.ReadInt32();
                break;
              }
              case 16: {
                SecondIndex = input.ReadInt32();
                break;
              }
              case 24: {
                FirstIsDelivery = input.ReadBool();
                break;
              }
              case 32: {
                SecondIsDelivery = input.ReadBool();
                break;
              }
              case 42: {
                if (offsetDuration_ == null) {
                  OffsetDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(OffsetDuration);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                FirstIndex = input.ReadInt32();
                break;
              }
              case 16: {
                SecondIndex = input.ReadInt32();
                break;
              }
              case 24: {
                FirstIsDelivery = input.ReadBool();
                break;
              }
              case 32: {
                SecondIsDelivery = input.ReadBool();
                break;
              }
              case 42: {
                if (offsetDuration_ == null) {
                  OffsetDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(OffsetDuration);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// The shipment of a single item, from one of its pickups to one of its
  /// deliveries. For the shipment to be considered as performed, a unique vehicle
  /// must visit one of its pickup locations (and decrease its spare capacities
  /// accordingly), then visit one of its delivery locations later on (and
  /// therefore re-increase its spare capacities accordingly).
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Shipment : pb::IMessage<Shipment>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Shipment> _parser = new pb::MessageParser<Shipment>(() => new Shipment());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Shipment> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Shipment() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Shipment(Shipment other) : this() {
      _hasBits0 = other._hasBits0;
      displayName_ = other.displayName_;
      pickups_ = other.pickups_.Clone();
      deliveries_ = other.deliveries_.Clone();
      loadDemands_ = other.loadDemands_.Clone();
      penaltyCost_ = other.penaltyCost_;
      allowedVehicleIndices_ = other.allowedVehicleIndices_.Clone();
      costsPerVehicle_ = other.costsPerVehicle_.Clone();
      costsPerVehicleIndices_ = other.costsPerVehicleIndices_.Clone();
      pickupToDeliveryRelativeDetourLimit_ = other.pickupToDeliveryRelativeDetourLimit_;
      pickupToDeliveryAbsoluteDetourLimit_ = other.pickupToDeliveryAbsoluteDetourLimit_ != null ? other.pickupToDeliveryAbsoluteDetourLimit_.Clone() : null;
      pickupToDeliveryTimeLimit_ = other.pickupToDeliveryTimeLimit_ != null ? other.pickupToDeliveryTimeLimit_.Clone() : null;
      shipmentType_ = other.shipmentType_;
      label_ = other.label_;
      ignore_ = other.ignore_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Shipment Clone() {
      return new Shipment(this);
    }

    /// <summary>Field number for the "display_name" field.</summary>
    public const int DisplayNameFieldNumber = 16;
    private string displayName_ = "";
    /// <summary>
    /// The user-defined display name of the shipment.
    /// It can be up to 63 characters long and may use UTF-8 characters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DisplayName {
      get { return displayName_; }
      set {
        displayName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "pickups" field.</summary>
    public const int PickupsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.Shipment.Types.VisitRequest> _repeated_pickups_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Maps.RouteOptimization.V1.Shipment.Types.VisitRequest.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.Shipment.Types.VisitRequest> pickups_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.Shipment.Types.VisitRequest>();
    /// <summary>
    /// Set of pickup alternatives associated to the shipment. If not specified,
    /// the vehicle only needs to visit a location corresponding to the deliveries.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.Shipment.Types.VisitRequest> Pickups {
      get { return pickups_; }
    }

    /// <summary>Field number for the "deliveries" field.</summary>
    public const int DeliveriesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.Shipment.Types.VisitRequest> _repeated_deliveries_codec
        = pb::FieldCodec.ForMessage(18, global::Google.Maps.RouteOptimization.V1.Shipment.Types.VisitRequest.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.Shipment.Types.VisitRequest> deliveries_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.Shipment.Types.VisitRequest>();
    /// <summary>
    /// Set of delivery alternatives associated to the shipment. If not specified,
    /// the vehicle only needs to visit a location corresponding to the pickups.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.Shipment.Types.VisitRequest> Deliveries {
      get { return deliveries_; }
    }

    /// <summary>Field number for the "load_demands" field.</summary>
    public const int LoadDemandsFieldNumber = 14;
    private static readonly pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.Shipment.Types.Load>.Codec _map_loadDemands_codec
        = new pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.Shipment.Types.Load>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Google.Maps.RouteOptimization.V1.Shipment.Types.Load.Parser), 114);
    private readonly pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.Shipment.Types.Load> loadDemands_ = new pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.Shipment.Types.Load>();
    /// <summary>
    /// Load demands of the shipment (for example weight, volume, number of
    /// pallets etc). The keys in the map should be identifiers describing the type
    /// of the corresponding load, ideally also including the units.
    /// For example: "weight_kg", "volume_gallons", "pallet_count", etc.
    /// If a given key does not appear in the map, the corresponding load is
    /// considered as null.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.Shipment.Types.Load> LoadDemands {
      get { return loadDemands_; }
    }

    /// <summary>Field number for the "penalty_cost" field.</summary>
    public const int PenaltyCostFieldNumber = 4;
    private readonly static double PenaltyCostDefaultValue = 0D;

    private double penaltyCost_;
    /// <summary>
    /// If the shipment is not completed, this penalty is added to the overall
    /// cost of the routes. A shipment is considered completed if one of its pickup
    /// and delivery alternatives is visited. The cost may be expressed in the
    /// same unit used for all other cost-related fields in the model and must be
    /// positive.
    ///
    /// *IMPORTANT*: If this penalty is not specified, it is considered infinite,
    /// i.e. the shipment must be completed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double PenaltyCost {
      get { if ((_hasBits0 & 1) != 0) { return penaltyCost_; } else { return PenaltyCostDefaultValue; } }
      set {
        _hasBits0 |= 1;
        penaltyCost_ = value;
      }
    }
    /// <summary>Gets whether the "penalty_cost" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPenaltyCost {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "penalty_cost" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPenaltyCost() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "allowed_vehicle_indices" field.</summary>
    public const int AllowedVehicleIndicesFieldNumber = 5;
    private static readonly pb::FieldCodec<int> _repeated_allowedVehicleIndices_codec
        = pb::FieldCodec.ForInt32(42);
    private readonly pbc::RepeatedField<int> allowedVehicleIndices_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// The set of vehicles that may perform this shipment. If empty, all vehicles
    /// may perform it. Vehicles are given by their index in the `ShipmentModel`'s
    /// `vehicles` list.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> AllowedVehicleIndices {
      get { return allowedVehicleIndices_; }
    }

    /// <summary>Field number for the "costs_per_vehicle" field.</summary>
    public const int CostsPerVehicleFieldNumber = 6;
    private static readonly pb::FieldCodec<double> _repeated_costsPerVehicle_codec
        = pb::FieldCodec.ForDouble(50);
    private readonly pbc::RepeatedField<double> costsPerVehicle_ = new pbc::RepeatedField<double>();
    /// <summary>
    /// Specifies the cost that is incurred when this shipment is delivered by each
    /// vehicle. If specified, it must have EITHER:
    ///
    ///   * the same number of elements as `costs_per_vehicle_indices`.
    ///     `costs_per_vehicle[i]` corresponds to vehicle
    ///     `costs_per_vehicle_indices[i]` of the model.
    ///   * the same number of elements as there are vehicles in the model. The
    ///     i-th element corresponds to vehicle #i of the model.
    ///
    /// These costs must be in the same unit as `penalty_cost` and must not be
    /// negative. Leave this field empty, if there are no such costs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<double> CostsPerVehicle {
      get { return costsPerVehicle_; }
    }

    /// <summary>Field number for the "costs_per_vehicle_indices" field.</summary>
    public const int CostsPerVehicleIndicesFieldNumber = 7;
    private static readonly pb::FieldCodec<int> _repeated_costsPerVehicleIndices_codec
        = pb::FieldCodec.ForInt32(58);
    private readonly pbc::RepeatedField<int> costsPerVehicleIndices_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// Indices of the vehicles to which `costs_per_vehicle` applies. If non-empty,
    /// it must have the same number of elements as `costs_per_vehicle`. A vehicle
    /// index may not be specified more than once. If a vehicle is excluded from
    /// `costs_per_vehicle_indices`, its cost is zero.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> CostsPerVehicleIndices {
      get { return costsPerVehicleIndices_; }
    }

    /// <summary>Field number for the "pickup_to_delivery_relative_detour_limit" field.</summary>
    public const int PickupToDeliveryRelativeDetourLimitFieldNumber = 8;
    private readonly static double PickupToDeliveryRelativeDetourLimitDefaultValue = 0D;

    private double pickupToDeliveryRelativeDetourLimit_;
    /// <summary>
    /// Specifies the maximum relative detour time compared to the shortest path
    /// from pickup to delivery. If specified, it must be nonnegative, and the
    /// shipment must contain at least a pickup and a delivery.
    ///
    /// For example, let t be the shortest time taken to go from the selected
    /// pickup alternative directly to the selected delivery alternative. Then
    /// setting `pickup_to_delivery_relative_detour_limit` enforces:
    ///
    /// ```
    /// start_time(delivery) - start_time(pickup) &lt;=
    /// std::ceil(t * (1.0 + pickup_to_delivery_relative_detour_limit))
    /// ```
    ///
    /// If both relative and absolute limits are specified on the same shipment,
    /// the more constraining limit is used for each possible pickup/delivery pair.
    /// As of 2017/10, detours are only supported when travel durations do not
    /// depend on vehicles.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double PickupToDeliveryRelativeDetourLimit {
      get { if ((_hasBits0 & 2) != 0) { return pickupToDeliveryRelativeDetourLimit_; } else { return PickupToDeliveryRelativeDetourLimitDefaultValue; } }
      set {
        _hasBits0 |= 2;
        pickupToDeliveryRelativeDetourLimit_ = value;
      }
    }
    /// <summary>Gets whether the "pickup_to_delivery_relative_detour_limit" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPickupToDeliveryRelativeDetourLimit {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "pickup_to_delivery_relative_detour_limit" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPickupToDeliveryRelativeDetourLimit() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "pickup_to_delivery_absolute_detour_limit" field.</summary>
    public const int PickupToDeliveryAbsoluteDetourLimitFieldNumber = 9;
    private global::Google.Protobuf.WellKnownTypes.Duration pickupToDeliveryAbsoluteDetourLimit_;
    /// <summary>
    /// Specifies the maximum absolute detour time compared to the shortest path
    /// from pickup to delivery. If specified, it must be nonnegative, and the
    /// shipment must contain at least a pickup and a delivery.
    ///
    /// For example, let t be the shortest time taken to go from the selected
    /// pickup alternative directly to the selected delivery alternative. Then
    /// setting `pickup_to_delivery_absolute_detour_limit` enforces:
    ///
    /// ```
    /// start_time(delivery) - start_time(pickup) &lt;=
    /// t + pickup_to_delivery_absolute_detour_limit
    /// ```
    ///
    /// If both relative and absolute limits are specified on the same shipment,
    /// the more constraining limit is used for each possible pickup/delivery pair.
    /// As of 2017/10, detours are only supported when travel durations do not
    /// depend on vehicles.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration PickupToDeliveryAbsoluteDetourLimit {
      get { return pickupToDeliveryAbsoluteDetourLimit_; }
      set {
        pickupToDeliveryAbsoluteDetourLimit_ = value;
      }
    }

    /// <summary>Field number for the "pickup_to_delivery_time_limit" field.</summary>
    public const int PickupToDeliveryTimeLimitFieldNumber = 10;
    private global::Google.Protobuf.WellKnownTypes.Duration pickupToDeliveryTimeLimit_;
    /// <summary>
    /// Specifies the maximum duration from start of pickup to start of delivery of
    /// a shipment. If specified, it must be nonnegative, and the shipment must
    /// contain at least a pickup and a delivery. This does not depend on which
    /// alternatives are selected for pickup and delivery, nor on vehicle speed.
    /// This can be specified alongside maximum detour constraints: the solution
    /// will respect both specifications.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration PickupToDeliveryTimeLimit {
      get { return pickupToDeliveryTimeLimit_; }
      set {
        pickupToDeliveryTimeLimit_ = value;
      }
    }

    /// <summary>Field number for the "shipment_type" field.</summary>
    public const int ShipmentTypeFieldNumber = 11;
    private string shipmentType_ = "";
    /// <summary>
    /// Non-empty string specifying a "type" for this shipment.
    /// This feature can be used to define incompatibilities or requirements
    /// between `shipment_types` (see `shipment_type_incompatibilities` and
    /// `shipment_type_requirements` in `ShipmentModel`).
    ///
    /// Differs from `visit_types` which is specified for a single visit: All
    /// pickup/deliveries belonging to the same shipment share the same
    /// `shipment_type`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ShipmentType {
      get { return shipmentType_; }
      set {
        shipmentType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "label" field.</summary>
    public const int LabelFieldNumber = 12;
    private string label_ = "";
    /// <summary>
    /// Specifies a label for this shipment. This label is reported in the response
    /// in the `shipment_label` of the corresponding
    /// [ShipmentRoute.Visit][google.maps.routeoptimization.v1.ShipmentRoute.Visit].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Label {
      get { return label_; }
      set {
        label_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "ignore" field.</summary>
    public const int IgnoreFieldNumber = 13;
    private bool ignore_;
    /// <summary>
    /// If true, skip this shipment, but don't apply a `penalty_cost`.
    ///
    /// Ignoring a shipment results in a validation error when there are any
    /// `shipment_type_requirements` in the model.
    ///
    /// Ignoring a shipment that is performed in `injected_first_solution_routes`
    /// or `injected_solution_constraint` is permitted; the solver removes the
    /// related pickup/delivery visits from the performing route.
    /// `precedence_rules` that reference ignored shipments will also be ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Ignore {
      get { return ignore_; }
      set {
        ignore_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Shipment);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Shipment other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (DisplayName != other.DisplayName) return false;
      if(!pickups_.Equals(other.pickups_)) return false;
      if(!deliveries_.Equals(other.deliveries_)) return false;
      if (!LoadDemands.Equals(other.LoadDemands)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(PenaltyCost, other.PenaltyCost)) return false;
      if(!allowedVehicleIndices_.Equals(other.allowedVehicleIndices_)) return false;
      if(!costsPerVehicle_.Equals(other.costsPerVehicle_)) return false;
      if(!costsPerVehicleIndices_.Equals(other.costsPerVehicleIndices_)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(PickupToDeliveryRelativeDetourLimit, other.PickupToDeliveryRelativeDetourLimit)) return false;
      if (!object.Equals(PickupToDeliveryAbsoluteDetourLimit, other.PickupToDeliveryAbsoluteDetourLimit)) return false;
      if (!object.Equals(PickupToDeliveryTimeLimit, other.PickupToDeliveryTimeLimit)) return false;
      if (ShipmentType != other.ShipmentType) return false;
      if (Label != other.Label) return false;
      if (Ignore != other.Ignore) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (DisplayName.Length != 0) hash ^= DisplayName.GetHashCode();
      hash ^= pickups_.GetHashCode();
      hash ^= deliveries_.GetHashCode();
      hash ^= LoadDemands.GetHashCode();
      if (HasPenaltyCost) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(PenaltyCost);
      hash ^= allowedVehicleIndices_.GetHashCode();
      hash ^= costsPerVehicle_.GetHashCode();
      hash ^= costsPerVehicleIndices_.GetHashCode();
      if (HasPickupToDeliveryRelativeDetourLimit) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(PickupToDeliveryRelativeDetourLimit);
      if (pickupToDeliveryAbsoluteDetourLimit_ != null) hash ^= PickupToDeliveryAbsoluteDetourLimit.GetHashCode();
      if (pickupToDeliveryTimeLimit_ != null) hash ^= PickupToDeliveryTimeLimit.GetHashCode();
      if (ShipmentType.Length != 0) hash ^= ShipmentType.GetHashCode();
      if (Label.Length != 0) hash ^= Label.GetHashCode();
      if (Ignore != false) hash ^= Ignore.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      pickups_.WriteTo(output, _repeated_pickups_codec);
      deliveries_.WriteTo(output, _repeated_deliveries_codec);
      if (HasPenaltyCost) {
        output.WriteRawTag(33);
        output.WriteDouble(PenaltyCost);
      }
      allowedVehicleIndices_.WriteTo(output, _repeated_allowedVehicleIndices_codec);
      costsPerVehicle_.WriteTo(output, _repeated_costsPerVehicle_codec);
      costsPerVehicleIndices_.WriteTo(output, _repeated_costsPerVehicleIndices_codec);
      if (HasPickupToDeliveryRelativeDetourLimit) {
        output.WriteRawTag(65);
        output.WriteDouble(PickupToDeliveryRelativeDetourLimit);
      }
      if (pickupToDeliveryAbsoluteDetourLimit_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(PickupToDeliveryAbsoluteDetourLimit);
      }
      if (pickupToDeliveryTimeLimit_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(PickupToDeliveryTimeLimit);
      }
      if (ShipmentType.Length != 0) {
        output.WriteRawTag(90);
        output.WriteString(ShipmentType);
      }
      if (Label.Length != 0) {
        output.WriteRawTag(98);
        output.WriteString(Label);
      }
      if (Ignore != false) {
        output.WriteRawTag(104);
        output.WriteBool(Ignore);
      }
      loadDemands_.WriteTo(output, _map_loadDemands_codec);
      if (DisplayName.Length != 0) {
        output.WriteRawTag(130, 1);
        output.WriteString(DisplayName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      pickups_.WriteTo(ref output, _repeated_pickups_codec);
      deliveries_.WriteTo(ref output, _repeated_deliveries_codec);
      if (HasPenaltyCost) {
        output.WriteRawTag(33);
        output.WriteDouble(PenaltyCost);
      }
      allowedVehicleIndices_.WriteTo(ref output, _repeated_allowedVehicleIndices_codec);
      costsPerVehicle_.WriteTo(ref output, _repeated_costsPerVehicle_codec);
      costsPerVehicleIndices_.WriteTo(ref output, _repeated_costsPerVehicleIndices_codec);
      if (HasPickupToDeliveryRelativeDetourLimit) {
        output.WriteRawTag(65);
        output.WriteDouble(PickupToDeliveryRelativeDetourLimit);
      }
      if (pickupToDeliveryAbsoluteDetourLimit_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(PickupToDeliveryAbsoluteDetourLimit);
      }
      if (pickupToDeliveryTimeLimit_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(PickupToDeliveryTimeLimit);
      }
      if (ShipmentType.Length != 0) {
        output.WriteRawTag(90);
        output.WriteString(ShipmentType);
      }
      if (Label.Length != 0) {
        output.WriteRawTag(98);
        output.WriteString(Label);
      }
      if (Ignore != false) {
        output.WriteRawTag(104);
        output.WriteBool(Ignore);
      }
      loadDemands_.WriteTo(ref output, _map_loadDemands_codec);
      if (DisplayName.Length != 0) {
        output.WriteRawTag(130, 1);
        output.WriteString(DisplayName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (DisplayName.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(DisplayName);
      }
      size += pickups_.CalculateSize(_repeated_pickups_codec);
      size += deliveries_.CalculateSize(_repeated_deliveries_codec);
      size += loadDemands_.CalculateSize(_map_loadDemands_codec);
      if (HasPenaltyCost) {
        size += 1 + 8;
      }
      size += allowedVehicleIndices_.CalculateSize(_repeated_allowedVehicleIndices_codec);
      size += costsPerVehicle_.CalculateSize(_repeated_costsPerVehicle_codec);
      size += costsPerVehicleIndices_.CalculateSize(_repeated_costsPerVehicleIndices_codec);
      if (HasPickupToDeliveryRelativeDetourLimit) {
        size += 1 + 8;
      }
      if (pickupToDeliveryAbsoluteDetourLimit_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PickupToDeliveryAbsoluteDetourLimit);
      }
      if (pickupToDeliveryTimeLimit_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PickupToDeliveryTimeLimit);
      }
      if (ShipmentType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ShipmentType);
      }
      if (Label.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Label);
      }
      if (Ignore != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Shipment other) {
      if (other == null) {
        return;
      }
      if (other.DisplayName.Length != 0) {
        DisplayName = other.DisplayName;
      }
      pickups_.Add(other.pickups_);
      deliveries_.Add(other.deliveries_);
      loadDemands_.MergeFrom(other.loadDemands_);
      if (other.HasPenaltyCost) {
        PenaltyCost = other.PenaltyCost;
      }
      allowedVehicleIndices_.Add(other.allowedVehicleIndices_);
      costsPerVehicle_.Add(other.costsPerVehicle_);
      costsPerVehicleIndices_.Add(other.costsPerVehicleIndices_);
      if (other.HasPickupToDeliveryRelativeDetourLimit) {
        PickupToDeliveryRelativeDetourLimit = other.PickupToDeliveryRelativeDetourLimit;
      }
      if (other.pickupToDeliveryAbsoluteDetourLimit_ != null) {
        if (pickupToDeliveryAbsoluteDetourLimit_ == null) {
          PickupToDeliveryAbsoluteDetourLimit = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        PickupToDeliveryAbsoluteDetourLimit.MergeFrom(other.PickupToDeliveryAbsoluteDetourLimit);
      }
      if (other.pickupToDeliveryTimeLimit_ != null) {
        if (pickupToDeliveryTimeLimit_ == null) {
          PickupToDeliveryTimeLimit = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        PickupToDeliveryTimeLimit.MergeFrom(other.PickupToDeliveryTimeLimit);
      }
      if (other.ShipmentType.Length != 0) {
        ShipmentType = other.ShipmentType;
      }
      if (other.Label.Length != 0) {
        Label = other.Label;
      }
      if (other.Ignore != false) {
        Ignore = other.Ignore;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            pickups_.AddEntriesFrom(input, _repeated_pickups_codec);
            break;
          }
          case 18: {
            deliveries_.AddEntriesFrom(input, _repeated_deliveries_codec);
            break;
          }
          case 33: {
            PenaltyCost = input.ReadDouble();
            break;
          }
          case 42:
          case 40: {
            allowedVehicleIndices_.AddEntriesFrom(input, _repeated_allowedVehicleIndices_codec);
            break;
          }
          case 50:
          case 49: {
            costsPerVehicle_.AddEntriesFrom(input, _repeated_costsPerVehicle_codec);
            break;
          }
          case 58:
          case 56: {
            costsPerVehicleIndices_.AddEntriesFrom(input, _repeated_costsPerVehicleIndices_codec);
            break;
          }
          case 65: {
            PickupToDeliveryRelativeDetourLimit = input.ReadDouble();
            break;
          }
          case 74: {
            if (pickupToDeliveryAbsoluteDetourLimit_ == null) {
              PickupToDeliveryAbsoluteDetourLimit = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(PickupToDeliveryAbsoluteDetourLimit);
            break;
          }
          case 82: {
            if (pickupToDeliveryTimeLimit_ == null) {
              PickupToDeliveryTimeLimit = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(PickupToDeliveryTimeLimit);
            break;
          }
          case 90: {
            ShipmentType = input.ReadString();
            break;
          }
          case 98: {
            Label = input.ReadString();
            break;
          }
          case 104: {
            Ignore = input.ReadBool();
            break;
          }
          case 114: {
            loadDemands_.AddEntriesFrom(input, _map_loadDemands_codec);
            break;
          }
          case 130: {
            DisplayName = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            pickups_.AddEntriesFrom(ref input, _repeated_pickups_codec);
            break;
          }
          case 18: {
            deliveries_.AddEntriesFrom(ref input, _repeated_deliveries_codec);
            break;
          }
          case 33: {
            PenaltyCost = input.ReadDouble();
            break;
          }
          case 42:
          case 40: {
            allowedVehicleIndices_.AddEntriesFrom(ref input, _repeated_allowedVehicleIndices_codec);
            break;
          }
          case 50:
          case 49: {
            costsPerVehicle_.AddEntriesFrom(ref input, _repeated_costsPerVehicle_codec);
            break;
          }
          case 58:
          case 56: {
            costsPerVehicleIndices_.AddEntriesFrom(ref input, _repeated_costsPerVehicleIndices_codec);
            break;
          }
          case 65: {
            PickupToDeliveryRelativeDetourLimit = input.ReadDouble();
            break;
          }
          case 74: {
            if (pickupToDeliveryAbsoluteDetourLimit_ == null) {
              PickupToDeliveryAbsoluteDetourLimit = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(PickupToDeliveryAbsoluteDetourLimit);
            break;
          }
          case 82: {
            if (pickupToDeliveryTimeLimit_ == null) {
              PickupToDeliveryTimeLimit = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(PickupToDeliveryTimeLimit);
            break;
          }
          case 90: {
            ShipmentType = input.ReadString();
            break;
          }
          case 98: {
            Label = input.ReadString();
            break;
          }
          case 104: {
            Ignore = input.ReadBool();
            break;
          }
          case 114: {
            loadDemands_.AddEntriesFrom(ref input, _map_loadDemands_codec);
            break;
          }
          case 130: {
            DisplayName = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Shipment message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Request for a visit which can be done by a vehicle: it has a geo-location
      /// (or two, see below), opening and closing times represented by time windows,
      /// and a service duration time (time spent by the vehicle once it has arrived
      /// to pickup or drop off goods).
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class VisitRequest : pb::IMessage<VisitRequest>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<VisitRequest> _parser = new pb::MessageParser<VisitRequest>(() => new VisitRequest());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<VisitRequest> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.RouteOptimization.V1.Shipment.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VisitRequest() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VisitRequest(VisitRequest other) : this() {
          arrivalLocation_ = other.arrivalLocation_ != null ? other.arrivalLocation_.Clone() : null;
          arrivalWaypoint_ = other.arrivalWaypoint_ != null ? other.arrivalWaypoint_.Clone() : null;
          departureLocation_ = other.departureLocation_ != null ? other.departureLocation_.Clone() : null;
          departureWaypoint_ = other.departureWaypoint_ != null ? other.departureWaypoint_.Clone() : null;
          tags_ = other.tags_.Clone();
          timeWindows_ = other.timeWindows_.Clone();
          duration_ = other.duration_ != null ? other.duration_.Clone() : null;
          cost_ = other.cost_;
          loadDemands_ = other.loadDemands_.Clone();
          visitTypes_ = other.visitTypes_.Clone();
          label_ = other.label_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VisitRequest Clone() {
          return new VisitRequest(this);
        }

        /// <summary>Field number for the "arrival_location" field.</summary>
        public const int ArrivalLocationFieldNumber = 1;
        private global::Google.Type.LatLng arrivalLocation_;
        /// <summary>
        /// The geo-location where the vehicle arrives when performing this
        /// `VisitRequest`. If the shipment model has duration distance matrices,
        /// `arrival_location` must not be specified.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Type.LatLng ArrivalLocation {
          get { return arrivalLocation_; }
          set {
            arrivalLocation_ = value;
          }
        }

        /// <summary>Field number for the "arrival_waypoint" field.</summary>
        public const int ArrivalWaypointFieldNumber = 2;
        private global::Google.Maps.RouteOptimization.V1.Waypoint arrivalWaypoint_;
        /// <summary>
        /// The waypoint where the vehicle arrives when performing this
        /// `VisitRequest`. If the shipment model has duration distance matrices,
        /// `arrival_waypoint` must not be specified.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Maps.RouteOptimization.V1.Waypoint ArrivalWaypoint {
          get { return arrivalWaypoint_; }
          set {
            arrivalWaypoint_ = value;
          }
        }

        /// <summary>Field number for the "departure_location" field.</summary>
        public const int DepartureLocationFieldNumber = 3;
        private global::Google.Type.LatLng departureLocation_;
        /// <summary>
        /// The geo-location where the vehicle departs after completing this
        /// `VisitRequest`. Can be omitted if it is the same as `arrival_location`.
        /// If the shipment model has duration distance matrices,
        /// `departure_location` must not be specified.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Type.LatLng DepartureLocation {
          get { return departureLocation_; }
          set {
            departureLocation_ = value;
          }
        }

        /// <summary>Field number for the "departure_waypoint" field.</summary>
        public const int DepartureWaypointFieldNumber = 4;
        private global::Google.Maps.RouteOptimization.V1.Waypoint departureWaypoint_;
        /// <summary>
        /// The waypoint where the vehicle departs after completing this
        /// `VisitRequest`. Can be omitted if it is the same as `arrival_waypoint`.
        /// If the shipment model has duration distance matrices,
        /// `departure_waypoint` must not be specified.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Maps.RouteOptimization.V1.Waypoint DepartureWaypoint {
          get { return departureWaypoint_; }
          set {
            departureWaypoint_ = value;
          }
        }

        /// <summary>Field number for the "tags" field.</summary>
        public const int TagsFieldNumber = 5;
        private static readonly pb::FieldCodec<string> _repeated_tags_codec
            = pb::FieldCodec.ForString(42);
        private readonly pbc::RepeatedField<string> tags_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// Specifies tags attached to the visit request.
        /// Empty or duplicate strings are not allowed.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<string> Tags {
          get { return tags_; }
        }

        /// <summary>Field number for the "time_windows" field.</summary>
        public const int TimeWindowsFieldNumber = 6;
        private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.TimeWindow> _repeated_timeWindows_codec
            = pb::FieldCodec.ForMessage(50, global::Google.Maps.RouteOptimization.V1.TimeWindow.Parser);
        private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.TimeWindow> timeWindows_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.TimeWindow>();
        /// <summary>
        /// Time windows which constrain the arrival time at a visit.
        /// Note that a vehicle may depart outside of the arrival time window, i.e.
        /// arrival time + duration do not need to be inside a time window. This can
        /// result in waiting time if the vehicle arrives before
        /// [TimeWindow.start_time][google.maps.routeoptimization.v1.TimeWindow.start_time].
        ///
        /// The absence of `TimeWindow` means that the vehicle can perform this visit
        /// at any time.
        ///
        /// Time windows must be disjoint, i.e. no time window must overlap with or
        /// be adjacent to another, and they must be in increasing order.
        ///
        /// `cost_per_hour_after_soft_end_time` and `soft_end_time` can only
        /// be set if there is a single time window.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.TimeWindow> TimeWindows {
          get { return timeWindows_; }
        }

        /// <summary>Field number for the "duration" field.</summary>
        public const int DurationFieldNumber = 7;
        private global::Google.Protobuf.WellKnownTypes.Duration duration_;
        /// <summary>
        /// Duration of the visit, i.e. time spent by the vehicle between arrival
        /// and departure (to be added to the possible waiting time; see
        /// `time_windows`).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration Duration {
          get { return duration_; }
          set {
            duration_ = value;
          }
        }

        /// <summary>Field number for the "cost" field.</summary>
        public const int CostFieldNumber = 8;
        private double cost_;
        /// <summary>
        /// Cost to service this visit request on a vehicle route. This can be used
        /// to pay different costs for each alternative pickup or delivery of a
        /// shipment. This cost must be in the same unit as `Shipment.penalty_cost`
        /// and must not be negative.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public double Cost {
          get { return cost_; }
          set {
            cost_ = value;
          }
        }

        /// <summary>Field number for the "load_demands" field.</summary>
        public const int LoadDemandsFieldNumber = 12;
        private static readonly pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.Shipment.Types.Load>.Codec _map_loadDemands_codec
            = new pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.Shipment.Types.Load>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Google.Maps.RouteOptimization.V1.Shipment.Types.Load.Parser), 98);
        private readonly pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.Shipment.Types.Load> loadDemands_ = new pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.Shipment.Types.Load>();
        /// <summary>
        /// Load demands of this visit request. This is just like
        /// [Shipment.load_demands][google.maps.routeoptimization.v1.Shipment.load_demands]
        /// field, except that it only applies to this
        /// [VisitRequest][google.maps.routeoptimization.v1.Shipment.VisitRequest]
        /// instead of the whole
        /// [Shipment][google.maps.routeoptimization.v1.Shipment]. The demands listed
        /// here are added to the demands listed in
        /// [Shipment.load_demands][google.maps.routeoptimization.v1.Shipment.load_demands].
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.Shipment.Types.Load> LoadDemands {
          get { return loadDemands_; }
        }

        /// <summary>Field number for the "visit_types" field.</summary>
        public const int VisitTypesFieldNumber = 10;
        private static readonly pb::FieldCodec<string> _repeated_visitTypes_codec
            = pb::FieldCodec.ForString(82);
        private readonly pbc::RepeatedField<string> visitTypes_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// Specifies the types of the visit. This may be used to allocate additional
        /// time required for a vehicle to complete this visit (see
        /// [Vehicle.extra_visit_duration_for_visit_type][google.maps.routeoptimization.v1.Vehicle.extra_visit_duration_for_visit_type]).
        ///
        /// A type can only appear once.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<string> VisitTypes {
          get { return visitTypes_; }
        }

        /// <summary>Field number for the "label" field.</summary>
        public const int LabelFieldNumber = 11;
        private string label_ = "";
        /// <summary>
        /// Specifies a label for this `VisitRequest`. This label is reported in the
        /// response as `visit_label` in the corresponding
        /// [ShipmentRoute.Visit][google.maps.routeoptimization.v1.ShipmentRoute.Visit].
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Label {
          get { return label_; }
          set {
            label_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as VisitRequest);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(VisitRequest other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(ArrivalLocation, other.ArrivalLocation)) return false;
          if (!object.Equals(ArrivalWaypoint, other.ArrivalWaypoint)) return false;
          if (!object.Equals(DepartureLocation, other.DepartureLocation)) return false;
          if (!object.Equals(DepartureWaypoint, other.DepartureWaypoint)) return false;
          if(!tags_.Equals(other.tags_)) return false;
          if(!timeWindows_.Equals(other.timeWindows_)) return false;
          if (!object.Equals(Duration, other.Duration)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Cost, other.Cost)) return false;
          if (!LoadDemands.Equals(other.LoadDemands)) return false;
          if(!visitTypes_.Equals(other.visitTypes_)) return false;
          if (Label != other.Label) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (arrivalLocation_ != null) hash ^= ArrivalLocation.GetHashCode();
          if (arrivalWaypoint_ != null) hash ^= ArrivalWaypoint.GetHashCode();
          if (departureLocation_ != null) hash ^= DepartureLocation.GetHashCode();
          if (departureWaypoint_ != null) hash ^= DepartureWaypoint.GetHashCode();
          hash ^= tags_.GetHashCode();
          hash ^= timeWindows_.GetHashCode();
          if (duration_ != null) hash ^= Duration.GetHashCode();
          if (Cost != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Cost);
          hash ^= LoadDemands.GetHashCode();
          hash ^= visitTypes_.GetHashCode();
          if (Label.Length != 0) hash ^= Label.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (arrivalLocation_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(ArrivalLocation);
          }
          if (arrivalWaypoint_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(ArrivalWaypoint);
          }
          if (departureLocation_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(DepartureLocation);
          }
          if (departureWaypoint_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(DepartureWaypoint);
          }
          tags_.WriteTo(output, _repeated_tags_codec);
          timeWindows_.WriteTo(output, _repeated_timeWindows_codec);
          if (duration_ != null) {
            output.WriteRawTag(58);
            output.WriteMessage(Duration);
          }
          if (Cost != 0D) {
            output.WriteRawTag(65);
            output.WriteDouble(Cost);
          }
          visitTypes_.WriteTo(output, _repeated_visitTypes_codec);
          if (Label.Length != 0) {
            output.WriteRawTag(90);
            output.WriteString(Label);
          }
          loadDemands_.WriteTo(output, _map_loadDemands_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (arrivalLocation_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(ArrivalLocation);
          }
          if (arrivalWaypoint_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(ArrivalWaypoint);
          }
          if (departureLocation_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(DepartureLocation);
          }
          if (departureWaypoint_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(DepartureWaypoint);
          }
          tags_.WriteTo(ref output, _repeated_tags_codec);
          timeWindows_.WriteTo(ref output, _repeated_timeWindows_codec);
          if (duration_ != null) {
            output.WriteRawTag(58);
            output.WriteMessage(Duration);
          }
          if (Cost != 0D) {
            output.WriteRawTag(65);
            output.WriteDouble(Cost);
          }
          visitTypes_.WriteTo(ref output, _repeated_visitTypes_codec);
          if (Label.Length != 0) {
            output.WriteRawTag(90);
            output.WriteString(Label);
          }
          loadDemands_.WriteTo(ref output, _map_loadDemands_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (arrivalLocation_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ArrivalLocation);
          }
          if (arrivalWaypoint_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ArrivalWaypoint);
          }
          if (departureLocation_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(DepartureLocation);
          }
          if (departureWaypoint_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(DepartureWaypoint);
          }
          size += tags_.CalculateSize(_repeated_tags_codec);
          size += timeWindows_.CalculateSize(_repeated_timeWindows_codec);
          if (duration_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Duration);
          }
          if (Cost != 0D) {
            size += 1 + 8;
          }
          size += loadDemands_.CalculateSize(_map_loadDemands_codec);
          size += visitTypes_.CalculateSize(_repeated_visitTypes_codec);
          if (Label.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Label);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(VisitRequest other) {
          if (other == null) {
            return;
          }
          if (other.arrivalLocation_ != null) {
            if (arrivalLocation_ == null) {
              ArrivalLocation = new global::Google.Type.LatLng();
            }
            ArrivalLocation.MergeFrom(other.ArrivalLocation);
          }
          if (other.arrivalWaypoint_ != null) {
            if (arrivalWaypoint_ == null) {
              ArrivalWaypoint = new global::Google.Maps.RouteOptimization.V1.Waypoint();
            }
            ArrivalWaypoint.MergeFrom(other.ArrivalWaypoint);
          }
          if (other.departureLocation_ != null) {
            if (departureLocation_ == null) {
              DepartureLocation = new global::Google.Type.LatLng();
            }
            DepartureLocation.MergeFrom(other.DepartureLocation);
          }
          if (other.departureWaypoint_ != null) {
            if (departureWaypoint_ == null) {
              DepartureWaypoint = new global::Google.Maps.RouteOptimization.V1.Waypoint();
            }
            DepartureWaypoint.MergeFrom(other.DepartureWaypoint);
          }
          tags_.Add(other.tags_);
          timeWindows_.Add(other.timeWindows_);
          if (other.duration_ != null) {
            if (duration_ == null) {
              Duration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            Duration.MergeFrom(other.Duration);
          }
          if (other.Cost != 0D) {
            Cost = other.Cost;
          }
          loadDemands_.MergeFrom(other.loadDemands_);
          visitTypes_.Add(other.visitTypes_);
          if (other.Label.Length != 0) {
            Label = other.Label;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (arrivalLocation_ == null) {
                  ArrivalLocation = new global::Google.Type.LatLng();
                }
                input.ReadMessage(ArrivalLocation);
                break;
              }
              case 18: {
                if (arrivalWaypoint_ == null) {
                  ArrivalWaypoint = new global::Google.Maps.RouteOptimization.V1.Waypoint();
                }
                input.ReadMessage(ArrivalWaypoint);
                break;
              }
              case 26: {
                if (departureLocation_ == null) {
                  DepartureLocation = new global::Google.Type.LatLng();
                }
                input.ReadMessage(DepartureLocation);
                break;
              }
              case 34: {
                if (departureWaypoint_ == null) {
                  DepartureWaypoint = new global::Google.Maps.RouteOptimization.V1.Waypoint();
                }
                input.ReadMessage(DepartureWaypoint);
                break;
              }
              case 42: {
                tags_.AddEntriesFrom(input, _repeated_tags_codec);
                break;
              }
              case 50: {
                timeWindows_.AddEntriesFrom(input, _repeated_timeWindows_codec);
                break;
              }
              case 58: {
                if (duration_ == null) {
                  Duration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(Duration);
                break;
              }
              case 65: {
                Cost = input.ReadDouble();
                break;
              }
              case 82: {
                visitTypes_.AddEntriesFrom(input, _repeated_visitTypes_codec);
                break;
              }
              case 90: {
                Label = input.ReadString();
                break;
              }
              case 98: {
                loadDemands_.AddEntriesFrom(input, _map_loadDemands_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (arrivalLocation_ == null) {
                  ArrivalLocation = new global::Google.Type.LatLng();
                }
                input.ReadMessage(ArrivalLocation);
                break;
              }
              case 18: {
                if (arrivalWaypoint_ == null) {
                  ArrivalWaypoint = new global::Google.Maps.RouteOptimization.V1.Waypoint();
                }
                input.ReadMessage(ArrivalWaypoint);
                break;
              }
              case 26: {
                if (departureLocation_ == null) {
                  DepartureLocation = new global::Google.Type.LatLng();
                }
                input.ReadMessage(DepartureLocation);
                break;
              }
              case 34: {
                if (departureWaypoint_ == null) {
                  DepartureWaypoint = new global::Google.Maps.RouteOptimization.V1.Waypoint();
                }
                input.ReadMessage(DepartureWaypoint);
                break;
              }
              case 42: {
                tags_.AddEntriesFrom(ref input, _repeated_tags_codec);
                break;
              }
              case 50: {
                timeWindows_.AddEntriesFrom(ref input, _repeated_timeWindows_codec);
                break;
              }
              case 58: {
                if (duration_ == null) {
                  Duration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(Duration);
                break;
              }
              case 65: {
                Cost = input.ReadDouble();
                break;
              }
              case 82: {
                visitTypes_.AddEntriesFrom(ref input, _repeated_visitTypes_codec);
                break;
              }
              case 90: {
                Label = input.ReadString();
                break;
              }
              case 98: {
                loadDemands_.AddEntriesFrom(ref input, _map_loadDemands_codec);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// When performing a visit, a predefined amount may be added to the vehicle
      /// load if it's a pickup, or subtracted if it's a delivery. This message
      /// defines such amount. See
      /// [load_demands][google.maps.routeoptimization.v1.Shipment.load_demands].
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class Load : pb::IMessage<Load>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Load> _parser = new pb::MessageParser<Load>(() => new Load());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Load> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.RouteOptimization.V1.Shipment.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Load() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Load(Load other) : this() {
          amount_ = other.amount_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Load Clone() {
          return new Load(this);
        }

        /// <summary>Field number for the "amount" field.</summary>
        public const int AmountFieldNumber = 2;
        private long amount_;
        /// <summary>
        /// The amount by which the load of the vehicle performing the corresponding
        /// visit will vary. Since it is an integer, users are advised to choose an
        /// appropriate unit to avoid loss of precision. Must be  0.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public long Amount {
          get { return amount_; }
          set {
            amount_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Load);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Load other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Amount != other.Amount) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Amount != 0L) hash ^= Amount.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Amount != 0L) {
            output.WriteRawTag(16);
            output.WriteInt64(Amount);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Amount != 0L) {
            output.WriteRawTag(16);
            output.WriteInt64(Amount);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Amount != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(Amount);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Load other) {
          if (other == null) {
            return;
          }
          if (other.Amount != 0L) {
            Amount = other.Amount;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 16: {
                Amount = input.ReadInt64();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 16: {
                Amount = input.ReadInt64();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Specifies incompatibilties between shipments depending on their
  /// shipment_type. The appearance of incompatible shipments on the same route is
  /// restricted based on the incompatibility mode.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ShipmentTypeIncompatibility : pb::IMessage<ShipmentTypeIncompatibility>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ShipmentTypeIncompatibility> _parser = new pb::MessageParser<ShipmentTypeIncompatibility>(() => new ShipmentTypeIncompatibility());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ShipmentTypeIncompatibility> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ShipmentTypeIncompatibility() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ShipmentTypeIncompatibility(ShipmentTypeIncompatibility other) : this() {
      types_ = other.types_.Clone();
      incompatibilityMode_ = other.incompatibilityMode_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ShipmentTypeIncompatibility Clone() {
      return new ShipmentTypeIncompatibility(this);
    }

    /// <summary>Field number for the "types" field.</summary>
    public const int Types_FieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_types_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> types_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// List of incompatible types. Two shipments having different `shipment_types`
    /// among those listed are "incompatible".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Types_ {
      get { return types_; }
    }

    /// <summary>Field number for the "incompatibility_mode" field.</summary>
    public const int IncompatibilityModeFieldNumber = 2;
    private global::Google.Maps.RouteOptimization.V1.ShipmentTypeIncompatibility.Types.IncompatibilityMode incompatibilityMode_ = global::Google.Maps.RouteOptimization.V1.ShipmentTypeIncompatibility.Types.IncompatibilityMode.Unspecified;
    /// <summary>
    /// Mode applied to the incompatibility.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.ShipmentTypeIncompatibility.Types.IncompatibilityMode IncompatibilityMode {
      get { return incompatibilityMode_; }
      set {
        incompatibilityMode_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ShipmentTypeIncompatibility);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ShipmentTypeIncompatibility other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!types_.Equals(other.types_)) return false;
      if (IncompatibilityMode != other.IncompatibilityMode) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= types_.GetHashCode();
      if (IncompatibilityMode != global::Google.Maps.RouteOptimization.V1.ShipmentTypeIncompatibility.Types.IncompatibilityMode.Unspecified) hash ^= IncompatibilityMode.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      types_.WriteTo(output, _repeated_types_codec);
      if (IncompatibilityMode != global::Google.Maps.RouteOptimization.V1.ShipmentTypeIncompatibility.Types.IncompatibilityMode.Unspecified) {
        output.WriteRawTag(16);
        output.WriteEnum((int) IncompatibilityMode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      types_.WriteTo(ref output, _repeated_types_codec);
      if (IncompatibilityMode != global::Google.Maps.RouteOptimization.V1.ShipmentTypeIncompatibility.Types.IncompatibilityMode.Unspecified) {
        output.WriteRawTag(16);
        output.WriteEnum((int) IncompatibilityMode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += types_.CalculateSize(_repeated_types_codec);
      if (IncompatibilityMode != global::Google.Maps.RouteOptimization.V1.ShipmentTypeIncompatibility.Types.IncompatibilityMode.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) IncompatibilityMode);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ShipmentTypeIncompatibility other) {
      if (other == null) {
        return;
      }
      types_.Add(other.types_);
      if (other.IncompatibilityMode != global::Google.Maps.RouteOptimization.V1.ShipmentTypeIncompatibility.Types.IncompatibilityMode.Unspecified) {
        IncompatibilityMode = other.IncompatibilityMode;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            types_.AddEntriesFrom(input, _repeated_types_codec);
            break;
          }
          case 16: {
            IncompatibilityMode = (global::Google.Maps.RouteOptimization.V1.ShipmentTypeIncompatibility.Types.IncompatibilityMode) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            types_.AddEntriesFrom(ref input, _repeated_types_codec);
            break;
          }
          case 16: {
            IncompatibilityMode = (global::Google.Maps.RouteOptimization.V1.ShipmentTypeIncompatibility.Types.IncompatibilityMode) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ShipmentTypeIncompatibility message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Modes defining how the appearance of incompatible shipments are restricted
      /// on the same route.
      /// </summary>
      public enum IncompatibilityMode {
        /// <summary>
        /// Unspecified incompatibility mode. This value should never be used.
        /// </summary>
        [pbr::OriginalName("INCOMPATIBILITY_MODE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// In this mode, two shipments with incompatible types can never share the
        /// same vehicle.
        /// </summary>
        [pbr::OriginalName("NOT_PERFORMED_BY_SAME_VEHICLE")] NotPerformedBySameVehicle = 1,
        /// <summary>
        /// For two shipments with incompatible types with the
        /// `NOT_IN_SAME_VEHICLE_SIMULTANEOUSLY` incompatibility mode:
        ///
        /// * If both are pickups only (no deliveries) or deliveries only (no
        ///   pickups), they cannot share the same vehicle at all.
        /// * If one of the shipments has a delivery and the other a pickup, the two
        ///   shipments can share the same vehicle iff the former shipment is
        ///   delivered before the latter is picked up.
        /// </summary>
        [pbr::OriginalName("NOT_IN_SAME_VEHICLE_SIMULTANEOUSLY")] NotInSameVehicleSimultaneously = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// Specifies requirements between shipments based on their shipment_type.
  /// The specifics of the requirement are defined by the requirement mode.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ShipmentTypeRequirement : pb::IMessage<ShipmentTypeRequirement>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ShipmentTypeRequirement> _parser = new pb::MessageParser<ShipmentTypeRequirement>(() => new ShipmentTypeRequirement());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ShipmentTypeRequirement> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ShipmentTypeRequirement() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ShipmentTypeRequirement(ShipmentTypeRequirement other) : this() {
      requiredShipmentTypeAlternatives_ = other.requiredShipmentTypeAlternatives_.Clone();
      dependentShipmentTypes_ = other.dependentShipmentTypes_.Clone();
      requirementMode_ = other.requirementMode_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ShipmentTypeRequirement Clone() {
      return new ShipmentTypeRequirement(this);
    }

    /// <summary>Field number for the "required_shipment_type_alternatives" field.</summary>
    public const int RequiredShipmentTypeAlternativesFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_requiredShipmentTypeAlternatives_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> requiredShipmentTypeAlternatives_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// List of alternative shipment types required by the
    /// `dependent_shipment_types`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> RequiredShipmentTypeAlternatives {
      get { return requiredShipmentTypeAlternatives_; }
    }

    /// <summary>Field number for the "dependent_shipment_types" field.</summary>
    public const int DependentShipmentTypesFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_dependentShipmentTypes_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> dependentShipmentTypes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// All shipments with a type in the `dependent_shipment_types` field require
    /// at least one shipment of type `required_shipment_type_alternatives` to be
    /// visited on the same route.
    ///
    /// NOTE: Chains of requirements such that a `shipment_type` depends on itself
    /// are not allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> DependentShipmentTypes {
      get { return dependentShipmentTypes_; }
    }

    /// <summary>Field number for the "requirement_mode" field.</summary>
    public const int RequirementModeFieldNumber = 3;
    private global::Google.Maps.RouteOptimization.V1.ShipmentTypeRequirement.Types.RequirementMode requirementMode_ = global::Google.Maps.RouteOptimization.V1.ShipmentTypeRequirement.Types.RequirementMode.Unspecified;
    /// <summary>
    /// Mode applied to the requirement.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.ShipmentTypeRequirement.Types.RequirementMode RequirementMode {
      get { return requirementMode_; }
      set {
        requirementMode_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ShipmentTypeRequirement);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ShipmentTypeRequirement other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!requiredShipmentTypeAlternatives_.Equals(other.requiredShipmentTypeAlternatives_)) return false;
      if(!dependentShipmentTypes_.Equals(other.dependentShipmentTypes_)) return false;
      if (RequirementMode != other.RequirementMode) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= requiredShipmentTypeAlternatives_.GetHashCode();
      hash ^= dependentShipmentTypes_.GetHashCode();
      if (RequirementMode != global::Google.Maps.RouteOptimization.V1.ShipmentTypeRequirement.Types.RequirementMode.Unspecified) hash ^= RequirementMode.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      requiredShipmentTypeAlternatives_.WriteTo(output, _repeated_requiredShipmentTypeAlternatives_codec);
      dependentShipmentTypes_.WriteTo(output, _repeated_dependentShipmentTypes_codec);
      if (RequirementMode != global::Google.Maps.RouteOptimization.V1.ShipmentTypeRequirement.Types.RequirementMode.Unspecified) {
        output.WriteRawTag(24);
        output.WriteEnum((int) RequirementMode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      requiredShipmentTypeAlternatives_.WriteTo(ref output, _repeated_requiredShipmentTypeAlternatives_codec);
      dependentShipmentTypes_.WriteTo(ref output, _repeated_dependentShipmentTypes_codec);
      if (RequirementMode != global::Google.Maps.RouteOptimization.V1.ShipmentTypeRequirement.Types.RequirementMode.Unspecified) {
        output.WriteRawTag(24);
        output.WriteEnum((int) RequirementMode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += requiredShipmentTypeAlternatives_.CalculateSize(_repeated_requiredShipmentTypeAlternatives_codec);
      size += dependentShipmentTypes_.CalculateSize(_repeated_dependentShipmentTypes_codec);
      if (RequirementMode != global::Google.Maps.RouteOptimization.V1.ShipmentTypeRequirement.Types.RequirementMode.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RequirementMode);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ShipmentTypeRequirement other) {
      if (other == null) {
        return;
      }
      requiredShipmentTypeAlternatives_.Add(other.requiredShipmentTypeAlternatives_);
      dependentShipmentTypes_.Add(other.dependentShipmentTypes_);
      if (other.RequirementMode != global::Google.Maps.RouteOptimization.V1.ShipmentTypeRequirement.Types.RequirementMode.Unspecified) {
        RequirementMode = other.RequirementMode;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            requiredShipmentTypeAlternatives_.AddEntriesFrom(input, _repeated_requiredShipmentTypeAlternatives_codec);
            break;
          }
          case 18: {
            dependentShipmentTypes_.AddEntriesFrom(input, _repeated_dependentShipmentTypes_codec);
            break;
          }
          case 24: {
            RequirementMode = (global::Google.Maps.RouteOptimization.V1.ShipmentTypeRequirement.Types.RequirementMode) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            requiredShipmentTypeAlternatives_.AddEntriesFrom(ref input, _repeated_requiredShipmentTypeAlternatives_codec);
            break;
          }
          case 18: {
            dependentShipmentTypes_.AddEntriesFrom(ref input, _repeated_dependentShipmentTypes_codec);
            break;
          }
          case 24: {
            RequirementMode = (global::Google.Maps.RouteOptimization.V1.ShipmentTypeRequirement.Types.RequirementMode) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ShipmentTypeRequirement message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Modes defining the appearance of dependent shipments on a route.
      /// </summary>
      public enum RequirementMode {
        /// <summary>
        /// Unspecified requirement mode. This value should never be used.
        /// </summary>
        [pbr::OriginalName("REQUIREMENT_MODE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// In this mode, all "dependent" shipments must share the same vehicle as at
        /// least one of their "required" shipments.
        /// </summary>
        [pbr::OriginalName("PERFORMED_BY_SAME_VEHICLE")] PerformedBySameVehicle = 1,
        /// <summary>
        /// With the `IN_SAME_VEHICLE_AT_PICKUP_TIME` mode, all "dependent"
        /// shipments need to have at least one "required" shipment on their vehicle
        /// at the time of their pickup.
        ///
        /// A "dependent" shipment pickup must therefore have either:
        ///
        /// * A delivery-only "required" shipment delivered on the route after, or
        /// * A "required" shipment picked up on the route before it, and if the
        ///   "required" shipment has a delivery, this delivery must be performed
        ///   after the "dependent" shipment's pickup.
        /// </summary>
        [pbr::OriginalName("IN_SAME_VEHICLE_AT_PICKUP_TIME")] InSameVehicleAtPickupTime = 2,
        /// <summary>
        /// Same as before, except the "dependent" shipments need to have a
        /// "required" shipment on their vehicle at the time of their *delivery*.
        /// </summary>
        [pbr::OriginalName("IN_SAME_VEHICLE_AT_DELIVERY_TIME")] InSameVehicleAtDeliveryTime = 3,
      }

    }
    #endregion

  }

  /// <summary>
  /// Encapsulates a set of optional conditions to satisfy when calculating
  /// vehicle routes. This is similar to `RouteModifiers` in the Google Maps
  /// Platform Routes Preferred API; see:
  /// https://developers.google.com/maps/documentation/routes/reference/rest/v2/RouteModifiers.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class RouteModifiers : pb::IMessage<RouteModifiers>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RouteModifiers> _parser = new pb::MessageParser<RouteModifiers>(() => new RouteModifiers());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RouteModifiers> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RouteModifiers() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RouteModifiers(RouteModifiers other) : this() {
      avoidTolls_ = other.avoidTolls_;
      avoidHighways_ = other.avoidHighways_;
      avoidFerries_ = other.avoidFerries_;
      avoidIndoor_ = other.avoidIndoor_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RouteModifiers Clone() {
      return new RouteModifiers(this);
    }

    /// <summary>Field number for the "avoid_tolls" field.</summary>
    public const int AvoidTollsFieldNumber = 2;
    private bool avoidTolls_;
    /// <summary>
    /// Specifies whether to avoid toll roads where reasonable. Preference will be
    /// given to routes not containing toll roads. Applies only to motorized travel
    /// modes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AvoidTolls {
      get { return avoidTolls_; }
      set {
        avoidTolls_ = value;
      }
    }

    /// <summary>Field number for the "avoid_highways" field.</summary>
    public const int AvoidHighwaysFieldNumber = 3;
    private bool avoidHighways_;
    /// <summary>
    /// Specifies whether to avoid highways where reasonable. Preference will be
    /// given to routes not containing highways. Applies only to motorized travel
    /// modes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AvoidHighways {
      get { return avoidHighways_; }
      set {
        avoidHighways_ = value;
      }
    }

    /// <summary>Field number for the "avoid_ferries" field.</summary>
    public const int AvoidFerriesFieldNumber = 4;
    private bool avoidFerries_;
    /// <summary>
    /// Specifies whether to avoid ferries where reasonable. Preference will be
    /// given to routes not containing travel by ferries. Applies only to motorized
    /// travel modes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AvoidFerries {
      get { return avoidFerries_; }
      set {
        avoidFerries_ = value;
      }
    }

    /// <summary>Field number for the "avoid_indoor" field.</summary>
    public const int AvoidIndoorFieldNumber = 5;
    private bool avoidIndoor_;
    /// <summary>
    /// Optional. Specifies whether to avoid navigating indoors where reasonable.
    /// Preference will be given to routes not containing indoor navigation.
    /// Applies only to the `WALKING` travel mode.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AvoidIndoor {
      get { return avoidIndoor_; }
      set {
        avoidIndoor_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RouteModifiers);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RouteModifiers other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AvoidTolls != other.AvoidTolls) return false;
      if (AvoidHighways != other.AvoidHighways) return false;
      if (AvoidFerries != other.AvoidFerries) return false;
      if (AvoidIndoor != other.AvoidIndoor) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (AvoidTolls != false) hash ^= AvoidTolls.GetHashCode();
      if (AvoidHighways != false) hash ^= AvoidHighways.GetHashCode();
      if (AvoidFerries != false) hash ^= AvoidFerries.GetHashCode();
      if (AvoidIndoor != false) hash ^= AvoidIndoor.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (AvoidTolls != false) {
        output.WriteRawTag(16);
        output.WriteBool(AvoidTolls);
      }
      if (AvoidHighways != false) {
        output.WriteRawTag(24);
        output.WriteBool(AvoidHighways);
      }
      if (AvoidFerries != false) {
        output.WriteRawTag(32);
        output.WriteBool(AvoidFerries);
      }
      if (AvoidIndoor != false) {
        output.WriteRawTag(40);
        output.WriteBool(AvoidIndoor);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (AvoidTolls != false) {
        output.WriteRawTag(16);
        output.WriteBool(AvoidTolls);
      }
      if (AvoidHighways != false) {
        output.WriteRawTag(24);
        output.WriteBool(AvoidHighways);
      }
      if (AvoidFerries != false) {
        output.WriteRawTag(32);
        output.WriteBool(AvoidFerries);
      }
      if (AvoidIndoor != false) {
        output.WriteRawTag(40);
        output.WriteBool(AvoidIndoor);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (AvoidTolls != false) {
        size += 1 + 1;
      }
      if (AvoidHighways != false) {
        size += 1 + 1;
      }
      if (AvoidFerries != false) {
        size += 1 + 1;
      }
      if (AvoidIndoor != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RouteModifiers other) {
      if (other == null) {
        return;
      }
      if (other.AvoidTolls != false) {
        AvoidTolls = other.AvoidTolls;
      }
      if (other.AvoidHighways != false) {
        AvoidHighways = other.AvoidHighways;
      }
      if (other.AvoidFerries != false) {
        AvoidFerries = other.AvoidFerries;
      }
      if (other.AvoidIndoor != false) {
        AvoidIndoor = other.AvoidIndoor;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 16: {
            AvoidTolls = input.ReadBool();
            break;
          }
          case 24: {
            AvoidHighways = input.ReadBool();
            break;
          }
          case 32: {
            AvoidFerries = input.ReadBool();
            break;
          }
          case 40: {
            AvoidIndoor = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 16: {
            AvoidTolls = input.ReadBool();
            break;
          }
          case 24: {
            AvoidHighways = input.ReadBool();
            break;
          }
          case 32: {
            AvoidFerries = input.ReadBool();
            break;
          }
          case 40: {
            AvoidIndoor = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Models a vehicle in a shipment problem. Solving a shipment problem will
  /// build a route starting from `start_location` and ending at `end_location`
  /// for this vehicle. A route is a sequence of visits (see `ShipmentRoute`).
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Vehicle : pb::IMessage<Vehicle>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Vehicle> _parser = new pb::MessageParser<Vehicle>(() => new Vehicle());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Vehicle> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Vehicle() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Vehicle(Vehicle other) : this() {
      _hasBits0 = other._hasBits0;
      displayName_ = other.displayName_;
      travelMode_ = other.travelMode_;
      routeModifiers_ = other.routeModifiers_ != null ? other.routeModifiers_.Clone() : null;
      startLocation_ = other.startLocation_ != null ? other.startLocation_.Clone() : null;
      startWaypoint_ = other.startWaypoint_ != null ? other.startWaypoint_.Clone() : null;
      endLocation_ = other.endLocation_ != null ? other.endLocation_.Clone() : null;
      endWaypoint_ = other.endWaypoint_ != null ? other.endWaypoint_.Clone() : null;
      startTags_ = other.startTags_.Clone();
      endTags_ = other.endTags_.Clone();
      startTimeWindows_ = other.startTimeWindows_.Clone();
      endTimeWindows_ = other.endTimeWindows_.Clone();
      travelDurationMultiple_ = other.travelDurationMultiple_;
      unloadingPolicy_ = other.unloadingPolicy_;
      loadLimits_ = other.loadLimits_.Clone();
      costPerHour_ = other.costPerHour_;
      costPerTraveledHour_ = other.costPerTraveledHour_;
      costPerKilometer_ = other.costPerKilometer_;
      fixedCost_ = other.fixedCost_;
      usedIfRouteIsEmpty_ = other.usedIfRouteIsEmpty_;
      routeDurationLimit_ = other.routeDurationLimit_ != null ? other.routeDurationLimit_.Clone() : null;
      travelDurationLimit_ = other.travelDurationLimit_ != null ? other.travelDurationLimit_.Clone() : null;
      routeDistanceLimit_ = other.routeDistanceLimit_ != null ? other.routeDistanceLimit_.Clone() : null;
      extraVisitDurationForVisitType_ = other.extraVisitDurationForVisitType_.Clone();
      breakRule_ = other.breakRule_ != null ? other.breakRule_.Clone() : null;
      label_ = other.label_;
      ignore_ = other.ignore_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Vehicle Clone() {
      return new Vehicle(this);
    }

    /// <summary>Field number for the "display_name" field.</summary>
    public const int DisplayNameFieldNumber = 32;
    private string displayName_ = "";
    /// <summary>
    /// The user-defined display name of the vehicle.
    /// It can be up to 63 characters long and may use UTF-8 characters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DisplayName {
      get { return displayName_; }
      set {
        displayName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "travel_mode" field.</summary>
    public const int TravelModeFieldNumber = 1;
    private global::Google.Maps.RouteOptimization.V1.Vehicle.Types.TravelMode travelMode_ = global::Google.Maps.RouteOptimization.V1.Vehicle.Types.TravelMode.Unspecified;
    /// <summary>
    /// The travel mode which affects the roads usable by the vehicle and its
    /// speed. See also `travel_duration_multiple`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.Vehicle.Types.TravelMode TravelMode {
      get { return travelMode_; }
      set {
        travelMode_ = value;
      }
    }

    /// <summary>Field number for the "route_modifiers" field.</summary>
    public const int RouteModifiersFieldNumber = 2;
    private global::Google.Maps.RouteOptimization.V1.RouteModifiers routeModifiers_;
    /// <summary>
    /// A set of conditions to satisfy that affect the way routes are calculated
    /// for the given vehicle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.RouteModifiers RouteModifiers {
      get { return routeModifiers_; }
      set {
        routeModifiers_ = value;
      }
    }

    /// <summary>Field number for the "start_location" field.</summary>
    public const int StartLocationFieldNumber = 3;
    private global::Google.Type.LatLng startLocation_;
    /// <summary>
    /// Geographic location where the vehicle starts before picking up any
    /// shipments. If not specified, the vehicle starts at its first pickup.
    /// If the shipment model has duration and distance matrices, `start_location`
    /// must not be specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Type.LatLng StartLocation {
      get { return startLocation_; }
      set {
        startLocation_ = value;
      }
    }

    /// <summary>Field number for the "start_waypoint" field.</summary>
    public const int StartWaypointFieldNumber = 4;
    private global::Google.Maps.RouteOptimization.V1.Waypoint startWaypoint_;
    /// <summary>
    /// Waypoint representing a geographic location where the vehicle starts before
    /// picking up any shipments. If neither `start_waypoint` nor `start_location`
    /// is specified, the vehicle starts at its first pickup.
    /// If the shipment model has duration and distance matrices, `start_waypoint`
    /// must not be specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.Waypoint StartWaypoint {
      get { return startWaypoint_; }
      set {
        startWaypoint_ = value;
      }
    }

    /// <summary>Field number for the "end_location" field.</summary>
    public const int EndLocationFieldNumber = 5;
    private global::Google.Type.LatLng endLocation_;
    /// <summary>
    /// Geographic location where the vehicle ends after it has completed its last
    /// `VisitRequest`. If not specified the vehicle's `ShipmentRoute` ends
    /// immediately when it completes its last `VisitRequest`.
    /// If the shipment model has duration and distance matrices, `end_location`
    /// must not be specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Type.LatLng EndLocation {
      get { return endLocation_; }
      set {
        endLocation_ = value;
      }
    }

    /// <summary>Field number for the "end_waypoint" field.</summary>
    public const int EndWaypointFieldNumber = 6;
    private global::Google.Maps.RouteOptimization.V1.Waypoint endWaypoint_;
    /// <summary>
    /// Waypoint representing a geographic location where the vehicle ends after
    /// it has completed its last `VisitRequest`. If neither `end_waypoint` nor
    /// `end_location` is specified, the vehicle's `ShipmentRoute` ends immediately
    /// when it completes its last `VisitRequest`.
    /// If the shipment model has duration and distance matrices, `end_waypoint`
    /// must not be specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.Waypoint EndWaypoint {
      get { return endWaypoint_; }
      set {
        endWaypoint_ = value;
      }
    }

    /// <summary>Field number for the "start_tags" field.</summary>
    public const int StartTagsFieldNumber = 7;
    private static readonly pb::FieldCodec<string> _repeated_startTags_codec
        = pb::FieldCodec.ForString(58);
    private readonly pbc::RepeatedField<string> startTags_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Specifies tags attached to the start of the vehicle's route.
    ///
    /// Empty or duplicate strings are not allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> StartTags {
      get { return startTags_; }
    }

    /// <summary>Field number for the "end_tags" field.</summary>
    public const int EndTagsFieldNumber = 8;
    private static readonly pb::FieldCodec<string> _repeated_endTags_codec
        = pb::FieldCodec.ForString(66);
    private readonly pbc::RepeatedField<string> endTags_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Specifies tags attached to the end of the vehicle's route.
    ///
    /// Empty or duplicate strings are not allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> EndTags {
      get { return endTags_; }
    }

    /// <summary>Field number for the "start_time_windows" field.</summary>
    public const int StartTimeWindowsFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.TimeWindow> _repeated_startTimeWindows_codec
        = pb::FieldCodec.ForMessage(74, global::Google.Maps.RouteOptimization.V1.TimeWindow.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.TimeWindow> startTimeWindows_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.TimeWindow>();
    /// <summary>
    /// Time windows during which the vehicle may depart its start location.
    /// They must be within the global time limits (see
    /// [ShipmentModel.global_*][google.maps.routeoptimization.v1.ShipmentModel.global_start_time]
    /// fields). If unspecified, there is no limitation besides those global time
    /// limits.
    ///
    /// Time windows belonging to the same repeated field must be disjoint, i.e. no
    /// time window can overlap with or be adjacent to another, and they must be in
    /// chronological order.
    ///
    /// `cost_per_hour_after_soft_end_time` and `soft_end_time` can only be set if
    /// there is a single time window.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.TimeWindow> StartTimeWindows {
      get { return startTimeWindows_; }
    }

    /// <summary>Field number for the "end_time_windows" field.</summary>
    public const int EndTimeWindowsFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.TimeWindow> _repeated_endTimeWindows_codec
        = pb::FieldCodec.ForMessage(82, global::Google.Maps.RouteOptimization.V1.TimeWindow.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.TimeWindow> endTimeWindows_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.TimeWindow>();
    /// <summary>
    /// Time windows during which the vehicle may arrive at its end location.
    /// They must be within the global time limits (see
    /// [ShipmentModel.global_*][google.maps.routeoptimization.v1.ShipmentModel.global_start_time]
    /// fields). If unspecified, there is no limitation besides those global time
    /// limits.
    ///
    /// Time windows belonging to the same repeated field must be disjoint, i.e. no
    /// time window can overlap with or be adjacent to another, and they must be in
    /// chronological order.
    ///
    /// `cost_per_hour_after_soft_end_time` and `soft_end_time` can only be set if
    /// there is a single time window.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.TimeWindow> EndTimeWindows {
      get { return endTimeWindows_; }
    }

    /// <summary>Field number for the "travel_duration_multiple" field.</summary>
    public const int TravelDurationMultipleFieldNumber = 11;
    private readonly static double TravelDurationMultipleDefaultValue = 0D;

    private double travelDurationMultiple_;
    /// <summary>
    /// Specifies a multiplicative factor that can be used to increase or decrease
    /// travel times of this vehicle. For example, setting this to 2.0 means
    /// that this vehicle is slower and has travel times that are twice what they
    /// are for standard vehicles. This multiple does not affect visit durations.
    /// It does affect cost if `cost_per_hour` or `cost_per_traveled_hour` are
    /// specified. This must be in the range [0.001, 1000.0]. If unset, the vehicle
    /// is standard, and this multiple is considered 1.0.
    ///
    /// WARNING: Travel times will be rounded to the nearest second after this
    /// multiple is applied but before performing any numerical operations, thus,
    /// a small multiple may result in a loss of precision.
    ///
    /// See also `extra_visit_duration_for_visit_type` below.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double TravelDurationMultiple {
      get { if ((_hasBits0 & 1) != 0) { return travelDurationMultiple_; } else { return TravelDurationMultipleDefaultValue; } }
      set {
        _hasBits0 |= 1;
        travelDurationMultiple_ = value;
      }
    }
    /// <summary>Gets whether the "travel_duration_multiple" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTravelDurationMultiple {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "travel_duration_multiple" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTravelDurationMultiple() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "unloading_policy" field.</summary>
    public const int UnloadingPolicyFieldNumber = 12;
    private global::Google.Maps.RouteOptimization.V1.Vehicle.Types.UnloadingPolicy unloadingPolicy_ = global::Google.Maps.RouteOptimization.V1.Vehicle.Types.UnloadingPolicy.Unspecified;
    /// <summary>
    /// Unloading policy enforced on the vehicle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.Vehicle.Types.UnloadingPolicy UnloadingPolicy {
      get { return unloadingPolicy_; }
      set {
        unloadingPolicy_ = value;
      }
    }

    /// <summary>Field number for the "load_limits" field.</summary>
    public const int LoadLimitsFieldNumber = 30;
    private static readonly pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.Vehicle.Types.LoadLimit>.Codec _map_loadLimits_codec
        = new pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.Vehicle.Types.LoadLimit>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Google.Maps.RouteOptimization.V1.Vehicle.Types.LoadLimit.Parser), 242);
    private readonly pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.Vehicle.Types.LoadLimit> loadLimits_ = new pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.Vehicle.Types.LoadLimit>();
    /// <summary>
    /// Capacities of the vehicle (weight, volume, # of pallets for example).
    /// The keys in the map are the identifiers of the type of load, consistent
    /// with the keys of the
    /// [Shipment.load_demands][google.maps.routeoptimization.v1.Shipment.load_demands]
    /// field. If a given key is absent from this map, the corresponding capacity
    /// is considered to be limitless.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.Vehicle.Types.LoadLimit> LoadLimits {
      get { return loadLimits_; }
    }

    /// <summary>Field number for the "cost_per_hour" field.</summary>
    public const int CostPerHourFieldNumber = 16;
    private double costPerHour_;
    /// <summary>
    /// Vehicle costs: all costs add up and must be in the same unit as
    /// [Shipment.penalty_cost][google.maps.routeoptimization.v1.Shipment.penalty_cost].
    ///
    /// Cost per hour of the vehicle route. This cost is applied to the total time
    /// taken by the route, and includes travel time, waiting time, and visit time.
    /// Using `cost_per_hour` instead of just `cost_per_traveled_hour` may result
    /// in additional latency.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double CostPerHour {
      get { return costPerHour_; }
      set {
        costPerHour_ = value;
      }
    }

    /// <summary>Field number for the "cost_per_traveled_hour" field.</summary>
    public const int CostPerTraveledHourFieldNumber = 17;
    private double costPerTraveledHour_;
    /// <summary>
    /// Cost per traveled hour of the vehicle route. This cost is applied only to
    /// travel time taken by the route (i.e., that reported in
    /// [ShipmentRoute.transitions][google.maps.routeoptimization.v1.ShipmentRoute.transitions]),
    /// and excludes waiting time and visit time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double CostPerTraveledHour {
      get { return costPerTraveledHour_; }
      set {
        costPerTraveledHour_ = value;
      }
    }

    /// <summary>Field number for the "cost_per_kilometer" field.</summary>
    public const int CostPerKilometerFieldNumber = 18;
    private double costPerKilometer_;
    /// <summary>
    /// Cost per kilometer of the vehicle route. This cost is applied to the
    /// distance reported in the
    /// [ShipmentRoute.transitions][google.maps.routeoptimization.v1.ShipmentRoute.transitions]
    /// and does not apply to any distance implicitly traveled from the
    /// `arrival_location` to the `departure_location` of a single `VisitRequest`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double CostPerKilometer {
      get { return costPerKilometer_; }
      set {
        costPerKilometer_ = value;
      }
    }

    /// <summary>Field number for the "fixed_cost" field.</summary>
    public const int FixedCostFieldNumber = 19;
    private double fixedCost_;
    /// <summary>
    /// Fixed cost applied if this vehicle is used to handle a shipment.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double FixedCost {
      get { return fixedCost_; }
      set {
        fixedCost_ = value;
      }
    }

    /// <summary>Field number for the "used_if_route_is_empty" field.</summary>
    public const int UsedIfRouteIsEmptyFieldNumber = 20;
    private bool usedIfRouteIsEmpty_;
    /// <summary>
    /// This field only applies to vehicles when their route does not serve any
    /// shipments. It indicates if the vehicle should be considered as used or not
    /// in this case.
    ///
    /// If true, the vehicle goes from its start to its end location even if it
    /// doesn't serve any shipments, and time and distance costs resulting from its
    /// start --> end travel are taken into account.
    ///
    /// Otherwise, it doesn't travel from its start to its end location, and no
    /// `break_rule` or delay (from `TransitionAttributes`) are scheduled for this
    /// vehicle. In this case, the vehicle's `ShipmentRoute` doesn't contain any
    /// information except for the vehicle index and label.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool UsedIfRouteIsEmpty {
      get { return usedIfRouteIsEmpty_; }
      set {
        usedIfRouteIsEmpty_ = value;
      }
    }

    /// <summary>Field number for the "route_duration_limit" field.</summary>
    public const int RouteDurationLimitFieldNumber = 21;
    private global::Google.Maps.RouteOptimization.V1.Vehicle.Types.DurationLimit routeDurationLimit_;
    /// <summary>
    /// Limit applied to the total duration of the vehicle's route. In a given
    /// `OptimizeToursResponse`, the route duration of a vehicle is the
    /// difference between its `vehicle_end_time` and `vehicle_start_time`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.Vehicle.Types.DurationLimit RouteDurationLimit {
      get { return routeDurationLimit_; }
      set {
        routeDurationLimit_ = value;
      }
    }

    /// <summary>Field number for the "travel_duration_limit" field.</summary>
    public const int TravelDurationLimitFieldNumber = 22;
    private global::Google.Maps.RouteOptimization.V1.Vehicle.Types.DurationLimit travelDurationLimit_;
    /// <summary>
    /// Limit applied to the travel duration of the vehicle's route. In a given
    /// `OptimizeToursResponse`, the route travel duration is the sum of all its
    /// [transitions.travel_duration][google.maps.routeoptimization.v1.ShipmentRoute.Transition.travel_duration].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.Vehicle.Types.DurationLimit TravelDurationLimit {
      get { return travelDurationLimit_; }
      set {
        travelDurationLimit_ = value;
      }
    }

    /// <summary>Field number for the "route_distance_limit" field.</summary>
    public const int RouteDistanceLimitFieldNumber = 23;
    private global::Google.Maps.RouteOptimization.V1.DistanceLimit routeDistanceLimit_;
    /// <summary>
    /// Limit applied to the total distance of the vehicle's route. In a given
    /// `OptimizeToursResponse`, the route distance is the sum of all its
    /// [transitions.travel_distance_meters][google.maps.routeoptimization.v1.ShipmentRoute.Transition.travel_distance_meters].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.DistanceLimit RouteDistanceLimit {
      get { return routeDistanceLimit_; }
      set {
        routeDistanceLimit_ = value;
      }
    }

    /// <summary>Field number for the "extra_visit_duration_for_visit_type" field.</summary>
    public const int ExtraVisitDurationForVisitTypeFieldNumber = 24;
    private static readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Duration>.Codec _map_extraVisitDurationForVisitType_codec
        = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Duration>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Google.Protobuf.WellKnownTypes.Duration.Parser), 194);
    private readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Duration> extraVisitDurationForVisitType_ = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Duration>();
    /// <summary>
    /// Specifies a map from visit_types strings to durations. The duration is time
    /// in addition to
    /// [VisitRequest.duration][google.maps.routeoptimization.v1.Shipment.VisitRequest.duration]
    /// to be taken at visits with the specified `visit_types`. This extra visit
    /// duration adds cost if `cost_per_hour` is specified. Keys (i.e.
    /// `visit_types`) cannot be empty strings.
    ///
    /// If a visit request has multiple types, a duration will be added for each
    /// type in the map.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Duration> ExtraVisitDurationForVisitType {
      get { return extraVisitDurationForVisitType_; }
    }

    /// <summary>Field number for the "break_rule" field.</summary>
    public const int BreakRuleFieldNumber = 25;
    private global::Google.Maps.RouteOptimization.V1.BreakRule breakRule_;
    /// <summary>
    /// Describes the break schedule to be enforced on this vehicle.
    /// If empty, no breaks will be scheduled for this vehicle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.BreakRule BreakRule {
      get { return breakRule_; }
      set {
        breakRule_ = value;
      }
    }

    /// <summary>Field number for the "label" field.</summary>
    public const int LabelFieldNumber = 27;
    private string label_ = "";
    /// <summary>
    /// Specifies a label for this vehicle. This label is reported in the response
    /// as the `vehicle_label` of the corresponding
    /// [ShipmentRoute][google.maps.routeoptimization.v1.ShipmentRoute].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Label {
      get { return label_; }
      set {
        label_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "ignore" field.</summary>
    public const int IgnoreFieldNumber = 28;
    private bool ignore_;
    /// <summary>
    /// If true, `used_if_route_is_empty` must be false, and this vehicle will
    /// remain unused.
    ///
    /// If a shipment is performed by an ignored vehicle in
    /// `injected_first_solution_routes`, it is skipped in the first solution but
    /// is free to be performed in the response.
    ///
    /// If a shipment is performed by an ignored vehicle in
    /// `injected_solution_constraint` and any related pickup/delivery is
    /// constrained to remain on the vehicle (i.e., not relaxed to level
    /// `RELAX_ALL_AFTER_THRESHOLD`), it is skipped in the response.
    /// If a shipment has a non-empty `allowed_vehicle_indices` field and all of
    /// the allowed vehicles are ignored, it is skipped in the response.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Ignore {
      get { return ignore_; }
      set {
        ignore_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Vehicle);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Vehicle other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (DisplayName != other.DisplayName) return false;
      if (TravelMode != other.TravelMode) return false;
      if (!object.Equals(RouteModifiers, other.RouteModifiers)) return false;
      if (!object.Equals(StartLocation, other.StartLocation)) return false;
      if (!object.Equals(StartWaypoint, other.StartWaypoint)) return false;
      if (!object.Equals(EndLocation, other.EndLocation)) return false;
      if (!object.Equals(EndWaypoint, other.EndWaypoint)) return false;
      if(!startTags_.Equals(other.startTags_)) return false;
      if(!endTags_.Equals(other.endTags_)) return false;
      if(!startTimeWindows_.Equals(other.startTimeWindows_)) return false;
      if(!endTimeWindows_.Equals(other.endTimeWindows_)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(TravelDurationMultiple, other.TravelDurationMultiple)) return false;
      if (UnloadingPolicy != other.UnloadingPolicy) return false;
      if (!LoadLimits.Equals(other.LoadLimits)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(CostPerHour, other.CostPerHour)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(CostPerTraveledHour, other.CostPerTraveledHour)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(CostPerKilometer, other.CostPerKilometer)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(FixedCost, other.FixedCost)) return false;
      if (UsedIfRouteIsEmpty != other.UsedIfRouteIsEmpty) return false;
      if (!object.Equals(RouteDurationLimit, other.RouteDurationLimit)) return false;
      if (!object.Equals(TravelDurationLimit, other.TravelDurationLimit)) return false;
      if (!object.Equals(RouteDistanceLimit, other.RouteDistanceLimit)) return false;
      if (!ExtraVisitDurationForVisitType.Equals(other.ExtraVisitDurationForVisitType)) return false;
      if (!object.Equals(BreakRule, other.BreakRule)) return false;
      if (Label != other.Label) return false;
      if (Ignore != other.Ignore) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (DisplayName.Length != 0) hash ^= DisplayName.GetHashCode();
      if (TravelMode != global::Google.Maps.RouteOptimization.V1.Vehicle.Types.TravelMode.Unspecified) hash ^= TravelMode.GetHashCode();
      if (routeModifiers_ != null) hash ^= RouteModifiers.GetHashCode();
      if (startLocation_ != null) hash ^= StartLocation.GetHashCode();
      if (startWaypoint_ != null) hash ^= StartWaypoint.GetHashCode();
      if (endLocation_ != null) hash ^= EndLocation.GetHashCode();
      if (endWaypoint_ != null) hash ^= EndWaypoint.GetHashCode();
      hash ^= startTags_.GetHashCode();
      hash ^= endTags_.GetHashCode();
      hash ^= startTimeWindows_.GetHashCode();
      hash ^= endTimeWindows_.GetHashCode();
      if (HasTravelDurationMultiple) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(TravelDurationMultiple);
      if (UnloadingPolicy != global::Google.Maps.RouteOptimization.V1.Vehicle.Types.UnloadingPolicy.Unspecified) hash ^= UnloadingPolicy.GetHashCode();
      hash ^= LoadLimits.GetHashCode();
      if (CostPerHour != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(CostPerHour);
      if (CostPerTraveledHour != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(CostPerTraveledHour);
      if (CostPerKilometer != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(CostPerKilometer);
      if (FixedCost != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(FixedCost);
      if (UsedIfRouteIsEmpty != false) hash ^= UsedIfRouteIsEmpty.GetHashCode();
      if (routeDurationLimit_ != null) hash ^= RouteDurationLimit.GetHashCode();
      if (travelDurationLimit_ != null) hash ^= TravelDurationLimit.GetHashCode();
      if (routeDistanceLimit_ != null) hash ^= RouteDistanceLimit.GetHashCode();
      hash ^= ExtraVisitDurationForVisitType.GetHashCode();
      if (breakRule_ != null) hash ^= BreakRule.GetHashCode();
      if (Label.Length != 0) hash ^= Label.GetHashCode();
      if (Ignore != false) hash ^= Ignore.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (TravelMode != global::Google.Maps.RouteOptimization.V1.Vehicle.Types.TravelMode.Unspecified) {
        output.WriteRawTag(8);
        output.WriteEnum((int) TravelMode);
      }
      if (routeModifiers_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(RouteModifiers);
      }
      if (startLocation_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(StartLocation);
      }
      if (startWaypoint_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(StartWaypoint);
      }
      if (endLocation_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(EndLocation);
      }
      if (endWaypoint_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(EndWaypoint);
      }
      startTags_.WriteTo(output, _repeated_startTags_codec);
      endTags_.WriteTo(output, _repeated_endTags_codec);
      startTimeWindows_.WriteTo(output, _repeated_startTimeWindows_codec);
      endTimeWindows_.WriteTo(output, _repeated_endTimeWindows_codec);
      if (HasTravelDurationMultiple) {
        output.WriteRawTag(89);
        output.WriteDouble(TravelDurationMultiple);
      }
      if (UnloadingPolicy != global::Google.Maps.RouteOptimization.V1.Vehicle.Types.UnloadingPolicy.Unspecified) {
        output.WriteRawTag(96);
        output.WriteEnum((int) UnloadingPolicy);
      }
      if (CostPerHour != 0D) {
        output.WriteRawTag(129, 1);
        output.WriteDouble(CostPerHour);
      }
      if (CostPerTraveledHour != 0D) {
        output.WriteRawTag(137, 1);
        output.WriteDouble(CostPerTraveledHour);
      }
      if (CostPerKilometer != 0D) {
        output.WriteRawTag(145, 1);
        output.WriteDouble(CostPerKilometer);
      }
      if (FixedCost != 0D) {
        output.WriteRawTag(153, 1);
        output.WriteDouble(FixedCost);
      }
      if (UsedIfRouteIsEmpty != false) {
        output.WriteRawTag(160, 1);
        output.WriteBool(UsedIfRouteIsEmpty);
      }
      if (routeDurationLimit_ != null) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(RouteDurationLimit);
      }
      if (travelDurationLimit_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(TravelDurationLimit);
      }
      if (routeDistanceLimit_ != null) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(RouteDistanceLimit);
      }
      extraVisitDurationForVisitType_.WriteTo(output, _map_extraVisitDurationForVisitType_codec);
      if (breakRule_ != null) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(BreakRule);
      }
      if (Label.Length != 0) {
        output.WriteRawTag(218, 1);
        output.WriteString(Label);
      }
      if (Ignore != false) {
        output.WriteRawTag(224, 1);
        output.WriteBool(Ignore);
      }
      loadLimits_.WriteTo(output, _map_loadLimits_codec);
      if (DisplayName.Length != 0) {
        output.WriteRawTag(130, 2);
        output.WriteString(DisplayName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (TravelMode != global::Google.Maps.RouteOptimization.V1.Vehicle.Types.TravelMode.Unspecified) {
        output.WriteRawTag(8);
        output.WriteEnum((int) TravelMode);
      }
      if (routeModifiers_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(RouteModifiers);
      }
      if (startLocation_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(StartLocation);
      }
      if (startWaypoint_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(StartWaypoint);
      }
      if (endLocation_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(EndLocation);
      }
      if (endWaypoint_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(EndWaypoint);
      }
      startTags_.WriteTo(ref output, _repeated_startTags_codec);
      endTags_.WriteTo(ref output, _repeated_endTags_codec);
      startTimeWindows_.WriteTo(ref output, _repeated_startTimeWindows_codec);
      endTimeWindows_.WriteTo(ref output, _repeated_endTimeWindows_codec);
      if (HasTravelDurationMultiple) {
        output.WriteRawTag(89);
        output.WriteDouble(TravelDurationMultiple);
      }
      if (UnloadingPolicy != global::Google.Maps.RouteOptimization.V1.Vehicle.Types.UnloadingPolicy.Unspecified) {
        output.WriteRawTag(96);
        output.WriteEnum((int) UnloadingPolicy);
      }
      if (CostPerHour != 0D) {
        output.WriteRawTag(129, 1);
        output.WriteDouble(CostPerHour);
      }
      if (CostPerTraveledHour != 0D) {
        output.WriteRawTag(137, 1);
        output.WriteDouble(CostPerTraveledHour);
      }
      if (CostPerKilometer != 0D) {
        output.WriteRawTag(145, 1);
        output.WriteDouble(CostPerKilometer);
      }
      if (FixedCost != 0D) {
        output.WriteRawTag(153, 1);
        output.WriteDouble(FixedCost);
      }
      if (UsedIfRouteIsEmpty != false) {
        output.WriteRawTag(160, 1);
        output.WriteBool(UsedIfRouteIsEmpty);
      }
      if (routeDurationLimit_ != null) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(RouteDurationLimit);
      }
      if (travelDurationLimit_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(TravelDurationLimit);
      }
      if (routeDistanceLimit_ != null) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(RouteDistanceLimit);
      }
      extraVisitDurationForVisitType_.WriteTo(ref output, _map_extraVisitDurationForVisitType_codec);
      if (breakRule_ != null) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(BreakRule);
      }
      if (Label.Length != 0) {
        output.WriteRawTag(218, 1);
        output.WriteString(Label);
      }
      if (Ignore != false) {
        output.WriteRawTag(224, 1);
        output.WriteBool(Ignore);
      }
      loadLimits_.WriteTo(ref output, _map_loadLimits_codec);
      if (DisplayName.Length != 0) {
        output.WriteRawTag(130, 2);
        output.WriteString(DisplayName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (DisplayName.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(DisplayName);
      }
      if (TravelMode != global::Google.Maps.RouteOptimization.V1.Vehicle.Types.TravelMode.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TravelMode);
      }
      if (routeModifiers_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RouteModifiers);
      }
      if (startLocation_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StartLocation);
      }
      if (startWaypoint_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StartWaypoint);
      }
      if (endLocation_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EndLocation);
      }
      if (endWaypoint_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EndWaypoint);
      }
      size += startTags_.CalculateSize(_repeated_startTags_codec);
      size += endTags_.CalculateSize(_repeated_endTags_codec);
      size += startTimeWindows_.CalculateSize(_repeated_startTimeWindows_codec);
      size += endTimeWindows_.CalculateSize(_repeated_endTimeWindows_codec);
      if (HasTravelDurationMultiple) {
        size += 1 + 8;
      }
      if (UnloadingPolicy != global::Google.Maps.RouteOptimization.V1.Vehicle.Types.UnloadingPolicy.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) UnloadingPolicy);
      }
      size += loadLimits_.CalculateSize(_map_loadLimits_codec);
      if (CostPerHour != 0D) {
        size += 2 + 8;
      }
      if (CostPerTraveledHour != 0D) {
        size += 2 + 8;
      }
      if (CostPerKilometer != 0D) {
        size += 2 + 8;
      }
      if (FixedCost != 0D) {
        size += 2 + 8;
      }
      if (UsedIfRouteIsEmpty != false) {
        size += 2 + 1;
      }
      if (routeDurationLimit_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RouteDurationLimit);
      }
      if (travelDurationLimit_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(TravelDurationLimit);
      }
      if (routeDistanceLimit_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RouteDistanceLimit);
      }
      size += extraVisitDurationForVisitType_.CalculateSize(_map_extraVisitDurationForVisitType_codec);
      if (breakRule_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(BreakRule);
      }
      if (Label.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Label);
      }
      if (Ignore != false) {
        size += 2 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Vehicle other) {
      if (other == null) {
        return;
      }
      if (other.DisplayName.Length != 0) {
        DisplayName = other.DisplayName;
      }
      if (other.TravelMode != global::Google.Maps.RouteOptimization.V1.Vehicle.Types.TravelMode.Unspecified) {
        TravelMode = other.TravelMode;
      }
      if (other.routeModifiers_ != null) {
        if (routeModifiers_ == null) {
          RouteModifiers = new global::Google.Maps.RouteOptimization.V1.RouteModifiers();
        }
        RouteModifiers.MergeFrom(other.RouteModifiers);
      }
      if (other.startLocation_ != null) {
        if (startLocation_ == null) {
          StartLocation = new global::Google.Type.LatLng();
        }
        StartLocation.MergeFrom(other.StartLocation);
      }
      if (other.startWaypoint_ != null) {
        if (startWaypoint_ == null) {
          StartWaypoint = new global::Google.Maps.RouteOptimization.V1.Waypoint();
        }
        StartWaypoint.MergeFrom(other.StartWaypoint);
      }
      if (other.endLocation_ != null) {
        if (endLocation_ == null) {
          EndLocation = new global::Google.Type.LatLng();
        }
        EndLocation.MergeFrom(other.EndLocation);
      }
      if (other.endWaypoint_ != null) {
        if (endWaypoint_ == null) {
          EndWaypoint = new global::Google.Maps.RouteOptimization.V1.Waypoint();
        }
        EndWaypoint.MergeFrom(other.EndWaypoint);
      }
      startTags_.Add(other.startTags_);
      endTags_.Add(other.endTags_);
      startTimeWindows_.Add(other.startTimeWindows_);
      endTimeWindows_.Add(other.endTimeWindows_);
      if (other.HasTravelDurationMultiple) {
        TravelDurationMultiple = other.TravelDurationMultiple;
      }
      if (other.UnloadingPolicy != global::Google.Maps.RouteOptimization.V1.Vehicle.Types.UnloadingPolicy.Unspecified) {
        UnloadingPolicy = other.UnloadingPolicy;
      }
      loadLimits_.MergeFrom(other.loadLimits_);
      if (other.CostPerHour != 0D) {
        CostPerHour = other.CostPerHour;
      }
      if (other.CostPerTraveledHour != 0D) {
        CostPerTraveledHour = other.CostPerTraveledHour;
      }
      if (other.CostPerKilometer != 0D) {
        CostPerKilometer = other.CostPerKilometer;
      }
      if (other.FixedCost != 0D) {
        FixedCost = other.FixedCost;
      }
      if (other.UsedIfRouteIsEmpty != false) {
        UsedIfRouteIsEmpty = other.UsedIfRouteIsEmpty;
      }
      if (other.routeDurationLimit_ != null) {
        if (routeDurationLimit_ == null) {
          RouteDurationLimit = new global::Google.Maps.RouteOptimization.V1.Vehicle.Types.DurationLimit();
        }
        RouteDurationLimit.MergeFrom(other.RouteDurationLimit);
      }
      if (other.travelDurationLimit_ != null) {
        if (travelDurationLimit_ == null) {
          TravelDurationLimit = new global::Google.Maps.RouteOptimization.V1.Vehicle.Types.DurationLimit();
        }
        TravelDurationLimit.MergeFrom(other.TravelDurationLimit);
      }
      if (other.routeDistanceLimit_ != null) {
        if (routeDistanceLimit_ == null) {
          RouteDistanceLimit = new global::Google.Maps.RouteOptimization.V1.DistanceLimit();
        }
        RouteDistanceLimit.MergeFrom(other.RouteDistanceLimit);
      }
      extraVisitDurationForVisitType_.MergeFrom(other.extraVisitDurationForVisitType_);
      if (other.breakRule_ != null) {
        if (breakRule_ == null) {
          BreakRule = new global::Google.Maps.RouteOptimization.V1.BreakRule();
        }
        BreakRule.MergeFrom(other.BreakRule);
      }
      if (other.Label.Length != 0) {
        Label = other.Label;
      }
      if (other.Ignore != false) {
        Ignore = other.Ignore;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            TravelMode = (global::Google.Maps.RouteOptimization.V1.Vehicle.Types.TravelMode) input.ReadEnum();
            break;
          }
          case 18: {
            if (routeModifiers_ == null) {
              RouteModifiers = new global::Google.Maps.RouteOptimization.V1.RouteModifiers();
            }
            input.ReadMessage(RouteModifiers);
            break;
          }
          case 26: {
            if (startLocation_ == null) {
              StartLocation = new global::Google.Type.LatLng();
            }
            input.ReadMessage(StartLocation);
            break;
          }
          case 34: {
            if (startWaypoint_ == null) {
              StartWaypoint = new global::Google.Maps.RouteOptimization.V1.Waypoint();
            }
            input.ReadMessage(StartWaypoint);
            break;
          }
          case 42: {
            if (endLocation_ == null) {
              EndLocation = new global::Google.Type.LatLng();
            }
            input.ReadMessage(EndLocation);
            break;
          }
          case 50: {
            if (endWaypoint_ == null) {
              EndWaypoint = new global::Google.Maps.RouteOptimization.V1.Waypoint();
            }
            input.ReadMessage(EndWaypoint);
            break;
          }
          case 58: {
            startTags_.AddEntriesFrom(input, _repeated_startTags_codec);
            break;
          }
          case 66: {
            endTags_.AddEntriesFrom(input, _repeated_endTags_codec);
            break;
          }
          case 74: {
            startTimeWindows_.AddEntriesFrom(input, _repeated_startTimeWindows_codec);
            break;
          }
          case 82: {
            endTimeWindows_.AddEntriesFrom(input, _repeated_endTimeWindows_codec);
            break;
          }
          case 89: {
            TravelDurationMultiple = input.ReadDouble();
            break;
          }
          case 96: {
            UnloadingPolicy = (global::Google.Maps.RouteOptimization.V1.Vehicle.Types.UnloadingPolicy) input.ReadEnum();
            break;
          }
          case 129: {
            CostPerHour = input.ReadDouble();
            break;
          }
          case 137: {
            CostPerTraveledHour = input.ReadDouble();
            break;
          }
          case 145: {
            CostPerKilometer = input.ReadDouble();
            break;
          }
          case 153: {
            FixedCost = input.ReadDouble();
            break;
          }
          case 160: {
            UsedIfRouteIsEmpty = input.ReadBool();
            break;
          }
          case 170: {
            if (routeDurationLimit_ == null) {
              RouteDurationLimit = new global::Google.Maps.RouteOptimization.V1.Vehicle.Types.DurationLimit();
            }
            input.ReadMessage(RouteDurationLimit);
            break;
          }
          case 178: {
            if (travelDurationLimit_ == null) {
              TravelDurationLimit = new global::Google.Maps.RouteOptimization.V1.Vehicle.Types.DurationLimit();
            }
            input.ReadMessage(TravelDurationLimit);
            break;
          }
          case 186: {
            if (routeDistanceLimit_ == null) {
              RouteDistanceLimit = new global::Google.Maps.RouteOptimization.V1.DistanceLimit();
            }
            input.ReadMessage(RouteDistanceLimit);
            break;
          }
          case 194: {
            extraVisitDurationForVisitType_.AddEntriesFrom(input, _map_extraVisitDurationForVisitType_codec);
            break;
          }
          case 202: {
            if (breakRule_ == null) {
              BreakRule = new global::Google.Maps.RouteOptimization.V1.BreakRule();
            }
            input.ReadMessage(BreakRule);
            break;
          }
          case 218: {
            Label = input.ReadString();
            break;
          }
          case 224: {
            Ignore = input.ReadBool();
            break;
          }
          case 242: {
            loadLimits_.AddEntriesFrom(input, _map_loadLimits_codec);
            break;
          }
          case 258: {
            DisplayName = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            TravelMode = (global::Google.Maps.RouteOptimization.V1.Vehicle.Types.TravelMode) input.ReadEnum();
            break;
          }
          case 18: {
            if (routeModifiers_ == null) {
              RouteModifiers = new global::Google.Maps.RouteOptimization.V1.RouteModifiers();
            }
            input.ReadMessage(RouteModifiers);
            break;
          }
          case 26: {
            if (startLocation_ == null) {
              StartLocation = new global::Google.Type.LatLng();
            }
            input.ReadMessage(StartLocation);
            break;
          }
          case 34: {
            if (startWaypoint_ == null) {
              StartWaypoint = new global::Google.Maps.RouteOptimization.V1.Waypoint();
            }
            input.ReadMessage(StartWaypoint);
            break;
          }
          case 42: {
            if (endLocation_ == null) {
              EndLocation = new global::Google.Type.LatLng();
            }
            input.ReadMessage(EndLocation);
            break;
          }
          case 50: {
            if (endWaypoint_ == null) {
              EndWaypoint = new global::Google.Maps.RouteOptimization.V1.Waypoint();
            }
            input.ReadMessage(EndWaypoint);
            break;
          }
          case 58: {
            startTags_.AddEntriesFrom(ref input, _repeated_startTags_codec);
            break;
          }
          case 66: {
            endTags_.AddEntriesFrom(ref input, _repeated_endTags_codec);
            break;
          }
          case 74: {
            startTimeWindows_.AddEntriesFrom(ref input, _repeated_startTimeWindows_codec);
            break;
          }
          case 82: {
            endTimeWindows_.AddEntriesFrom(ref input, _repeated_endTimeWindows_codec);
            break;
          }
          case 89: {
            TravelDurationMultiple = input.ReadDouble();
            break;
          }
          case 96: {
            UnloadingPolicy = (global::Google.Maps.RouteOptimization.V1.Vehicle.Types.UnloadingPolicy) input.ReadEnum();
            break;
          }
          case 129: {
            CostPerHour = input.ReadDouble();
            break;
          }
          case 137: {
            CostPerTraveledHour = input.ReadDouble();
            break;
          }
          case 145: {
            CostPerKilometer = input.ReadDouble();
            break;
          }
          case 153: {
            FixedCost = input.ReadDouble();
            break;
          }
          case 160: {
            UsedIfRouteIsEmpty = input.ReadBool();
            break;
          }
          case 170: {
            if (routeDurationLimit_ == null) {
              RouteDurationLimit = new global::Google.Maps.RouteOptimization.V1.Vehicle.Types.DurationLimit();
            }
            input.ReadMessage(RouteDurationLimit);
            break;
          }
          case 178: {
            if (travelDurationLimit_ == null) {
              TravelDurationLimit = new global::Google.Maps.RouteOptimization.V1.Vehicle.Types.DurationLimit();
            }
            input.ReadMessage(TravelDurationLimit);
            break;
          }
          case 186: {
            if (routeDistanceLimit_ == null) {
              RouteDistanceLimit = new global::Google.Maps.RouteOptimization.V1.DistanceLimit();
            }
            input.ReadMessage(RouteDistanceLimit);
            break;
          }
          case 194: {
            extraVisitDurationForVisitType_.AddEntriesFrom(ref input, _map_extraVisitDurationForVisitType_codec);
            break;
          }
          case 202: {
            if (breakRule_ == null) {
              BreakRule = new global::Google.Maps.RouteOptimization.V1.BreakRule();
            }
            input.ReadMessage(BreakRule);
            break;
          }
          case 218: {
            Label = input.ReadString();
            break;
          }
          case 224: {
            Ignore = input.ReadBool();
            break;
          }
          case 242: {
            loadLimits_.AddEntriesFrom(ref input, _map_loadLimits_codec);
            break;
          }
          case 258: {
            DisplayName = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Vehicle message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Travel modes which can be used by vehicles.
      ///
      /// These should be a subset of the Google Maps Platform Routes Preferred API
      /// travel modes, see:
      /// https://developers.google.com/maps/documentation/routes_preferred/reference/rest/Shared.Types/RouteTravelMode.
      /// </summary>
      public enum TravelMode {
        /// <summary>
        /// Unspecified travel mode, equivalent to `DRIVING`.
        /// </summary>
        [pbr::OriginalName("TRAVEL_MODE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Travel mode corresponding to driving directions (car, ...).
        /// </summary>
        [pbr::OriginalName("DRIVING")] Driving = 1,
        /// <summary>
        /// Travel mode corresponding to walking directions.
        /// </summary>
        [pbr::OriginalName("WALKING")] Walking = 2,
      }

      /// <summary>
      /// Policy on how a vehicle can be unloaded. Applies only to shipments having
      /// both a pickup and a delivery.
      ///
      /// Other shipments are free to occur anywhere on the route independent of
      /// `unloading_policy`.
      /// </summary>
      public enum UnloadingPolicy {
        /// <summary>
        /// Unspecified unloading policy; deliveries must just occur after their
        /// corresponding pickups.
        /// </summary>
        [pbr::OriginalName("UNLOADING_POLICY_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Deliveries must occur in reverse order of pickups
        /// </summary>
        [pbr::OriginalName("LAST_IN_FIRST_OUT")] LastInFirstOut = 1,
        /// <summary>
        /// Deliveries must occur in the same order as pickups
        /// </summary>
        [pbr::OriginalName("FIRST_IN_FIRST_OUT")] FirstInFirstOut = 2,
      }

      /// <summary>
      /// Defines a load limit applying to a vehicle, e.g. "this truck may only
      /// carry up to 3500 kg". See
      /// [load_limits][google.maps.routeoptimization.v1.Vehicle.load_limits].
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class LoadLimit : pb::IMessage<LoadLimit>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<LoadLimit> _parser = new pb::MessageParser<LoadLimit>(() => new LoadLimit());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<LoadLimit> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.RouteOptimization.V1.Vehicle.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LoadLimit() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LoadLimit(LoadLimit other) : this() {
          _hasBits0 = other._hasBits0;
          maxLoad_ = other.maxLoad_;
          softMaxLoad_ = other.softMaxLoad_;
          costPerUnitAboveSoftMax_ = other.costPerUnitAboveSoftMax_;
          startLoadInterval_ = other.startLoadInterval_ != null ? other.startLoadInterval_.Clone() : null;
          endLoadInterval_ = other.endLoadInterval_ != null ? other.endLoadInterval_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LoadLimit Clone() {
          return new LoadLimit(this);
        }

        /// <summary>Field number for the "max_load" field.</summary>
        public const int MaxLoadFieldNumber = 1;
        private readonly static long MaxLoadDefaultValue = 0L;

        private long maxLoad_;
        /// <summary>
        /// The maximum acceptable amount of load.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public long MaxLoad {
          get { if ((_hasBits0 & 1) != 0) { return maxLoad_; } else { return MaxLoadDefaultValue; } }
          set {
            _hasBits0 |= 1;
            maxLoad_ = value;
          }
        }
        /// <summary>Gets whether the "max_load" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasMaxLoad {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "max_load" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearMaxLoad() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "soft_max_load" field.</summary>
        public const int SoftMaxLoadFieldNumber = 2;
        private long softMaxLoad_;
        /// <summary>
        /// A soft limit of the load. See
        /// [cost_per_unit_above_soft_max][google.maps.routeoptimization.v1.Vehicle.LoadLimit.cost_per_unit_above_soft_max].
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public long SoftMaxLoad {
          get { return softMaxLoad_; }
          set {
            softMaxLoad_ = value;
          }
        }

        /// <summary>Field number for the "cost_per_unit_above_soft_max" field.</summary>
        public const int CostPerUnitAboveSoftMaxFieldNumber = 3;
        private double costPerUnitAboveSoftMax_;
        /// <summary>
        /// If the load ever exceeds
        /// [soft_max_load][google.maps.routeoptimization.v1.Vehicle.LoadLimit.soft_max_load]
        /// along this vehicle's route, the following cost penalty applies (only once
        /// per vehicle): (load -
        /// [soft_max_load][google.maps.routeoptimization.v1.Vehicle.LoadLimit.soft_max_load])
        /// * [cost_per_unit_above_soft_max][google.maps.routeoptimization.v1.Vehicle.LoadLimit.cost_per_unit_above_soft_max]. All costs
        /// add up and must be in the same unit as
        /// [Shipment.penalty_cost][google.maps.routeoptimization.v1.Shipment.penalty_cost].
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public double CostPerUnitAboveSoftMax {
          get { return costPerUnitAboveSoftMax_; }
          set {
            costPerUnitAboveSoftMax_ = value;
          }
        }

        /// <summary>Field number for the "start_load_interval" field.</summary>
        public const int StartLoadIntervalFieldNumber = 4;
        private global::Google.Maps.RouteOptimization.V1.Vehicle.Types.LoadLimit.Types.Interval startLoadInterval_;
        /// <summary>
        /// The acceptable load interval of the vehicle at the start of the route.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Maps.RouteOptimization.V1.Vehicle.Types.LoadLimit.Types.Interval StartLoadInterval {
          get { return startLoadInterval_; }
          set {
            startLoadInterval_ = value;
          }
        }

        /// <summary>Field number for the "end_load_interval" field.</summary>
        public const int EndLoadIntervalFieldNumber = 5;
        private global::Google.Maps.RouteOptimization.V1.Vehicle.Types.LoadLimit.Types.Interval endLoadInterval_;
        /// <summary>
        /// The acceptable load interval of the vehicle at the end of the route.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Maps.RouteOptimization.V1.Vehicle.Types.LoadLimit.Types.Interval EndLoadInterval {
          get { return endLoadInterval_; }
          set {
            endLoadInterval_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as LoadLimit);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(LoadLimit other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (MaxLoad != other.MaxLoad) return false;
          if (SoftMaxLoad != other.SoftMaxLoad) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(CostPerUnitAboveSoftMax, other.CostPerUnitAboveSoftMax)) return false;
          if (!object.Equals(StartLoadInterval, other.StartLoadInterval)) return false;
          if (!object.Equals(EndLoadInterval, other.EndLoadInterval)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasMaxLoad) hash ^= MaxLoad.GetHashCode();
          if (SoftMaxLoad != 0L) hash ^= SoftMaxLoad.GetHashCode();
          if (CostPerUnitAboveSoftMax != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(CostPerUnitAboveSoftMax);
          if (startLoadInterval_ != null) hash ^= StartLoadInterval.GetHashCode();
          if (endLoadInterval_ != null) hash ^= EndLoadInterval.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasMaxLoad) {
            output.WriteRawTag(8);
            output.WriteInt64(MaxLoad);
          }
          if (SoftMaxLoad != 0L) {
            output.WriteRawTag(16);
            output.WriteInt64(SoftMaxLoad);
          }
          if (CostPerUnitAboveSoftMax != 0D) {
            output.WriteRawTag(25);
            output.WriteDouble(CostPerUnitAboveSoftMax);
          }
          if (startLoadInterval_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(StartLoadInterval);
          }
          if (endLoadInterval_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(EndLoadInterval);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasMaxLoad) {
            output.WriteRawTag(8);
            output.WriteInt64(MaxLoad);
          }
          if (SoftMaxLoad != 0L) {
            output.WriteRawTag(16);
            output.WriteInt64(SoftMaxLoad);
          }
          if (CostPerUnitAboveSoftMax != 0D) {
            output.WriteRawTag(25);
            output.WriteDouble(CostPerUnitAboveSoftMax);
          }
          if (startLoadInterval_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(StartLoadInterval);
          }
          if (endLoadInterval_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(EndLoadInterval);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasMaxLoad) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(MaxLoad);
          }
          if (SoftMaxLoad != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(SoftMaxLoad);
          }
          if (CostPerUnitAboveSoftMax != 0D) {
            size += 1 + 8;
          }
          if (startLoadInterval_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(StartLoadInterval);
          }
          if (endLoadInterval_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(EndLoadInterval);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(LoadLimit other) {
          if (other == null) {
            return;
          }
          if (other.HasMaxLoad) {
            MaxLoad = other.MaxLoad;
          }
          if (other.SoftMaxLoad != 0L) {
            SoftMaxLoad = other.SoftMaxLoad;
          }
          if (other.CostPerUnitAboveSoftMax != 0D) {
            CostPerUnitAboveSoftMax = other.CostPerUnitAboveSoftMax;
          }
          if (other.startLoadInterval_ != null) {
            if (startLoadInterval_ == null) {
              StartLoadInterval = new global::Google.Maps.RouteOptimization.V1.Vehicle.Types.LoadLimit.Types.Interval();
            }
            StartLoadInterval.MergeFrom(other.StartLoadInterval);
          }
          if (other.endLoadInterval_ != null) {
            if (endLoadInterval_ == null) {
              EndLoadInterval = new global::Google.Maps.RouteOptimization.V1.Vehicle.Types.LoadLimit.Types.Interval();
            }
            EndLoadInterval.MergeFrom(other.EndLoadInterval);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                MaxLoad = input.ReadInt64();
                break;
              }
              case 16: {
                SoftMaxLoad = input.ReadInt64();
                break;
              }
              case 25: {
                CostPerUnitAboveSoftMax = input.ReadDouble();
                break;
              }
              case 34: {
                if (startLoadInterval_ == null) {
                  StartLoadInterval = new global::Google.Maps.RouteOptimization.V1.Vehicle.Types.LoadLimit.Types.Interval();
                }
                input.ReadMessage(StartLoadInterval);
                break;
              }
              case 42: {
                if (endLoadInterval_ == null) {
                  EndLoadInterval = new global::Google.Maps.RouteOptimization.V1.Vehicle.Types.LoadLimit.Types.Interval();
                }
                input.ReadMessage(EndLoadInterval);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                MaxLoad = input.ReadInt64();
                break;
              }
              case 16: {
                SoftMaxLoad = input.ReadInt64();
                break;
              }
              case 25: {
                CostPerUnitAboveSoftMax = input.ReadDouble();
                break;
              }
              case 34: {
                if (startLoadInterval_ == null) {
                  StartLoadInterval = new global::Google.Maps.RouteOptimization.V1.Vehicle.Types.LoadLimit.Types.Interval();
                }
                input.ReadMessage(StartLoadInterval);
                break;
              }
              case 42: {
                if (endLoadInterval_ == null) {
                  EndLoadInterval = new global::Google.Maps.RouteOptimization.V1.Vehicle.Types.LoadLimit.Types.Interval();
                }
                input.ReadMessage(EndLoadInterval);
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the LoadLimit message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// Interval of acceptable load amounts.
          /// </summary>
          [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
          public sealed partial class Interval : pb::IMessage<Interval>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<Interval> _parser = new pb::MessageParser<Interval>(() => new Interval());
            private pb::UnknownFieldSet _unknownFields;
            private int _hasBits0;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<Interval> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Maps.RouteOptimization.V1.Vehicle.Types.LoadLimit.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Interval() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Interval(Interval other) : this() {
              _hasBits0 = other._hasBits0;
              min_ = other.min_;
              max_ = other.max_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Interval Clone() {
              return new Interval(this);
            }

            /// <summary>Field number for the "min" field.</summary>
            public const int MinFieldNumber = 1;
            private long min_;
            /// <summary>
            /// A minimum acceptable load. Must be  0.
            /// If they're both specified,
            /// [min][google.maps.routeoptimization.v1.Vehicle.LoadLimit.Interval.min]
            /// must be 
            /// [max][google.maps.routeoptimization.v1.Vehicle.LoadLimit.Interval.max].
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public long Min {
              get { return min_; }
              set {
                min_ = value;
              }
            }

            /// <summary>Field number for the "max" field.</summary>
            public const int MaxFieldNumber = 2;
            private readonly static long MaxDefaultValue = 0L;

            private long max_;
            /// <summary>
            /// A maximum acceptable load. Must be  0. If unspecified, the maximum
            /// load is unrestricted by this message.
            /// If they're both specified,
            /// [min][google.maps.routeoptimization.v1.Vehicle.LoadLimit.Interval.min]
            /// must be 
            /// [max][google.maps.routeoptimization.v1.Vehicle.LoadLimit.Interval.max].
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public long Max {
              get { if ((_hasBits0 & 1) != 0) { return max_; } else { return MaxDefaultValue; } }
              set {
                _hasBits0 |= 1;
                max_ = value;
              }
            }
            /// <summary>Gets whether the "max" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasMax {
              get { return (_hasBits0 & 1) != 0; }
            }
            /// <summary>Clears the value of the "max" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearMax() {
              _hasBits0 &= ~1;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as Interval);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(Interval other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Min != other.Min) return false;
              if (Max != other.Max) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (Min != 0L) hash ^= Min.GetHashCode();
              if (HasMax) hash ^= Max.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (Min != 0L) {
                output.WriteRawTag(8);
                output.WriteInt64(Min);
              }
              if (HasMax) {
                output.WriteRawTag(16);
                output.WriteInt64(Max);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (Min != 0L) {
                output.WriteRawTag(8);
                output.WriteInt64(Min);
              }
              if (HasMax) {
                output.WriteRawTag(16);
                output.WriteInt64(Max);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (Min != 0L) {
                size += 1 + pb::CodedOutputStream.ComputeInt64Size(Min);
              }
              if (HasMax) {
                size += 1 + pb::CodedOutputStream.ComputeInt64Size(Max);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(Interval other) {
              if (other == null) {
                return;
              }
              if (other.Min != 0L) {
                Min = other.Min;
              }
              if (other.HasMax) {
                Max = other.Max;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 8: {
                    Min = input.ReadInt64();
                    break;
                  }
                  case 16: {
                    Max = input.ReadInt64();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 8: {
                    Min = input.ReadInt64();
                    break;
                  }
                  case 16: {
                    Max = input.ReadInt64();
                    break;
                  }
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

      /// <summary>
      /// A limit defining a maximum duration of the route of a vehicle. It can be
      /// either hard or soft.
      ///
      /// When a soft limit field is defined, both the soft max threshold and its
      /// associated cost must be defined together.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class DurationLimit : pb::IMessage<DurationLimit>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<DurationLimit> _parser = new pb::MessageParser<DurationLimit>(() => new DurationLimit());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<DurationLimit> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.RouteOptimization.V1.Vehicle.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DurationLimit() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DurationLimit(DurationLimit other) : this() {
          _hasBits0 = other._hasBits0;
          maxDuration_ = other.maxDuration_ != null ? other.maxDuration_.Clone() : null;
          softMaxDuration_ = other.softMaxDuration_ != null ? other.softMaxDuration_.Clone() : null;
          costPerHourAfterSoftMax_ = other.costPerHourAfterSoftMax_;
          quadraticSoftMaxDuration_ = other.quadraticSoftMaxDuration_ != null ? other.quadraticSoftMaxDuration_.Clone() : null;
          costPerSquareHourAfterQuadraticSoftMax_ = other.costPerSquareHourAfterQuadraticSoftMax_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DurationLimit Clone() {
          return new DurationLimit(this);
        }

        /// <summary>Field number for the "max_duration" field.</summary>
        public const int MaxDurationFieldNumber = 1;
        private global::Google.Protobuf.WellKnownTypes.Duration maxDuration_;
        /// <summary>
        /// A hard limit constraining the duration to be at most max_duration.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration MaxDuration {
          get { return maxDuration_; }
          set {
            maxDuration_ = value;
          }
        }

        /// <summary>Field number for the "soft_max_duration" field.</summary>
        public const int SoftMaxDurationFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Duration softMaxDuration_;
        /// <summary>
        /// A soft limit not enforcing a maximum duration limit, but when violated
        /// makes the route incur a cost. This cost adds up to other costs defined in
        /// the model, with the same unit.
        ///
        /// If defined, `soft_max_duration` must be nonnegative. If max_duration is
        /// also defined, `soft_max_duration` must be less than max_duration.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration SoftMaxDuration {
          get { return softMaxDuration_; }
          set {
            softMaxDuration_ = value;
          }
        }

        /// <summary>Field number for the "cost_per_hour_after_soft_max" field.</summary>
        public const int CostPerHourAfterSoftMaxFieldNumber = 3;
        private readonly static double CostPerHourAfterSoftMaxDefaultValue = 0D;

        private double costPerHourAfterSoftMax_;
        /// <summary>
        /// Cost per hour incurred if the `soft_max_duration` threshold is violated.
        /// The additional cost is 0 if the duration is under the threshold,
        /// otherwise the cost depends on the duration as follows:
        /// ```
        ///   cost_per_hour_after_soft_max * (duration - soft_max_duration)
        /// ```
        /// The cost must be nonnegative.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public double CostPerHourAfterSoftMax {
          get { if ((_hasBits0 & 1) != 0) { return costPerHourAfterSoftMax_; } else { return CostPerHourAfterSoftMaxDefaultValue; } }
          set {
            _hasBits0 |= 1;
            costPerHourAfterSoftMax_ = value;
          }
        }
        /// <summary>Gets whether the "cost_per_hour_after_soft_max" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasCostPerHourAfterSoftMax {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "cost_per_hour_after_soft_max" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearCostPerHourAfterSoftMax() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "quadratic_soft_max_duration" field.</summary>
        public const int QuadraticSoftMaxDurationFieldNumber = 4;
        private global::Google.Protobuf.WellKnownTypes.Duration quadraticSoftMaxDuration_;
        /// <summary>
        /// A soft limit not enforcing a maximum duration limit, but when violated
        /// makes the route incur a cost, quadratic in the duration. This cost adds
        /// up to other costs defined in the model, with the same unit.
        ///
        /// If defined, `quadratic_soft_max_duration` must be nonnegative. If
        /// `max_duration` is also defined, `quadratic_soft_max_duration` must be
        /// less than `max_duration`, and the difference must be no larger than one
        /// day:
        ///
        ///    `max_duration - quadratic_soft_max_duration &lt;= 86400 seconds`
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration QuadraticSoftMaxDuration {
          get { return quadraticSoftMaxDuration_; }
          set {
            quadraticSoftMaxDuration_ = value;
          }
        }

        /// <summary>Field number for the "cost_per_square_hour_after_quadratic_soft_max" field.</summary>
        public const int CostPerSquareHourAfterQuadraticSoftMaxFieldNumber = 5;
        private readonly static double CostPerSquareHourAfterQuadraticSoftMaxDefaultValue = 0D;

        private double costPerSquareHourAfterQuadraticSoftMax_;
        /// <summary>
        /// Cost per square hour incurred if the
        /// `quadratic_soft_max_duration` threshold is violated.
        ///
        /// The additional cost is 0 if the duration is under the threshold,
        /// otherwise the cost depends on the duration as follows:
        ///
        /// ```
        ///   cost_per_square_hour_after_quadratic_soft_max *
        ///   (duration - quadratic_soft_max_duration)^2
        /// ```
        ///
        /// The cost must be nonnegative.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public double CostPerSquareHourAfterQuadraticSoftMax {
          get { if ((_hasBits0 & 2) != 0) { return costPerSquareHourAfterQuadraticSoftMax_; } else { return CostPerSquareHourAfterQuadraticSoftMaxDefaultValue; } }
          set {
            _hasBits0 |= 2;
            costPerSquareHourAfterQuadraticSoftMax_ = value;
          }
        }
        /// <summary>Gets whether the "cost_per_square_hour_after_quadratic_soft_max" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasCostPerSquareHourAfterQuadraticSoftMax {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "cost_per_square_hour_after_quadratic_soft_max" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearCostPerSquareHourAfterQuadraticSoftMax() {
          _hasBits0 &= ~2;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as DurationLimit);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(DurationLimit other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(MaxDuration, other.MaxDuration)) return false;
          if (!object.Equals(SoftMaxDuration, other.SoftMaxDuration)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(CostPerHourAfterSoftMax, other.CostPerHourAfterSoftMax)) return false;
          if (!object.Equals(QuadraticSoftMaxDuration, other.QuadraticSoftMaxDuration)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(CostPerSquareHourAfterQuadraticSoftMax, other.CostPerSquareHourAfterQuadraticSoftMax)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (maxDuration_ != null) hash ^= MaxDuration.GetHashCode();
          if (softMaxDuration_ != null) hash ^= SoftMaxDuration.GetHashCode();
          if (HasCostPerHourAfterSoftMax) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(CostPerHourAfterSoftMax);
          if (quadraticSoftMaxDuration_ != null) hash ^= QuadraticSoftMaxDuration.GetHashCode();
          if (HasCostPerSquareHourAfterQuadraticSoftMax) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(CostPerSquareHourAfterQuadraticSoftMax);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (maxDuration_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(MaxDuration);
          }
          if (softMaxDuration_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(SoftMaxDuration);
          }
          if (HasCostPerHourAfterSoftMax) {
            output.WriteRawTag(25);
            output.WriteDouble(CostPerHourAfterSoftMax);
          }
          if (quadraticSoftMaxDuration_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(QuadraticSoftMaxDuration);
          }
          if (HasCostPerSquareHourAfterQuadraticSoftMax) {
            output.WriteRawTag(41);
            output.WriteDouble(CostPerSquareHourAfterQuadraticSoftMax);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (maxDuration_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(MaxDuration);
          }
          if (softMaxDuration_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(SoftMaxDuration);
          }
          if (HasCostPerHourAfterSoftMax) {
            output.WriteRawTag(25);
            output.WriteDouble(CostPerHourAfterSoftMax);
          }
          if (quadraticSoftMaxDuration_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(QuadraticSoftMaxDuration);
          }
          if (HasCostPerSquareHourAfterQuadraticSoftMax) {
            output.WriteRawTag(41);
            output.WriteDouble(CostPerSquareHourAfterQuadraticSoftMax);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (maxDuration_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaxDuration);
          }
          if (softMaxDuration_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(SoftMaxDuration);
          }
          if (HasCostPerHourAfterSoftMax) {
            size += 1 + 8;
          }
          if (quadraticSoftMaxDuration_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(QuadraticSoftMaxDuration);
          }
          if (HasCostPerSquareHourAfterQuadraticSoftMax) {
            size += 1 + 8;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(DurationLimit other) {
          if (other == null) {
            return;
          }
          if (other.maxDuration_ != null) {
            if (maxDuration_ == null) {
              MaxDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            MaxDuration.MergeFrom(other.MaxDuration);
          }
          if (other.softMaxDuration_ != null) {
            if (softMaxDuration_ == null) {
              SoftMaxDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            SoftMaxDuration.MergeFrom(other.SoftMaxDuration);
          }
          if (other.HasCostPerHourAfterSoftMax) {
            CostPerHourAfterSoftMax = other.CostPerHourAfterSoftMax;
          }
          if (other.quadraticSoftMaxDuration_ != null) {
            if (quadraticSoftMaxDuration_ == null) {
              QuadraticSoftMaxDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            QuadraticSoftMaxDuration.MergeFrom(other.QuadraticSoftMaxDuration);
          }
          if (other.HasCostPerSquareHourAfterQuadraticSoftMax) {
            CostPerSquareHourAfterQuadraticSoftMax = other.CostPerSquareHourAfterQuadraticSoftMax;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (maxDuration_ == null) {
                  MaxDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(MaxDuration);
                break;
              }
              case 18: {
                if (softMaxDuration_ == null) {
                  SoftMaxDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(SoftMaxDuration);
                break;
              }
              case 25: {
                CostPerHourAfterSoftMax = input.ReadDouble();
                break;
              }
              case 34: {
                if (quadraticSoftMaxDuration_ == null) {
                  QuadraticSoftMaxDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(QuadraticSoftMaxDuration);
                break;
              }
              case 41: {
                CostPerSquareHourAfterQuadraticSoftMax = input.ReadDouble();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (maxDuration_ == null) {
                  MaxDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(MaxDuration);
                break;
              }
              case 18: {
                if (softMaxDuration_ == null) {
                  SoftMaxDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(SoftMaxDuration);
                break;
              }
              case 25: {
                CostPerHourAfterSoftMax = input.ReadDouble();
                break;
              }
              case 34: {
                if (quadraticSoftMaxDuration_ == null) {
                  QuadraticSoftMaxDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(QuadraticSoftMaxDuration);
                break;
              }
              case 41: {
                CostPerSquareHourAfterQuadraticSoftMax = input.ReadDouble();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Time windows constrain the time of an event, such as the arrival time at a
  /// visit, or the start and end time of a vehicle.
  ///
  /// Hard time window bounds, `start_time` and `end_time`, enforce the earliest
  /// and latest time of the event, such that `start_time &lt;= event_time &lt;=
  /// end_time`. The soft time window lower bound, `soft_start_time`, expresses a
  /// preference for the event to happen at or after `soft_start_time` by incurring
  /// a cost proportional to how long before soft_start_time the event occurs. The
  /// soft time window upper bound, `soft_end_time`, expresses a preference for the
  /// event to happen at or before `soft_end_time` by incurring a cost proportional
  /// to how long after `soft_end_time` the event occurs. `start_time`, `end_time`,
  /// `soft_start_time` and `soft_end_time` should be within the global time limits
  /// (see
  /// [ShipmentModel.global_start_time][google.maps.routeoptimization.v1.ShipmentModel.global_start_time]
  /// and
  /// [ShipmentModel.global_end_time][google.maps.routeoptimization.v1.ShipmentModel.global_end_time])
  /// and should respect:
  /// ```
  ///   0 &lt;= `start_time` &lt;= `end_time` and
  ///   0 &lt;= `start_time` &lt;= `soft_start_time` and
  ///   0 &lt;= `soft_end_time` &lt;= `end_time`.
  /// ```
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TimeWindow : pb::IMessage<TimeWindow>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TimeWindow> _parser = new pb::MessageParser<TimeWindow>(() => new TimeWindow());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TimeWindow> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TimeWindow() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TimeWindow(TimeWindow other) : this() {
      _hasBits0 = other._hasBits0;
      startTime_ = other.startTime_ != null ? other.startTime_.Clone() : null;
      endTime_ = other.endTime_ != null ? other.endTime_.Clone() : null;
      softStartTime_ = other.softStartTime_ != null ? other.softStartTime_.Clone() : null;
      softEndTime_ = other.softEndTime_ != null ? other.softEndTime_.Clone() : null;
      costPerHourBeforeSoftStartTime_ = other.costPerHourBeforeSoftStartTime_;
      costPerHourAfterSoftEndTime_ = other.costPerHourAfterSoftEndTime_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TimeWindow Clone() {
      return new TimeWindow(this);
    }

    /// <summary>Field number for the "start_time" field.</summary>
    public const int StartTimeFieldNumber = 1;
    private global::Google.Protobuf.WellKnownTypes.Timestamp startTime_;
    /// <summary>
    /// The hard time window start time. If unspecified it will be set to
    /// `ShipmentModel.global_start_time`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp StartTime {
      get { return startTime_; }
      set {
        startTime_ = value;
      }
    }

    /// <summary>Field number for the "end_time" field.</summary>
    public const int EndTimeFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Timestamp endTime_;
    /// <summary>
    /// The hard time window end time. If unspecified it will be set to
    /// `ShipmentModel.global_end_time`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp EndTime {
      get { return endTime_; }
      set {
        endTime_ = value;
      }
    }

    /// <summary>Field number for the "soft_start_time" field.</summary>
    public const int SoftStartTimeFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Timestamp softStartTime_;
    /// <summary>
    /// The soft start time of the time window.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp SoftStartTime {
      get { return softStartTime_; }
      set {
        softStartTime_ = value;
      }
    }

    /// <summary>Field number for the "soft_end_time" field.</summary>
    public const int SoftEndTimeFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Timestamp softEndTime_;
    /// <summary>
    /// The soft end time of the time window.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp SoftEndTime {
      get { return softEndTime_; }
      set {
        softEndTime_ = value;
      }
    }

    /// <summary>Field number for the "cost_per_hour_before_soft_start_time" field.</summary>
    public const int CostPerHourBeforeSoftStartTimeFieldNumber = 5;
    private readonly static double CostPerHourBeforeSoftStartTimeDefaultValue = 0D;

    private double costPerHourBeforeSoftStartTime_;
    /// <summary>
    /// A cost per hour added to other costs in the model if the event occurs
    /// before soft_start_time, computed as:
    ///
    /// ```
    ///    max(0, soft_start_time - t.seconds)
    ///                           * cost_per_hour_before_soft_start_time / 3600,
    /// t being the time of the event.
    /// ```
    ///
    /// This cost must be positive, and the field can only be set if
    /// soft_start_time has been set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double CostPerHourBeforeSoftStartTime {
      get { if ((_hasBits0 & 1) != 0) { return costPerHourBeforeSoftStartTime_; } else { return CostPerHourBeforeSoftStartTimeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        costPerHourBeforeSoftStartTime_ = value;
      }
    }
    /// <summary>Gets whether the "cost_per_hour_before_soft_start_time" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCostPerHourBeforeSoftStartTime {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "cost_per_hour_before_soft_start_time" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCostPerHourBeforeSoftStartTime() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "cost_per_hour_after_soft_end_time" field.</summary>
    public const int CostPerHourAfterSoftEndTimeFieldNumber = 6;
    private readonly static double CostPerHourAfterSoftEndTimeDefaultValue = 0D;

    private double costPerHourAfterSoftEndTime_;
    /// <summary>
    /// A cost per hour added to other costs in the model if the event occurs after
    /// `soft_end_time`, computed as:
    ///
    /// ```
    ///    max(0, t.seconds - soft_end_time.seconds)
    ///                     * cost_per_hour_after_soft_end_time / 3600,
    /// t being the time of the event.
    /// ```
    ///
    /// This cost must be positive, and the field can only be set if
    /// `soft_end_time` has been set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double CostPerHourAfterSoftEndTime {
      get { if ((_hasBits0 & 2) != 0) { return costPerHourAfterSoftEndTime_; } else { return CostPerHourAfterSoftEndTimeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        costPerHourAfterSoftEndTime_ = value;
      }
    }
    /// <summary>Gets whether the "cost_per_hour_after_soft_end_time" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCostPerHourAfterSoftEndTime {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "cost_per_hour_after_soft_end_time" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCostPerHourAfterSoftEndTime() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TimeWindow);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TimeWindow other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(StartTime, other.StartTime)) return false;
      if (!object.Equals(EndTime, other.EndTime)) return false;
      if (!object.Equals(SoftStartTime, other.SoftStartTime)) return false;
      if (!object.Equals(SoftEndTime, other.SoftEndTime)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(CostPerHourBeforeSoftStartTime, other.CostPerHourBeforeSoftStartTime)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(CostPerHourAfterSoftEndTime, other.CostPerHourAfterSoftEndTime)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (startTime_ != null) hash ^= StartTime.GetHashCode();
      if (endTime_ != null) hash ^= EndTime.GetHashCode();
      if (softStartTime_ != null) hash ^= SoftStartTime.GetHashCode();
      if (softEndTime_ != null) hash ^= SoftEndTime.GetHashCode();
      if (HasCostPerHourBeforeSoftStartTime) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(CostPerHourBeforeSoftStartTime);
      if (HasCostPerHourAfterSoftEndTime) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(CostPerHourAfterSoftEndTime);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (startTime_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(StartTime);
      }
      if (endTime_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(EndTime);
      }
      if (softStartTime_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(SoftStartTime);
      }
      if (softEndTime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(SoftEndTime);
      }
      if (HasCostPerHourBeforeSoftStartTime) {
        output.WriteRawTag(41);
        output.WriteDouble(CostPerHourBeforeSoftStartTime);
      }
      if (HasCostPerHourAfterSoftEndTime) {
        output.WriteRawTag(49);
        output.WriteDouble(CostPerHourAfterSoftEndTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (startTime_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(StartTime);
      }
      if (endTime_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(EndTime);
      }
      if (softStartTime_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(SoftStartTime);
      }
      if (softEndTime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(SoftEndTime);
      }
      if (HasCostPerHourBeforeSoftStartTime) {
        output.WriteRawTag(41);
        output.WriteDouble(CostPerHourBeforeSoftStartTime);
      }
      if (HasCostPerHourAfterSoftEndTime) {
        output.WriteRawTag(49);
        output.WriteDouble(CostPerHourAfterSoftEndTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (startTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StartTime);
      }
      if (endTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EndTime);
      }
      if (softStartTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SoftStartTime);
      }
      if (softEndTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SoftEndTime);
      }
      if (HasCostPerHourBeforeSoftStartTime) {
        size += 1 + 8;
      }
      if (HasCostPerHourAfterSoftEndTime) {
        size += 1 + 8;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TimeWindow other) {
      if (other == null) {
        return;
      }
      if (other.startTime_ != null) {
        if (startTime_ == null) {
          StartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        StartTime.MergeFrom(other.StartTime);
      }
      if (other.endTime_ != null) {
        if (endTime_ == null) {
          EndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        EndTime.MergeFrom(other.EndTime);
      }
      if (other.softStartTime_ != null) {
        if (softStartTime_ == null) {
          SoftStartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        SoftStartTime.MergeFrom(other.SoftStartTime);
      }
      if (other.softEndTime_ != null) {
        if (softEndTime_ == null) {
          SoftEndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        SoftEndTime.MergeFrom(other.SoftEndTime);
      }
      if (other.HasCostPerHourBeforeSoftStartTime) {
        CostPerHourBeforeSoftStartTime = other.CostPerHourBeforeSoftStartTime;
      }
      if (other.HasCostPerHourAfterSoftEndTime) {
        CostPerHourAfterSoftEndTime = other.CostPerHourAfterSoftEndTime;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (startTime_ == null) {
              StartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(StartTime);
            break;
          }
          case 18: {
            if (endTime_ == null) {
              EndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(EndTime);
            break;
          }
          case 26: {
            if (softStartTime_ == null) {
              SoftStartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(SoftStartTime);
            break;
          }
          case 34: {
            if (softEndTime_ == null) {
              SoftEndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(SoftEndTime);
            break;
          }
          case 41: {
            CostPerHourBeforeSoftStartTime = input.ReadDouble();
            break;
          }
          case 49: {
            CostPerHourAfterSoftEndTime = input.ReadDouble();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (startTime_ == null) {
              StartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(StartTime);
            break;
          }
          case 18: {
            if (endTime_ == null) {
              EndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(EndTime);
            break;
          }
          case 26: {
            if (softStartTime_ == null) {
              SoftStartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(SoftStartTime);
            break;
          }
          case 34: {
            if (softEndTime_ == null) {
              SoftEndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(SoftEndTime);
            break;
          }
          case 41: {
            CostPerHourBeforeSoftStartTime = input.ReadDouble();
            break;
          }
          case 49: {
            CostPerHourAfterSoftEndTime = input.ReadDouble();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A limit defining a maximum distance which can be traveled. It can be either
  /// hard or soft.
  ///
  /// If a soft limit is defined, both `soft_max_meters` and
  /// `cost_per_kilometer_above_soft_max` must be defined and be nonnegative.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class DistanceLimit : pb::IMessage<DistanceLimit>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DistanceLimit> _parser = new pb::MessageParser<DistanceLimit>(() => new DistanceLimit());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<DistanceLimit> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DistanceLimit() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DistanceLimit(DistanceLimit other) : this() {
      _hasBits0 = other._hasBits0;
      maxMeters_ = other.maxMeters_;
      softMaxMeters_ = other.softMaxMeters_;
      costPerKilometerBelowSoftMax_ = other.costPerKilometerBelowSoftMax_;
      costPerKilometerAboveSoftMax_ = other.costPerKilometerAboveSoftMax_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DistanceLimit Clone() {
      return new DistanceLimit(this);
    }

    /// <summary>Field number for the "max_meters" field.</summary>
    public const int MaxMetersFieldNumber = 1;
    private readonly static long MaxMetersDefaultValue = 0L;

    private long maxMeters_;
    /// <summary>
    /// A hard limit constraining the distance to be at most max_meters. The limit
    /// must be nonnegative.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long MaxMeters {
      get { if ((_hasBits0 & 1) != 0) { return maxMeters_; } else { return MaxMetersDefaultValue; } }
      set {
        _hasBits0 |= 1;
        maxMeters_ = value;
      }
    }
    /// <summary>Gets whether the "max_meters" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxMeters {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "max_meters" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxMeters() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "soft_max_meters" field.</summary>
    public const int SoftMaxMetersFieldNumber = 2;
    private readonly static long SoftMaxMetersDefaultValue = 0L;

    private long softMaxMeters_;
    /// <summary>
    /// A soft limit not enforcing a maximum distance limit, but when violated
    /// results in a cost which adds up to other costs defined in the model,
    /// with the same unit.
    ///
    /// If defined soft_max_meters must be less than max_meters and must be
    /// nonnegative.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long SoftMaxMeters {
      get { if ((_hasBits0 & 2) != 0) { return softMaxMeters_; } else { return SoftMaxMetersDefaultValue; } }
      set {
        _hasBits0 |= 2;
        softMaxMeters_ = value;
      }
    }
    /// <summary>Gets whether the "soft_max_meters" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSoftMaxMeters {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "soft_max_meters" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSoftMaxMeters() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "cost_per_kilometer_below_soft_max" field.</summary>
    public const int CostPerKilometerBelowSoftMaxFieldNumber = 4;
    private readonly static double CostPerKilometerBelowSoftMaxDefaultValue = 0D;

    private double costPerKilometerBelowSoftMax_;
    /// <summary>
    /// Cost per kilometer incurred, increasing up to `soft_max_meters`, with
    /// formula:
    /// ```
    ///   min(distance_meters, soft_max_meters) / 1000.0 *
    ///   cost_per_kilometer_below_soft_max.
    /// ```
    /// This cost is not supported in `route_distance_limit`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double CostPerKilometerBelowSoftMax {
      get { if ((_hasBits0 & 8) != 0) { return costPerKilometerBelowSoftMax_; } else { return CostPerKilometerBelowSoftMaxDefaultValue; } }
      set {
        _hasBits0 |= 8;
        costPerKilometerBelowSoftMax_ = value;
      }
    }
    /// <summary>Gets whether the "cost_per_kilometer_below_soft_max" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCostPerKilometerBelowSoftMax {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "cost_per_kilometer_below_soft_max" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCostPerKilometerBelowSoftMax() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "cost_per_kilometer_above_soft_max" field.</summary>
    public const int CostPerKilometerAboveSoftMaxFieldNumber = 3;
    private readonly static double CostPerKilometerAboveSoftMaxDefaultValue = 0D;

    private double costPerKilometerAboveSoftMax_;
    /// <summary>
    /// Cost per kilometer incurred if distance is above `soft_max_meters` limit.
    /// The additional cost is 0 if the distance is under the limit, otherwise the
    /// formula used to compute the cost is the following:
    /// ```
    ///   (distance_meters - soft_max_meters) / 1000.0 *
    ///   cost_per_kilometer_above_soft_max.
    /// ```
    /// The cost must be nonnegative.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double CostPerKilometerAboveSoftMax {
      get { if ((_hasBits0 & 4) != 0) { return costPerKilometerAboveSoftMax_; } else { return CostPerKilometerAboveSoftMaxDefaultValue; } }
      set {
        _hasBits0 |= 4;
        costPerKilometerAboveSoftMax_ = value;
      }
    }
    /// <summary>Gets whether the "cost_per_kilometer_above_soft_max" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCostPerKilometerAboveSoftMax {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "cost_per_kilometer_above_soft_max" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCostPerKilometerAboveSoftMax() {
      _hasBits0 &= ~4;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as DistanceLimit);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(DistanceLimit other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MaxMeters != other.MaxMeters) return false;
      if (SoftMaxMeters != other.SoftMaxMeters) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(CostPerKilometerBelowSoftMax, other.CostPerKilometerBelowSoftMax)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(CostPerKilometerAboveSoftMax, other.CostPerKilometerAboveSoftMax)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasMaxMeters) hash ^= MaxMeters.GetHashCode();
      if (HasSoftMaxMeters) hash ^= SoftMaxMeters.GetHashCode();
      if (HasCostPerKilometerBelowSoftMax) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(CostPerKilometerBelowSoftMax);
      if (HasCostPerKilometerAboveSoftMax) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(CostPerKilometerAboveSoftMax);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasMaxMeters) {
        output.WriteRawTag(8);
        output.WriteInt64(MaxMeters);
      }
      if (HasSoftMaxMeters) {
        output.WriteRawTag(16);
        output.WriteInt64(SoftMaxMeters);
      }
      if (HasCostPerKilometerAboveSoftMax) {
        output.WriteRawTag(25);
        output.WriteDouble(CostPerKilometerAboveSoftMax);
      }
      if (HasCostPerKilometerBelowSoftMax) {
        output.WriteRawTag(33);
        output.WriteDouble(CostPerKilometerBelowSoftMax);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasMaxMeters) {
        output.WriteRawTag(8);
        output.WriteInt64(MaxMeters);
      }
      if (HasSoftMaxMeters) {
        output.WriteRawTag(16);
        output.WriteInt64(SoftMaxMeters);
      }
      if (HasCostPerKilometerAboveSoftMax) {
        output.WriteRawTag(25);
        output.WriteDouble(CostPerKilometerAboveSoftMax);
      }
      if (HasCostPerKilometerBelowSoftMax) {
        output.WriteRawTag(33);
        output.WriteDouble(CostPerKilometerBelowSoftMax);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasMaxMeters) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(MaxMeters);
      }
      if (HasSoftMaxMeters) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(SoftMaxMeters);
      }
      if (HasCostPerKilometerBelowSoftMax) {
        size += 1 + 8;
      }
      if (HasCostPerKilometerAboveSoftMax) {
        size += 1 + 8;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(DistanceLimit other) {
      if (other == null) {
        return;
      }
      if (other.HasMaxMeters) {
        MaxMeters = other.MaxMeters;
      }
      if (other.HasSoftMaxMeters) {
        SoftMaxMeters = other.SoftMaxMeters;
      }
      if (other.HasCostPerKilometerBelowSoftMax) {
        CostPerKilometerBelowSoftMax = other.CostPerKilometerBelowSoftMax;
      }
      if (other.HasCostPerKilometerAboveSoftMax) {
        CostPerKilometerAboveSoftMax = other.CostPerKilometerAboveSoftMax;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            MaxMeters = input.ReadInt64();
            break;
          }
          case 16: {
            SoftMaxMeters = input.ReadInt64();
            break;
          }
          case 25: {
            CostPerKilometerAboveSoftMax = input.ReadDouble();
            break;
          }
          case 33: {
            CostPerKilometerBelowSoftMax = input.ReadDouble();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            MaxMeters = input.ReadInt64();
            break;
          }
          case 16: {
            SoftMaxMeters = input.ReadInt64();
            break;
          }
          case 25: {
            CostPerKilometerAboveSoftMax = input.ReadDouble();
            break;
          }
          case 33: {
            CostPerKilometerBelowSoftMax = input.ReadDouble();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Specifies attributes of transitions between two consecutive visits on a
  /// route. Several `TransitionAttributes` may apply to the same transition: in
  /// that case, all extra costs add up and the strictest constraint or limit
  /// applies (following natural "AND" semantics).
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TransitionAttributes : pb::IMessage<TransitionAttributes>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TransitionAttributes> _parser = new pb::MessageParser<TransitionAttributes>(() => new TransitionAttributes());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TransitionAttributes> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TransitionAttributes() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TransitionAttributes(TransitionAttributes other) : this() {
      srcTag_ = other.srcTag_;
      excludedSrcTag_ = other.excludedSrcTag_;
      dstTag_ = other.dstTag_;
      excludedDstTag_ = other.excludedDstTag_;
      cost_ = other.cost_;
      costPerKilometer_ = other.costPerKilometer_;
      distanceLimit_ = other.distanceLimit_ != null ? other.distanceLimit_.Clone() : null;
      delay_ = other.delay_ != null ? other.delay_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TransitionAttributes Clone() {
      return new TransitionAttributes(this);
    }

    /// <summary>Field number for the "src_tag" field.</summary>
    public const int SrcTagFieldNumber = 1;
    private string srcTag_ = "";
    /// <summary>
    /// Tags defining the set of (src->dst) transitions these attributes apply to.
    ///
    /// A source visit or vehicle start matches iff its
    /// [VisitRequest.tags][google.maps.routeoptimization.v1.Shipment.VisitRequest.tags]
    /// or
    /// [Vehicle.start_tags][google.maps.routeoptimization.v1.Vehicle.start_tags]
    /// either contains `src_tag` or does not contain `excluded_src_tag` (depending
    /// on which of these two fields is non-empty).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SrcTag {
      get { return srcTag_; }
      set {
        srcTag_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "excluded_src_tag" field.</summary>
    public const int ExcludedSrcTagFieldNumber = 2;
    private string excludedSrcTag_ = "";
    /// <summary>
    /// See `src_tag`. Exactly one of `src_tag` and `excluded_src_tag` must be
    /// non-empty.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ExcludedSrcTag {
      get { return excludedSrcTag_; }
      set {
        excludedSrcTag_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "dst_tag" field.</summary>
    public const int DstTagFieldNumber = 3;
    private string dstTag_ = "";
    /// <summary>
    /// A destination visit or vehicle end matches iff its
    /// [VisitRequest.tags][google.maps.routeoptimization.v1.Shipment.VisitRequest.tags]
    /// or [Vehicle.end_tags][google.maps.routeoptimization.v1.Vehicle.end_tags]
    /// either contains `dst_tag` or does not contain `excluded_dst_tag` (depending
    /// on which of these two fields is non-empty).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DstTag {
      get { return dstTag_; }
      set {
        dstTag_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "excluded_dst_tag" field.</summary>
    public const int ExcludedDstTagFieldNumber = 4;
    private string excludedDstTag_ = "";
    /// <summary>
    /// See `dst_tag`. Exactly one of `dst_tag` and `excluded_dst_tag` must be
    /// non-empty.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ExcludedDstTag {
      get { return excludedDstTag_; }
      set {
        excludedDstTag_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "cost" field.</summary>
    public const int CostFieldNumber = 5;
    private double cost_;
    /// <summary>
    /// Specifies a cost for performing this transition. This is in the same unit
    /// as all other costs in the model and must not be negative. It is applied on
    /// top of all other existing costs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double Cost {
      get { return cost_; }
      set {
        cost_ = value;
      }
    }

    /// <summary>Field number for the "cost_per_kilometer" field.</summary>
    public const int CostPerKilometerFieldNumber = 6;
    private double costPerKilometer_;
    /// <summary>
    /// Specifies a cost per kilometer applied to the distance traveled while
    /// performing this transition. It adds up to any
    /// [Vehicle.cost_per_kilometer][google.maps.routeoptimization.v1.Vehicle.cost_per_kilometer]
    /// specified on vehicles.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double CostPerKilometer {
      get { return costPerKilometer_; }
      set {
        costPerKilometer_ = value;
      }
    }

    /// <summary>Field number for the "distance_limit" field.</summary>
    public const int DistanceLimitFieldNumber = 7;
    private global::Google.Maps.RouteOptimization.V1.DistanceLimit distanceLimit_;
    /// <summary>
    /// Specifies a limit on the distance traveled while performing this
    /// transition.
    ///
    /// As of 2021/06, only soft limits are supported.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.DistanceLimit DistanceLimit {
      get { return distanceLimit_; }
      set {
        distanceLimit_ = value;
      }
    }

    /// <summary>Field number for the "delay" field.</summary>
    public const int DelayFieldNumber = 8;
    private global::Google.Protobuf.WellKnownTypes.Duration delay_;
    /// <summary>
    /// Specifies a delay incurred when performing this transition.
    ///
    /// This delay always occurs *after* finishing the source visit and *before*
    /// starting the destination visit.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration Delay {
      get { return delay_; }
      set {
        delay_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TransitionAttributes);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TransitionAttributes other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SrcTag != other.SrcTag) return false;
      if (ExcludedSrcTag != other.ExcludedSrcTag) return false;
      if (DstTag != other.DstTag) return false;
      if (ExcludedDstTag != other.ExcludedDstTag) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Cost, other.Cost)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(CostPerKilometer, other.CostPerKilometer)) return false;
      if (!object.Equals(DistanceLimit, other.DistanceLimit)) return false;
      if (!object.Equals(Delay, other.Delay)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (SrcTag.Length != 0) hash ^= SrcTag.GetHashCode();
      if (ExcludedSrcTag.Length != 0) hash ^= ExcludedSrcTag.GetHashCode();
      if (DstTag.Length != 0) hash ^= DstTag.GetHashCode();
      if (ExcludedDstTag.Length != 0) hash ^= ExcludedDstTag.GetHashCode();
      if (Cost != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Cost);
      if (CostPerKilometer != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(CostPerKilometer);
      if (distanceLimit_ != null) hash ^= DistanceLimit.GetHashCode();
      if (delay_ != null) hash ^= Delay.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (SrcTag.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(SrcTag);
      }
      if (ExcludedSrcTag.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ExcludedSrcTag);
      }
      if (DstTag.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(DstTag);
      }
      if (ExcludedDstTag.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(ExcludedDstTag);
      }
      if (Cost != 0D) {
        output.WriteRawTag(41);
        output.WriteDouble(Cost);
      }
      if (CostPerKilometer != 0D) {
        output.WriteRawTag(49);
        output.WriteDouble(CostPerKilometer);
      }
      if (distanceLimit_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(DistanceLimit);
      }
      if (delay_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Delay);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (SrcTag.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(SrcTag);
      }
      if (ExcludedSrcTag.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ExcludedSrcTag);
      }
      if (DstTag.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(DstTag);
      }
      if (ExcludedDstTag.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(ExcludedDstTag);
      }
      if (Cost != 0D) {
        output.WriteRawTag(41);
        output.WriteDouble(Cost);
      }
      if (CostPerKilometer != 0D) {
        output.WriteRawTag(49);
        output.WriteDouble(CostPerKilometer);
      }
      if (distanceLimit_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(DistanceLimit);
      }
      if (delay_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Delay);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (SrcTag.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SrcTag);
      }
      if (ExcludedSrcTag.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ExcludedSrcTag);
      }
      if (DstTag.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DstTag);
      }
      if (ExcludedDstTag.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ExcludedDstTag);
      }
      if (Cost != 0D) {
        size += 1 + 8;
      }
      if (CostPerKilometer != 0D) {
        size += 1 + 8;
      }
      if (distanceLimit_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DistanceLimit);
      }
      if (delay_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Delay);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TransitionAttributes other) {
      if (other == null) {
        return;
      }
      if (other.SrcTag.Length != 0) {
        SrcTag = other.SrcTag;
      }
      if (other.ExcludedSrcTag.Length != 0) {
        ExcludedSrcTag = other.ExcludedSrcTag;
      }
      if (other.DstTag.Length != 0) {
        DstTag = other.DstTag;
      }
      if (other.ExcludedDstTag.Length != 0) {
        ExcludedDstTag = other.ExcludedDstTag;
      }
      if (other.Cost != 0D) {
        Cost = other.Cost;
      }
      if (other.CostPerKilometer != 0D) {
        CostPerKilometer = other.CostPerKilometer;
      }
      if (other.distanceLimit_ != null) {
        if (distanceLimit_ == null) {
          DistanceLimit = new global::Google.Maps.RouteOptimization.V1.DistanceLimit();
        }
        DistanceLimit.MergeFrom(other.DistanceLimit);
      }
      if (other.delay_ != null) {
        if (delay_ == null) {
          Delay = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Delay.MergeFrom(other.Delay);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            SrcTag = input.ReadString();
            break;
          }
          case 18: {
            ExcludedSrcTag = input.ReadString();
            break;
          }
          case 26: {
            DstTag = input.ReadString();
            break;
          }
          case 34: {
            ExcludedDstTag = input.ReadString();
            break;
          }
          case 41: {
            Cost = input.ReadDouble();
            break;
          }
          case 49: {
            CostPerKilometer = input.ReadDouble();
            break;
          }
          case 58: {
            if (distanceLimit_ == null) {
              DistanceLimit = new global::Google.Maps.RouteOptimization.V1.DistanceLimit();
            }
            input.ReadMessage(DistanceLimit);
            break;
          }
          case 66: {
            if (delay_ == null) {
              Delay = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Delay);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            SrcTag = input.ReadString();
            break;
          }
          case 18: {
            ExcludedSrcTag = input.ReadString();
            break;
          }
          case 26: {
            DstTag = input.ReadString();
            break;
          }
          case 34: {
            ExcludedDstTag = input.ReadString();
            break;
          }
          case 41: {
            Cost = input.ReadDouble();
            break;
          }
          case 49: {
            CostPerKilometer = input.ReadDouble();
            break;
          }
          case 58: {
            if (distanceLimit_ == null) {
              DistanceLimit = new global::Google.Maps.RouteOptimization.V1.DistanceLimit();
            }
            input.ReadMessage(DistanceLimit);
            break;
          }
          case 66: {
            if (delay_ == null) {
              Delay = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Delay);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Encapsulates a waypoint. Waypoints mark arrival and departure locations of
  /// VisitRequests, and start and end locations of Vehicles.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Waypoint : pb::IMessage<Waypoint>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Waypoint> _parser = new pb::MessageParser<Waypoint>(() => new Waypoint());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Waypoint> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Waypoint() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Waypoint(Waypoint other) : this() {
      sideOfRoad_ = other.sideOfRoad_;
      switch (other.LocationTypeCase) {
        case LocationTypeOneofCase.Location:
          Location = other.Location.Clone();
          break;
        case LocationTypeOneofCase.PlaceId:
          PlaceId = other.PlaceId;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Waypoint Clone() {
      return new Waypoint(this);
    }

    /// <summary>Field number for the "location" field.</summary>
    public const int LocationFieldNumber = 1;
    /// <summary>
    /// A point specified using geographic coordinates, including an optional
    /// heading.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.Location Location {
      get { return locationTypeCase_ == LocationTypeOneofCase.Location ? (global::Google.Maps.RouteOptimization.V1.Location) locationType_ : null; }
      set {
        locationType_ = value;
        locationTypeCase_ = value == null ? LocationTypeOneofCase.None : LocationTypeOneofCase.Location;
      }
    }

    /// <summary>Field number for the "place_id" field.</summary>
    public const int PlaceIdFieldNumber = 2;
    /// <summary>
    /// The POI Place ID associated with the waypoint.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string PlaceId {
      get { return HasPlaceId ? (string) locationType_ : ""; }
      set {
        locationType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        locationTypeCase_ = LocationTypeOneofCase.PlaceId;
      }
    }
    /// <summary>Gets whether the "place_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPlaceId {
      get { return locationTypeCase_ == LocationTypeOneofCase.PlaceId; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "place_id" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPlaceId() {
      if (HasPlaceId) {
        ClearLocationType();
      }
    }

    /// <summary>Field number for the "side_of_road" field.</summary>
    public const int SideOfRoadFieldNumber = 3;
    private bool sideOfRoad_;
    /// <summary>
    /// Optional. Indicates that the location of this waypoint is meant to have a
    /// preference for the vehicle to stop at a particular side of road. When you
    /// set this value, the route will pass through the location so that the
    /// vehicle can stop at the side of road that the location is biased towards
    /// from the center of the road. This option doesn't work for the 'WALKING'
    /// travel mode.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool SideOfRoad {
      get { return sideOfRoad_; }
      set {
        sideOfRoad_ = value;
      }
    }

    private object locationType_;
    /// <summary>Enum of possible cases for the "location_type" oneof.</summary>
    public enum LocationTypeOneofCase {
      None = 0,
      Location = 1,
      PlaceId = 2,
    }
    private LocationTypeOneofCase locationTypeCase_ = LocationTypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LocationTypeOneofCase LocationTypeCase {
      get { return locationTypeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLocationType() {
      locationTypeCase_ = LocationTypeOneofCase.None;
      locationType_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Waypoint);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Waypoint other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Location, other.Location)) return false;
      if (PlaceId != other.PlaceId) return false;
      if (SideOfRoad != other.SideOfRoad) return false;
      if (LocationTypeCase != other.LocationTypeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (locationTypeCase_ == LocationTypeOneofCase.Location) hash ^= Location.GetHashCode();
      if (HasPlaceId) hash ^= PlaceId.GetHashCode();
      if (SideOfRoad != false) hash ^= SideOfRoad.GetHashCode();
      hash ^= (int) locationTypeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (locationTypeCase_ == LocationTypeOneofCase.Location) {
        output.WriteRawTag(10);
        output.WriteMessage(Location);
      }
      if (HasPlaceId) {
        output.WriteRawTag(18);
        output.WriteString(PlaceId);
      }
      if (SideOfRoad != false) {
        output.WriteRawTag(24);
        output.WriteBool(SideOfRoad);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (locationTypeCase_ == LocationTypeOneofCase.Location) {
        output.WriteRawTag(10);
        output.WriteMessage(Location);
      }
      if (HasPlaceId) {
        output.WriteRawTag(18);
        output.WriteString(PlaceId);
      }
      if (SideOfRoad != false) {
        output.WriteRawTag(24);
        output.WriteBool(SideOfRoad);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (locationTypeCase_ == LocationTypeOneofCase.Location) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Location);
      }
      if (HasPlaceId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PlaceId);
      }
      if (SideOfRoad != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Waypoint other) {
      if (other == null) {
        return;
      }
      if (other.SideOfRoad != false) {
        SideOfRoad = other.SideOfRoad;
      }
      switch (other.LocationTypeCase) {
        case LocationTypeOneofCase.Location:
          if (Location == null) {
            Location = new global::Google.Maps.RouteOptimization.V1.Location();
          }
          Location.MergeFrom(other.Location);
          break;
        case LocationTypeOneofCase.PlaceId:
          PlaceId = other.PlaceId;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Google.Maps.RouteOptimization.V1.Location subBuilder = new global::Google.Maps.RouteOptimization.V1.Location();
            if (locationTypeCase_ == LocationTypeOneofCase.Location) {
              subBuilder.MergeFrom(Location);
            }
            input.ReadMessage(subBuilder);
            Location = subBuilder;
            break;
          }
          case 18: {
            PlaceId = input.ReadString();
            break;
          }
          case 24: {
            SideOfRoad = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::Google.Maps.RouteOptimization.V1.Location subBuilder = new global::Google.Maps.RouteOptimization.V1.Location();
            if (locationTypeCase_ == LocationTypeOneofCase.Location) {
              subBuilder.MergeFrom(Location);
            }
            input.ReadMessage(subBuilder);
            Location = subBuilder;
            break;
          }
          case 18: {
            PlaceId = input.ReadString();
            break;
          }
          case 24: {
            SideOfRoad = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Encapsulates a location (a geographic point, and an optional heading).
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Location : pb::IMessage<Location>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Location> _parser = new pb::MessageParser<Location>(() => new Location());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Location> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Location() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Location(Location other) : this() {
      _hasBits0 = other._hasBits0;
      latLng_ = other.latLng_ != null ? other.latLng_.Clone() : null;
      heading_ = other.heading_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Location Clone() {
      return new Location(this);
    }

    /// <summary>Field number for the "lat_lng" field.</summary>
    public const int LatLngFieldNumber = 1;
    private global::Google.Type.LatLng latLng_;
    /// <summary>
    /// The waypoint's geographic coordinates.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Type.LatLng LatLng {
      get { return latLng_; }
      set {
        latLng_ = value;
      }
    }

    /// <summary>Field number for the "heading" field.</summary>
    public const int HeadingFieldNumber = 2;
    private readonly static int HeadingDefaultValue = 0;

    private int heading_;
    /// <summary>
    /// The compass heading associated with the direction of the flow of traffic.
    /// This value is used to specify the side of the road to use for pickup and
    /// drop-off. Heading values can be from 0 to 360, where 0 specifies a heading
    /// of due North, 90 specifies a heading of due East, etc.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Heading {
      get { if ((_hasBits0 & 1) != 0) { return heading_; } else { return HeadingDefaultValue; } }
      set {
        _hasBits0 |= 1;
        heading_ = value;
      }
    }
    /// <summary>Gets whether the "heading" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHeading {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "heading" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHeading() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Location);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Location other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(LatLng, other.LatLng)) return false;
      if (Heading != other.Heading) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (latLng_ != null) hash ^= LatLng.GetHashCode();
      if (HasHeading) hash ^= Heading.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (latLng_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LatLng);
      }
      if (HasHeading) {
        output.WriteRawTag(16);
        output.WriteInt32(Heading);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (latLng_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LatLng);
      }
      if (HasHeading) {
        output.WriteRawTag(16);
        output.WriteInt32(Heading);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (latLng_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LatLng);
      }
      if (HasHeading) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Heading);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Location other) {
      if (other == null) {
        return;
      }
      if (other.latLng_ != null) {
        if (latLng_ == null) {
          LatLng = new global::Google.Type.LatLng();
        }
        LatLng.MergeFrom(other.LatLng);
      }
      if (other.HasHeading) {
        Heading = other.Heading;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (latLng_ == null) {
              LatLng = new global::Google.Type.LatLng();
            }
            input.ReadMessage(LatLng);
            break;
          }
          case 16: {
            Heading = input.ReadInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (latLng_ == null) {
              LatLng = new global::Google.Type.LatLng();
            }
            input.ReadMessage(LatLng);
            break;
          }
          case 16: {
            Heading = input.ReadInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Rules to generate time breaks for a vehicle (e.g. lunch breaks). A break
  /// is a contiguous period of time during which the vehicle remains idle at its
  /// current position and cannot perform any visit. A break may occur:
  ///
  /// * during the travel between two visits (which includes the time right
  ///   before or right after a visit, but not in the middle of a visit), in
  ///   which case it extends the corresponding transit time between the visits,
  /// * or before the vehicle start (the vehicle may not start in the middle of
  ///   a break), in which case it does not affect the vehicle start time.
  /// * or after the vehicle end (ditto, with the vehicle end time).
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class BreakRule : pb::IMessage<BreakRule>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<BreakRule> _parser = new pb::MessageParser<BreakRule>(() => new BreakRule());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<BreakRule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BreakRule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BreakRule(BreakRule other) : this() {
      breakRequests_ = other.breakRequests_.Clone();
      frequencyConstraints_ = other.frequencyConstraints_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BreakRule Clone() {
      return new BreakRule(this);
    }

    /// <summary>Field number for the "break_requests" field.</summary>
    public const int BreakRequestsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.BreakRule.Types.BreakRequest> _repeated_breakRequests_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Maps.RouteOptimization.V1.BreakRule.Types.BreakRequest.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.BreakRule.Types.BreakRequest> breakRequests_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.BreakRule.Types.BreakRequest>();
    /// <summary>
    /// Sequence of breaks. See the `BreakRequest` message.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.BreakRule.Types.BreakRequest> BreakRequests {
      get { return breakRequests_; }
    }

    /// <summary>Field number for the "frequency_constraints" field.</summary>
    public const int FrequencyConstraintsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.BreakRule.Types.FrequencyConstraint> _repeated_frequencyConstraints_codec
        = pb::FieldCodec.ForMessage(18, global::Google.Maps.RouteOptimization.V1.BreakRule.Types.FrequencyConstraint.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.BreakRule.Types.FrequencyConstraint> frequencyConstraints_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.BreakRule.Types.FrequencyConstraint>();
    /// <summary>
    /// Several `FrequencyConstraint` may apply. They must all be satisfied by
    /// the `BreakRequest`s of this `BreakRule`. See `FrequencyConstraint`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.BreakRule.Types.FrequencyConstraint> FrequencyConstraints {
      get { return frequencyConstraints_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as BreakRule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(BreakRule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!breakRequests_.Equals(other.breakRequests_)) return false;
      if(!frequencyConstraints_.Equals(other.frequencyConstraints_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= breakRequests_.GetHashCode();
      hash ^= frequencyConstraints_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      breakRequests_.WriteTo(output, _repeated_breakRequests_codec);
      frequencyConstraints_.WriteTo(output, _repeated_frequencyConstraints_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      breakRequests_.WriteTo(ref output, _repeated_breakRequests_codec);
      frequencyConstraints_.WriteTo(ref output, _repeated_frequencyConstraints_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += breakRequests_.CalculateSize(_repeated_breakRequests_codec);
      size += frequencyConstraints_.CalculateSize(_repeated_frequencyConstraints_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(BreakRule other) {
      if (other == null) {
        return;
      }
      breakRequests_.Add(other.breakRequests_);
      frequencyConstraints_.Add(other.frequencyConstraints_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            breakRequests_.AddEntriesFrom(input, _repeated_breakRequests_codec);
            break;
          }
          case 18: {
            frequencyConstraints_.AddEntriesFrom(input, _repeated_frequencyConstraints_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            breakRequests_.AddEntriesFrom(ref input, _repeated_breakRequests_codec);
            break;
          }
          case 18: {
            frequencyConstraints_.AddEntriesFrom(ref input, _repeated_frequencyConstraints_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the BreakRule message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// The sequence of breaks (i.e. their number and order) that apply to each
      /// vehicle must be known beforehand. The repeated `BreakRequest`s define
      /// that sequence, in the order in which they must occur. Their time windows
      /// (`earliest_start_time` / `latest_start_time`) may overlap, but they must
      /// be compatible with the order (this is checked).
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class BreakRequest : pb::IMessage<BreakRequest>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<BreakRequest> _parser = new pb::MessageParser<BreakRequest>(() => new BreakRequest());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<BreakRequest> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.RouteOptimization.V1.BreakRule.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public BreakRequest() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public BreakRequest(BreakRequest other) : this() {
          earliestStartTime_ = other.earliestStartTime_ != null ? other.earliestStartTime_.Clone() : null;
          latestStartTime_ = other.latestStartTime_ != null ? other.latestStartTime_.Clone() : null;
          minDuration_ = other.minDuration_ != null ? other.minDuration_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public BreakRequest Clone() {
          return new BreakRequest(this);
        }

        /// <summary>Field number for the "earliest_start_time" field.</summary>
        public const int EarliestStartTimeFieldNumber = 1;
        private global::Google.Protobuf.WellKnownTypes.Timestamp earliestStartTime_;
        /// <summary>
        /// Required. Lower bound (inclusive) on the start of the break.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Timestamp EarliestStartTime {
          get { return earliestStartTime_; }
          set {
            earliestStartTime_ = value;
          }
        }

        /// <summary>Field number for the "latest_start_time" field.</summary>
        public const int LatestStartTimeFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Timestamp latestStartTime_;
        /// <summary>
        /// Required. Upper bound (inclusive) on the start of the break.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Timestamp LatestStartTime {
          get { return latestStartTime_; }
          set {
            latestStartTime_ = value;
          }
        }

        /// <summary>Field number for the "min_duration" field.</summary>
        public const int MinDurationFieldNumber = 3;
        private global::Google.Protobuf.WellKnownTypes.Duration minDuration_;
        /// <summary>
        /// Required. Minimum duration of the break. Must be positive.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration MinDuration {
          get { return minDuration_; }
          set {
            minDuration_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as BreakRequest);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(BreakRequest other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(EarliestStartTime, other.EarliestStartTime)) return false;
          if (!object.Equals(LatestStartTime, other.LatestStartTime)) return false;
          if (!object.Equals(MinDuration, other.MinDuration)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (earliestStartTime_ != null) hash ^= EarliestStartTime.GetHashCode();
          if (latestStartTime_ != null) hash ^= LatestStartTime.GetHashCode();
          if (minDuration_ != null) hash ^= MinDuration.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (earliestStartTime_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(EarliestStartTime);
          }
          if (latestStartTime_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(LatestStartTime);
          }
          if (minDuration_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(MinDuration);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (earliestStartTime_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(EarliestStartTime);
          }
          if (latestStartTime_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(LatestStartTime);
          }
          if (minDuration_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(MinDuration);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (earliestStartTime_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(EarliestStartTime);
          }
          if (latestStartTime_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(LatestStartTime);
          }
          if (minDuration_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(MinDuration);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(BreakRequest other) {
          if (other == null) {
            return;
          }
          if (other.earliestStartTime_ != null) {
            if (earliestStartTime_ == null) {
              EarliestStartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            EarliestStartTime.MergeFrom(other.EarliestStartTime);
          }
          if (other.latestStartTime_ != null) {
            if (latestStartTime_ == null) {
              LatestStartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            LatestStartTime.MergeFrom(other.LatestStartTime);
          }
          if (other.minDuration_ != null) {
            if (minDuration_ == null) {
              MinDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            MinDuration.MergeFrom(other.MinDuration);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (earliestStartTime_ == null) {
                  EarliestStartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(EarliestStartTime);
                break;
              }
              case 18: {
                if (latestStartTime_ == null) {
                  LatestStartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(LatestStartTime);
                break;
              }
              case 26: {
                if (minDuration_ == null) {
                  MinDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(MinDuration);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (earliestStartTime_ == null) {
                  EarliestStartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(EarliestStartTime);
                break;
              }
              case 18: {
                if (latestStartTime_ == null) {
                  LatestStartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(LatestStartTime);
                break;
              }
              case 26: {
                if (minDuration_ == null) {
                  MinDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(MinDuration);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// One may further constrain the frequency and duration of the breaks
      /// specified above, by enforcing a minimum break frequency, such as
      /// "There must be a break of at least 1 hour every 12 hours". Assuming that
      /// this can be interpreted as "Within any sliding time window of 12h, there
      /// must be at least one break of at least one hour", that example would
      /// translate to the following `FrequencyConstraint`:
      /// ```
      /// {
      ///    min_break_duration { seconds: 3600 }         # 1 hour.
      ///    max_inter_break_duration { seconds: 39600 }  # 11 hours (12 - 1 = 11).
      /// }
      /// ```
      ///
      /// The timing and duration of the breaks in the solution will respect all
      /// such constraints, in addition to the time windows and minimum durations
      /// already specified in the `BreakRequest`.
      ///
      /// A `FrequencyConstraint` may in practice apply to non-consecutive breaks.
      /// For example, the following schedule honors the "1h every 12h" example:
      /// ```
      ///   04:00 vehicle start
      ///    .. performing travel and visits ..
      ///   09:00 1 hour break
      ///   10:00 end of the break
      ///    .. performing travel and visits ..
      ///   12:00 20-min lunch break
      ///   12:20 end of the break
      ///    .. performing travel and visits ..
      ///   21:00 1 hour break
      ///   22:00 end of the break
      ///    .. performing travel and visits ..
      ///   23:59 vehicle end
      /// ```
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class FrequencyConstraint : pb::IMessage<FrequencyConstraint>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<FrequencyConstraint> _parser = new pb::MessageParser<FrequencyConstraint>(() => new FrequencyConstraint());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<FrequencyConstraint> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.RouteOptimization.V1.BreakRule.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public FrequencyConstraint() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public FrequencyConstraint(FrequencyConstraint other) : this() {
          minBreakDuration_ = other.minBreakDuration_ != null ? other.minBreakDuration_.Clone() : null;
          maxInterBreakDuration_ = other.maxInterBreakDuration_ != null ? other.maxInterBreakDuration_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public FrequencyConstraint Clone() {
          return new FrequencyConstraint(this);
        }

        /// <summary>Field number for the "min_break_duration" field.</summary>
        public const int MinBreakDurationFieldNumber = 1;
        private global::Google.Protobuf.WellKnownTypes.Duration minBreakDuration_;
        /// <summary>
        /// Required. Minimum break duration for this constraint. Nonnegative.
        /// See description of `FrequencyConstraint`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration MinBreakDuration {
          get { return minBreakDuration_; }
          set {
            minBreakDuration_ = value;
          }
        }

        /// <summary>Field number for the "max_inter_break_duration" field.</summary>
        public const int MaxInterBreakDurationFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Duration maxInterBreakDuration_;
        /// <summary>
        /// Required. Maximum allowed span of any interval of time in the route that
        /// does not include at least partially a break of `duration >=
        /// min_break_duration`. Must be positive.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration MaxInterBreakDuration {
          get { return maxInterBreakDuration_; }
          set {
            maxInterBreakDuration_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as FrequencyConstraint);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(FrequencyConstraint other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(MinBreakDuration, other.MinBreakDuration)) return false;
          if (!object.Equals(MaxInterBreakDuration, other.MaxInterBreakDuration)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (minBreakDuration_ != null) hash ^= MinBreakDuration.GetHashCode();
          if (maxInterBreakDuration_ != null) hash ^= MaxInterBreakDuration.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (minBreakDuration_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(MinBreakDuration);
          }
          if (maxInterBreakDuration_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(MaxInterBreakDuration);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (minBreakDuration_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(MinBreakDuration);
          }
          if (maxInterBreakDuration_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(MaxInterBreakDuration);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (minBreakDuration_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(MinBreakDuration);
          }
          if (maxInterBreakDuration_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaxInterBreakDuration);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(FrequencyConstraint other) {
          if (other == null) {
            return;
          }
          if (other.minBreakDuration_ != null) {
            if (minBreakDuration_ == null) {
              MinBreakDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            MinBreakDuration.MergeFrom(other.MinBreakDuration);
          }
          if (other.maxInterBreakDuration_ != null) {
            if (maxInterBreakDuration_ == null) {
              MaxInterBreakDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            MaxInterBreakDuration.MergeFrom(other.MaxInterBreakDuration);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (minBreakDuration_ == null) {
                  MinBreakDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(MinBreakDuration);
                break;
              }
              case 18: {
                if (maxInterBreakDuration_ == null) {
                  MaxInterBreakDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(MaxInterBreakDuration);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (minBreakDuration_ == null) {
                  MinBreakDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(MinBreakDuration);
                break;
              }
              case 18: {
                if (maxInterBreakDuration_ == null) {
                  MaxInterBreakDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(MaxInterBreakDuration);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// A vehicle's route can be decomposed, along the time axis, like this (we
  /// assume there are n visits):
  /// ```
  ///   |            |            |          |       |  T[2], |        |      |
  ///   | Transition |  Visit #0  |          |       |  V[2], |        |      |
  ///   |     #0     |    aka     |   T[1]   |  V[1] |  ...   | V[n-1] | T[n] |
  ///   |  aka T[0]  |    V[0]    |          |       | V[n-2],|        |      |
  ///   |            |            |          |       | T[n-1] |        |      |
  ///   ^            ^            ^          ^       ^        ^        ^      ^
  /// vehicle    V[0].start   V[0].end     V[1].   V[1].    V[n].    V[n]. vehicle
  ///  start     (arrival)   (departure)   start   end      start    end     end
  /// ```
  /// Note that we make a difference between:
  ///
  /// * "punctual events", such as the vehicle start and end and each visit's start
  ///   and end (aka arrival and departure). They happen at a given second.
  /// * "time intervals", such as the visits themselves, and the transition between
  ///   visits. Though time intervals can sometimes have zero duration, i.e. start
  ///   and end at the same second, they often have a positive duration.
  ///
  /// Invariants:
  ///
  /// * If there are n visits, there are n+1 transitions.
  /// * A visit is always surrounded by a transition before it (same index) and a
  ///   transition after it (index + 1).
  /// * The vehicle start is always followed by transition #0.
  /// * The vehicle end is always preceded by transition #n.
  ///
  /// Zooming in, here is what happens during a `Transition` and a `Visit`:
  /// ```
  /// ---+-------------------------------------+-----------------------------+-->
  ///    |           TRANSITION[i]             |           VISIT[i]          |
  ///    |                                     |                             |
  ///    |  * TRAVEL: the vehicle moves from   |      PERFORM the visit:     |
  ///    |    VISIT[i-1].departure_location to |                             |
  ///    |    VISIT[i].arrival_location, which |  * Spend some time:         |
  ///    |    takes a given travel duration    |    the "visit duration".    |
  ///    |    and distance                     |                             |
  ///    |                                     |  * Load or unload           |
  ///    |  * BREAKS: the driver may have      |    some quantities from the |
  ///    |    breaks (e.g. lunch break).       |    vehicle: the "demand".   |
  ///    |                                     |                             |
  ///    |  * WAIT: the driver/vehicle does    |                             |
  ///    |    nothing. This can happen for     |                             |
  ///    |    many reasons, for example when   |                             |
  ///    |    the vehicle reaches the next     |                             |
  ///    |    event's destination before the   |                             |
  ///    |    start of its time window         |                             |
  ///    |                                     |                             |
  ///    |  * DELAY: *right before* the next   |                             |
  ///    |    arrival. E.g. the vehicle and/or |                             |
  ///    |    driver spends time unloading.    |                             |
  ///    |                                     |                             |
  /// ---+-------------------------------------+-----------------------------+-->
  ///    ^                                     ^                             ^
  /// V[i-1].end                           V[i].start                    V[i].end
  /// ```
  /// Lastly, here is how the TRAVEL, BREAKS, DELAY and WAIT can be arranged
  /// during a transition.
  ///
  /// * They don't overlap.
  /// * The DELAY is unique and *must* be a contiguous period of time right
  ///   before the next visit (or vehicle end). Thus, it suffice to know the
  ///   delay duration to know its start and end time.
  /// * The BREAKS are contiguous, non-overlapping periods of time. The
  ///   response specifies the start time and duration of each break.
  /// * TRAVEL and WAIT are "preemptable": they can be interrupted several times
  ///   during this transition. Clients can assume that travel happens "as soon as
  ///   possible" and that "wait" fills the remaining time.
  ///
  /// A (complex) example:
  /// ```
  ///                                TRANSITION[i]
  /// --++-----+-----------------------------------------------------------++-->
  ///   ||     |       |           |       |           |         |         ||
  ///   ||  T  |   B   |     T     |       |     B     |         |    D    ||
  ///   ||  r  |   r   |     r     |   W   |     r     |    W    |    e    ||
  ///   ||  a  |   e   |     a     |   a   |     e     |    a    |    l    ||
  ///   ||  v  |   a   |     v     |   i   |     a     |    i    |    a    ||
  ///   ||  e  |   k   |     e     |   t   |     k     |    t    |    y    ||
  ///   ||  l  |       |     l     |       |           |         |         ||
  ///   ||     |       |           |       |           |         |         ||
  /// --++-----------------------------------------------------------------++-->
  /// ```
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ShipmentRoute : pb::IMessage<ShipmentRoute>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ShipmentRoute> _parser = new pb::MessageParser<ShipmentRoute>(() => new ShipmentRoute());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ShipmentRoute> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ShipmentRoute() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ShipmentRoute(ShipmentRoute other) : this() {
      vehicleIndex_ = other.vehicleIndex_;
      vehicleLabel_ = other.vehicleLabel_;
      vehicleStartTime_ = other.vehicleStartTime_ != null ? other.vehicleStartTime_.Clone() : null;
      vehicleEndTime_ = other.vehicleEndTime_ != null ? other.vehicleEndTime_.Clone() : null;
      visits_ = other.visits_.Clone();
      transitions_ = other.transitions_.Clone();
      hasTrafficInfeasibilities_ = other.hasTrafficInfeasibilities_;
      routePolyline_ = other.routePolyline_ != null ? other.routePolyline_.Clone() : null;
      breaks_ = other.breaks_.Clone();
      metrics_ = other.metrics_ != null ? other.metrics_.Clone() : null;
      routeCosts_ = other.routeCosts_.Clone();
      routeTotalCost_ = other.routeTotalCost_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ShipmentRoute Clone() {
      return new ShipmentRoute(this);
    }

    /// <summary>Field number for the "vehicle_index" field.</summary>
    public const int VehicleIndexFieldNumber = 1;
    private int vehicleIndex_;
    /// <summary>
    /// Vehicle performing the route, identified by its index in the source
    /// `ShipmentModel`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int VehicleIndex {
      get { return vehicleIndex_; }
      set {
        vehicleIndex_ = value;
      }
    }

    /// <summary>Field number for the "vehicle_label" field.</summary>
    public const int VehicleLabelFieldNumber = 2;
    private string vehicleLabel_ = "";
    /// <summary>
    /// Label of the vehicle performing this route, equal to
    /// `ShipmentModel.vehicles(vehicle_index).label`, if specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string VehicleLabel {
      get { return vehicleLabel_; }
      set {
        vehicleLabel_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "vehicle_start_time" field.</summary>
    public const int VehicleStartTimeFieldNumber = 5;
    private global::Google.Protobuf.WellKnownTypes.Timestamp vehicleStartTime_;
    /// <summary>
    /// Time at which the vehicle starts its route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp VehicleStartTime {
      get { return vehicleStartTime_; }
      set {
        vehicleStartTime_ = value;
      }
    }

    /// <summary>Field number for the "vehicle_end_time" field.</summary>
    public const int VehicleEndTimeFieldNumber = 6;
    private global::Google.Protobuf.WellKnownTypes.Timestamp vehicleEndTime_;
    /// <summary>
    /// Time at which the vehicle finishes its route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp VehicleEndTime {
      get { return vehicleEndTime_; }
      set {
        vehicleEndTime_ = value;
      }
    }

    /// <summary>Field number for the "visits" field.</summary>
    public const int VisitsFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.Visit> _repeated_visits_codec
        = pb::FieldCodec.ForMessage(58, global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.Visit.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.Visit> visits_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.Visit>();
    /// <summary>
    /// Ordered sequence of visits representing a route.
    /// visits[i] is the i-th visit in the route.
    /// If this field is empty, the vehicle is considered as unused.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.Visit> Visits {
      get { return visits_; }
    }

    /// <summary>Field number for the "transitions" field.</summary>
    public const int TransitionsFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.Transition> _repeated_transitions_codec
        = pb::FieldCodec.ForMessage(66, global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.Transition.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.Transition> transitions_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.Transition>();
    /// <summary>
    /// Ordered list of transitions for the route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.Transition> Transitions {
      get { return transitions_; }
    }

    /// <summary>Field number for the "has_traffic_infeasibilities" field.</summary>
    public const int HasTrafficInfeasibilitiesFieldNumber = 9;
    private bool hasTrafficInfeasibilities_;
    /// <summary>
    /// When
    /// [OptimizeToursRequest.consider_road_traffic][google.maps.routeoptimization.v1.OptimizeToursRequest.consider_road_traffic],
    /// is set to true, this field indicates that inconsistencies in route timings
    /// are predicted using traffic-based travel duration estimates. There may be
    /// insufficient time to complete traffic-adjusted travel, delays, and breaks
    /// between visits, before the first visit, or after the last visit, while
    /// still satisfying the visit and vehicle time windows. For example,
    ///
    /// ```
    ///   start_time(previous_visit) + duration(previous_visit) +
    ///   travel_duration(previous_visit, next_visit) > start_time(next_visit)
    /// ```
    ///
    /// Arrival at next_visit will likely happen later than its current
    /// time window due the increased estimate of travel time
    /// `travel_duration(previous_visit, next_visit)` due to traffic. Also, a break
    /// may be forced to overlap with a visit due to an increase in travel time
    /// estimates and visit or break time window restrictions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTrafficInfeasibilities {
      get { return hasTrafficInfeasibilities_; }
      set {
        hasTrafficInfeasibilities_ = value;
      }
    }

    /// <summary>Field number for the "route_polyline" field.</summary>
    public const int RoutePolylineFieldNumber = 10;
    private global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.EncodedPolyline routePolyline_;
    /// <summary>
    /// The encoded polyline representation of the route.
    /// This field is only populated if
    /// [OptimizeToursRequest.populate_polylines][google.maps.routeoptimization.v1.OptimizeToursRequest.populate_polylines]
    /// is set to true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.EncodedPolyline RoutePolyline {
      get { return routePolyline_; }
      set {
        routePolyline_ = value;
      }
    }

    /// <summary>Field number for the "breaks" field.</summary>
    public const int BreaksFieldNumber = 11;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.Break> _repeated_breaks_codec
        = pb::FieldCodec.ForMessage(90, global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.Break.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.Break> breaks_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.Break>();
    /// <summary>
    /// Breaks scheduled for the vehicle performing this route.
    /// The `breaks` sequence represents time intervals, each starting at the
    /// corresponding `start_time` and lasting `duration` seconds.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.Break> Breaks {
      get { return breaks_; }
    }

    /// <summary>Field number for the "metrics" field.</summary>
    public const int MetricsFieldNumber = 12;
    private global::Google.Maps.RouteOptimization.V1.AggregatedMetrics metrics_;
    /// <summary>
    /// Duration, distance and load metrics for this route. The fields of
    /// [AggregatedMetrics][google.maps.routeoptimization.v1.AggregatedMetrics] are
    /// summed over all
    /// [ShipmentRoute.transitions][google.maps.routeoptimization.v1.ShipmentRoute.transitions]
    /// or
    /// [ShipmentRoute.visits][google.maps.routeoptimization.v1.ShipmentRoute.visits],
    /// depending on the context.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.AggregatedMetrics Metrics {
      get { return metrics_; }
      set {
        metrics_ = value;
      }
    }

    /// <summary>Field number for the "route_costs" field.</summary>
    public const int RouteCostsFieldNumber = 17;
    private static readonly pbc::MapField<string, double>.Codec _map_routeCosts_codec
        = new pbc::MapField<string, double>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForDouble(17, 0D), 138);
    private readonly pbc::MapField<string, double> routeCosts_ = new pbc::MapField<string, double>();
    /// <summary>
    /// Cost of the route, broken down by cost-related request fields.
    /// The keys are proto paths, relative to the input OptimizeToursRequest, e.g.
    /// "model.shipments.pickups.cost", and the values are the total cost
    /// generated by the corresponding cost field, aggregated over the whole route.
    /// In other words, costs["model.shipments.pickups.cost"] is the sum of all
    /// pickup costs over the route. All costs defined in the model are reported in
    /// detail here with the exception of costs related to TransitionAttributes
    /// that are only reported in an aggregated way as of 2022/01.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, double> RouteCosts {
      get { return routeCosts_; }
    }

    /// <summary>Field number for the "route_total_cost" field.</summary>
    public const int RouteTotalCostFieldNumber = 18;
    private double routeTotalCost_;
    /// <summary>
    /// Total cost of the route. The sum of all costs in the cost map.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double RouteTotalCost {
      get { return routeTotalCost_; }
      set {
        routeTotalCost_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ShipmentRoute);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ShipmentRoute other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (VehicleIndex != other.VehicleIndex) return false;
      if (VehicleLabel != other.VehicleLabel) return false;
      if (!object.Equals(VehicleStartTime, other.VehicleStartTime)) return false;
      if (!object.Equals(VehicleEndTime, other.VehicleEndTime)) return false;
      if(!visits_.Equals(other.visits_)) return false;
      if(!transitions_.Equals(other.transitions_)) return false;
      if (HasTrafficInfeasibilities != other.HasTrafficInfeasibilities) return false;
      if (!object.Equals(RoutePolyline, other.RoutePolyline)) return false;
      if(!breaks_.Equals(other.breaks_)) return false;
      if (!object.Equals(Metrics, other.Metrics)) return false;
      if (!RouteCosts.Equals(other.RouteCosts)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(RouteTotalCost, other.RouteTotalCost)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (VehicleIndex != 0) hash ^= VehicleIndex.GetHashCode();
      if (VehicleLabel.Length != 0) hash ^= VehicleLabel.GetHashCode();
      if (vehicleStartTime_ != null) hash ^= VehicleStartTime.GetHashCode();
      if (vehicleEndTime_ != null) hash ^= VehicleEndTime.GetHashCode();
      hash ^= visits_.GetHashCode();
      hash ^= transitions_.GetHashCode();
      if (HasTrafficInfeasibilities != false) hash ^= HasTrafficInfeasibilities.GetHashCode();
      if (routePolyline_ != null) hash ^= RoutePolyline.GetHashCode();
      hash ^= breaks_.GetHashCode();
      if (metrics_ != null) hash ^= Metrics.GetHashCode();
      hash ^= RouteCosts.GetHashCode();
      if (RouteTotalCost != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(RouteTotalCost);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (VehicleIndex != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(VehicleIndex);
      }
      if (VehicleLabel.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(VehicleLabel);
      }
      if (vehicleStartTime_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(VehicleStartTime);
      }
      if (vehicleEndTime_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(VehicleEndTime);
      }
      visits_.WriteTo(output, _repeated_visits_codec);
      transitions_.WriteTo(output, _repeated_transitions_codec);
      if (HasTrafficInfeasibilities != false) {
        output.WriteRawTag(72);
        output.WriteBool(HasTrafficInfeasibilities);
      }
      if (routePolyline_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(RoutePolyline);
      }
      breaks_.WriteTo(output, _repeated_breaks_codec);
      if (metrics_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Metrics);
      }
      routeCosts_.WriteTo(output, _map_routeCosts_codec);
      if (RouteTotalCost != 0D) {
        output.WriteRawTag(145, 1);
        output.WriteDouble(RouteTotalCost);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (VehicleIndex != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(VehicleIndex);
      }
      if (VehicleLabel.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(VehicleLabel);
      }
      if (vehicleStartTime_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(VehicleStartTime);
      }
      if (vehicleEndTime_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(VehicleEndTime);
      }
      visits_.WriteTo(ref output, _repeated_visits_codec);
      transitions_.WriteTo(ref output, _repeated_transitions_codec);
      if (HasTrafficInfeasibilities != false) {
        output.WriteRawTag(72);
        output.WriteBool(HasTrafficInfeasibilities);
      }
      if (routePolyline_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(RoutePolyline);
      }
      breaks_.WriteTo(ref output, _repeated_breaks_codec);
      if (metrics_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Metrics);
      }
      routeCosts_.WriteTo(ref output, _map_routeCosts_codec);
      if (RouteTotalCost != 0D) {
        output.WriteRawTag(145, 1);
        output.WriteDouble(RouteTotalCost);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (VehicleIndex != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(VehicleIndex);
      }
      if (VehicleLabel.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VehicleLabel);
      }
      if (vehicleStartTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VehicleStartTime);
      }
      if (vehicleEndTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VehicleEndTime);
      }
      size += visits_.CalculateSize(_repeated_visits_codec);
      size += transitions_.CalculateSize(_repeated_transitions_codec);
      if (HasTrafficInfeasibilities != false) {
        size += 1 + 1;
      }
      if (routePolyline_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RoutePolyline);
      }
      size += breaks_.CalculateSize(_repeated_breaks_codec);
      if (metrics_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metrics);
      }
      size += routeCosts_.CalculateSize(_map_routeCosts_codec);
      if (RouteTotalCost != 0D) {
        size += 2 + 8;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ShipmentRoute other) {
      if (other == null) {
        return;
      }
      if (other.VehicleIndex != 0) {
        VehicleIndex = other.VehicleIndex;
      }
      if (other.VehicleLabel.Length != 0) {
        VehicleLabel = other.VehicleLabel;
      }
      if (other.vehicleStartTime_ != null) {
        if (vehicleStartTime_ == null) {
          VehicleStartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        VehicleStartTime.MergeFrom(other.VehicleStartTime);
      }
      if (other.vehicleEndTime_ != null) {
        if (vehicleEndTime_ == null) {
          VehicleEndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        VehicleEndTime.MergeFrom(other.VehicleEndTime);
      }
      visits_.Add(other.visits_);
      transitions_.Add(other.transitions_);
      if (other.HasTrafficInfeasibilities != false) {
        HasTrafficInfeasibilities = other.HasTrafficInfeasibilities;
      }
      if (other.routePolyline_ != null) {
        if (routePolyline_ == null) {
          RoutePolyline = new global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.EncodedPolyline();
        }
        RoutePolyline.MergeFrom(other.RoutePolyline);
      }
      breaks_.Add(other.breaks_);
      if (other.metrics_ != null) {
        if (metrics_ == null) {
          Metrics = new global::Google.Maps.RouteOptimization.V1.AggregatedMetrics();
        }
        Metrics.MergeFrom(other.Metrics);
      }
      routeCosts_.MergeFrom(other.routeCosts_);
      if (other.RouteTotalCost != 0D) {
        RouteTotalCost = other.RouteTotalCost;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            VehicleIndex = input.ReadInt32();
            break;
          }
          case 18: {
            VehicleLabel = input.ReadString();
            break;
          }
          case 42: {
            if (vehicleStartTime_ == null) {
              VehicleStartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(VehicleStartTime);
            break;
          }
          case 50: {
            if (vehicleEndTime_ == null) {
              VehicleEndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(VehicleEndTime);
            break;
          }
          case 58: {
            visits_.AddEntriesFrom(input, _repeated_visits_codec);
            break;
          }
          case 66: {
            transitions_.AddEntriesFrom(input, _repeated_transitions_codec);
            break;
          }
          case 72: {
            HasTrafficInfeasibilities = input.ReadBool();
            break;
          }
          case 82: {
            if (routePolyline_ == null) {
              RoutePolyline = new global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.EncodedPolyline();
            }
            input.ReadMessage(RoutePolyline);
            break;
          }
          case 90: {
            breaks_.AddEntriesFrom(input, _repeated_breaks_codec);
            break;
          }
          case 98: {
            if (metrics_ == null) {
              Metrics = new global::Google.Maps.RouteOptimization.V1.AggregatedMetrics();
            }
            input.ReadMessage(Metrics);
            break;
          }
          case 138: {
            routeCosts_.AddEntriesFrom(input, _map_routeCosts_codec);
            break;
          }
          case 145: {
            RouteTotalCost = input.ReadDouble();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            VehicleIndex = input.ReadInt32();
            break;
          }
          case 18: {
            VehicleLabel = input.ReadString();
            break;
          }
          case 42: {
            if (vehicleStartTime_ == null) {
              VehicleStartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(VehicleStartTime);
            break;
          }
          case 50: {
            if (vehicleEndTime_ == null) {
              VehicleEndTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(VehicleEndTime);
            break;
          }
          case 58: {
            visits_.AddEntriesFrom(ref input, _repeated_visits_codec);
            break;
          }
          case 66: {
            transitions_.AddEntriesFrom(ref input, _repeated_transitions_codec);
            break;
          }
          case 72: {
            HasTrafficInfeasibilities = input.ReadBool();
            break;
          }
          case 82: {
            if (routePolyline_ == null) {
              RoutePolyline = new global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.EncodedPolyline();
            }
            input.ReadMessage(RoutePolyline);
            break;
          }
          case 90: {
            breaks_.AddEntriesFrom(ref input, _repeated_breaks_codec);
            break;
          }
          case 98: {
            if (metrics_ == null) {
              Metrics = new global::Google.Maps.RouteOptimization.V1.AggregatedMetrics();
            }
            input.ReadMessage(Metrics);
            break;
          }
          case 138: {
            routeCosts_.AddEntriesFrom(ref input, _map_routeCosts_codec);
            break;
          }
          case 145: {
            RouteTotalCost = input.ReadDouble();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ShipmentRoute message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// A visit performed during a route. This visit corresponds to a pickup or a
      /// delivery of a `Shipment`.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class Visit : pb::IMessage<Visit>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Visit> _parser = new pb::MessageParser<Visit>(() => new Visit());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Visit> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Visit() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Visit(Visit other) : this() {
          shipmentIndex_ = other.shipmentIndex_;
          isPickup_ = other.isPickup_;
          visitRequestIndex_ = other.visitRequestIndex_;
          startTime_ = other.startTime_ != null ? other.startTime_.Clone() : null;
          loadDemands_ = other.loadDemands_.Clone();
          detour_ = other.detour_ != null ? other.detour_.Clone() : null;
          shipmentLabel_ = other.shipmentLabel_;
          visitLabel_ = other.visitLabel_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Visit Clone() {
          return new Visit(this);
        }

        /// <summary>Field number for the "shipment_index" field.</summary>
        public const int ShipmentIndexFieldNumber = 1;
        private int shipmentIndex_;
        /// <summary>
        /// Index of the `shipments` field in the source
        /// [ShipmentModel][google.maps.routeoptimization.v1.ShipmentModel].
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int ShipmentIndex {
          get { return shipmentIndex_; }
          set {
            shipmentIndex_ = value;
          }
        }

        /// <summary>Field number for the "is_pickup" field.</summary>
        public const int IsPickupFieldNumber = 2;
        private bool isPickup_;
        /// <summary>
        /// If true the visit corresponds to a pickup of a `Shipment`. Otherwise, it
        /// corresponds to a delivery.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool IsPickup {
          get { return isPickup_; }
          set {
            isPickup_ = value;
          }
        }

        /// <summary>Field number for the "visit_request_index" field.</summary>
        public const int VisitRequestIndexFieldNumber = 3;
        private int visitRequestIndex_;
        /// <summary>
        /// Index of `VisitRequest` in either the pickup or delivery field of the
        /// `Shipment` (see `is_pickup`).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int VisitRequestIndex {
          get { return visitRequestIndex_; }
          set {
            visitRequestIndex_ = value;
          }
        }

        /// <summary>Field number for the "start_time" field.</summary>
        public const int StartTimeFieldNumber = 4;
        private global::Google.Protobuf.WellKnownTypes.Timestamp startTime_;
        /// <summary>
        /// Time at which the visit starts. Note that the vehicle may arrive earlier
        /// than this at the visit location. Times are consistent with the
        /// `ShipmentModel`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Timestamp StartTime {
          get { return startTime_; }
          set {
            startTime_ = value;
          }
        }

        /// <summary>Field number for the "load_demands" field.</summary>
        public const int LoadDemandsFieldNumber = 11;
        private static readonly pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.Shipment.Types.Load>.Codec _map_loadDemands_codec
            = new pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.Shipment.Types.Load>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Google.Maps.RouteOptimization.V1.Shipment.Types.Load.Parser), 90);
        private readonly pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.Shipment.Types.Load> loadDemands_ = new pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.Shipment.Types.Load>();
        /// <summary>
        /// Total visit load demand as the sum of the shipment and the visit request
        /// `load_demands`. The values are negative if the visit is a delivery.
        /// Demands are reported for the same types as the
        /// [Transition.loads][google.maps.routeoptimization.v1.ShipmentRoute.Transition]
        /// (see this field).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.Shipment.Types.Load> LoadDemands {
          get { return loadDemands_; }
        }

        /// <summary>Field number for the "detour" field.</summary>
        public const int DetourFieldNumber = 6;
        private global::Google.Protobuf.WellKnownTypes.Duration detour_;
        /// <summary>
        /// Extra detour time due to the shipments visited on the route before the
        /// visit and to the potential waiting time induced by time windows.
        /// If the visit is a delivery, the detour is computed from the corresponding
        /// pickup visit and is equal to:
        /// ```
        /// start_time(delivery) - start_time(pickup)
        /// - (duration(pickup) + travel duration from the pickup location
        /// to the delivery location).
        /// ```
        /// Otherwise, it is computed from the vehicle `start_location` and is equal
        /// to:
        /// ```
        /// start_time - vehicle_start_time - travel duration from
        /// the vehicle's `start_location` to the visit.
        /// ```
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration Detour {
          get { return detour_; }
          set {
            detour_ = value;
          }
        }

        /// <summary>Field number for the "shipment_label" field.</summary>
        public const int ShipmentLabelFieldNumber = 7;
        private string shipmentLabel_ = "";
        /// <summary>
        /// Copy of the corresponding `Shipment.label`, if specified in the
        /// `Shipment`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string ShipmentLabel {
          get { return shipmentLabel_; }
          set {
            shipmentLabel_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "visit_label" field.</summary>
        public const int VisitLabelFieldNumber = 8;
        private string visitLabel_ = "";
        /// <summary>
        /// Copy of the corresponding
        /// [VisitRequest.label][google.maps.routeoptimization.v1.Shipment.VisitRequest.label],
        /// if specified in the `VisitRequest`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string VisitLabel {
          get { return visitLabel_; }
          set {
            visitLabel_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Visit);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Visit other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (ShipmentIndex != other.ShipmentIndex) return false;
          if (IsPickup != other.IsPickup) return false;
          if (VisitRequestIndex != other.VisitRequestIndex) return false;
          if (!object.Equals(StartTime, other.StartTime)) return false;
          if (!LoadDemands.Equals(other.LoadDemands)) return false;
          if (!object.Equals(Detour, other.Detour)) return false;
          if (ShipmentLabel != other.ShipmentLabel) return false;
          if (VisitLabel != other.VisitLabel) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (ShipmentIndex != 0) hash ^= ShipmentIndex.GetHashCode();
          if (IsPickup != false) hash ^= IsPickup.GetHashCode();
          if (VisitRequestIndex != 0) hash ^= VisitRequestIndex.GetHashCode();
          if (startTime_ != null) hash ^= StartTime.GetHashCode();
          hash ^= LoadDemands.GetHashCode();
          if (detour_ != null) hash ^= Detour.GetHashCode();
          if (ShipmentLabel.Length != 0) hash ^= ShipmentLabel.GetHashCode();
          if (VisitLabel.Length != 0) hash ^= VisitLabel.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (ShipmentIndex != 0) {
            output.WriteRawTag(8);
            output.WriteInt32(ShipmentIndex);
          }
          if (IsPickup != false) {
            output.WriteRawTag(16);
            output.WriteBool(IsPickup);
          }
          if (VisitRequestIndex != 0) {
            output.WriteRawTag(24);
            output.WriteInt32(VisitRequestIndex);
          }
          if (startTime_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(StartTime);
          }
          if (detour_ != null) {
            output.WriteRawTag(50);
            output.WriteMessage(Detour);
          }
          if (ShipmentLabel.Length != 0) {
            output.WriteRawTag(58);
            output.WriteString(ShipmentLabel);
          }
          if (VisitLabel.Length != 0) {
            output.WriteRawTag(66);
            output.WriteString(VisitLabel);
          }
          loadDemands_.WriteTo(output, _map_loadDemands_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (ShipmentIndex != 0) {
            output.WriteRawTag(8);
            output.WriteInt32(ShipmentIndex);
          }
          if (IsPickup != false) {
            output.WriteRawTag(16);
            output.WriteBool(IsPickup);
          }
          if (VisitRequestIndex != 0) {
            output.WriteRawTag(24);
            output.WriteInt32(VisitRequestIndex);
          }
          if (startTime_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(StartTime);
          }
          if (detour_ != null) {
            output.WriteRawTag(50);
            output.WriteMessage(Detour);
          }
          if (ShipmentLabel.Length != 0) {
            output.WriteRawTag(58);
            output.WriteString(ShipmentLabel);
          }
          if (VisitLabel.Length != 0) {
            output.WriteRawTag(66);
            output.WriteString(VisitLabel);
          }
          loadDemands_.WriteTo(ref output, _map_loadDemands_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (ShipmentIndex != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(ShipmentIndex);
          }
          if (IsPickup != false) {
            size += 1 + 1;
          }
          if (VisitRequestIndex != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(VisitRequestIndex);
          }
          if (startTime_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(StartTime);
          }
          size += loadDemands_.CalculateSize(_map_loadDemands_codec);
          if (detour_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Detour);
          }
          if (ShipmentLabel.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(ShipmentLabel);
          }
          if (VisitLabel.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(VisitLabel);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Visit other) {
          if (other == null) {
            return;
          }
          if (other.ShipmentIndex != 0) {
            ShipmentIndex = other.ShipmentIndex;
          }
          if (other.IsPickup != false) {
            IsPickup = other.IsPickup;
          }
          if (other.VisitRequestIndex != 0) {
            VisitRequestIndex = other.VisitRequestIndex;
          }
          if (other.startTime_ != null) {
            if (startTime_ == null) {
              StartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            StartTime.MergeFrom(other.StartTime);
          }
          loadDemands_.MergeFrom(other.loadDemands_);
          if (other.detour_ != null) {
            if (detour_ == null) {
              Detour = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            Detour.MergeFrom(other.Detour);
          }
          if (other.ShipmentLabel.Length != 0) {
            ShipmentLabel = other.ShipmentLabel;
          }
          if (other.VisitLabel.Length != 0) {
            VisitLabel = other.VisitLabel;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                ShipmentIndex = input.ReadInt32();
                break;
              }
              case 16: {
                IsPickup = input.ReadBool();
                break;
              }
              case 24: {
                VisitRequestIndex = input.ReadInt32();
                break;
              }
              case 34: {
                if (startTime_ == null) {
                  StartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(StartTime);
                break;
              }
              case 50: {
                if (detour_ == null) {
                  Detour = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(Detour);
                break;
              }
              case 58: {
                ShipmentLabel = input.ReadString();
                break;
              }
              case 66: {
                VisitLabel = input.ReadString();
                break;
              }
              case 90: {
                loadDemands_.AddEntriesFrom(input, _map_loadDemands_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                ShipmentIndex = input.ReadInt32();
                break;
              }
              case 16: {
                IsPickup = input.ReadBool();
                break;
              }
              case 24: {
                VisitRequestIndex = input.ReadInt32();
                break;
              }
              case 34: {
                if (startTime_ == null) {
                  StartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(StartTime);
                break;
              }
              case 50: {
                if (detour_ == null) {
                  Detour = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(Detour);
                break;
              }
              case 58: {
                ShipmentLabel = input.ReadString();
                break;
              }
              case 66: {
                VisitLabel = input.ReadString();
                break;
              }
              case 90: {
                loadDemands_.AddEntriesFrom(ref input, _map_loadDemands_codec);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Transition between two events on the route. See the description of
      /// [ShipmentRoute][google.maps.routeoptimization.v1.ShipmentRoute].
      ///
      /// If the vehicle does not have a `start_location` and/or `end_location`, the
      /// corresponding travel metrics are 0.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class Transition : pb::IMessage<Transition>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Transition> _parser = new pb::MessageParser<Transition>(() => new Transition());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Transition> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Transition() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Transition(Transition other) : this() {
          travelDuration_ = other.travelDuration_ != null ? other.travelDuration_.Clone() : null;
          travelDistanceMeters_ = other.travelDistanceMeters_;
          trafficInfoUnavailable_ = other.trafficInfoUnavailable_;
          delayDuration_ = other.delayDuration_ != null ? other.delayDuration_.Clone() : null;
          breakDuration_ = other.breakDuration_ != null ? other.breakDuration_.Clone() : null;
          waitDuration_ = other.waitDuration_ != null ? other.waitDuration_.Clone() : null;
          totalDuration_ = other.totalDuration_ != null ? other.totalDuration_.Clone() : null;
          startTime_ = other.startTime_ != null ? other.startTime_.Clone() : null;
          routePolyline_ = other.routePolyline_ != null ? other.routePolyline_.Clone() : null;
          routeToken_ = other.routeToken_;
          vehicleLoads_ = other.vehicleLoads_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Transition Clone() {
          return new Transition(this);
        }

        /// <summary>Field number for the "travel_duration" field.</summary>
        public const int TravelDurationFieldNumber = 1;
        private global::Google.Protobuf.WellKnownTypes.Duration travelDuration_;
        /// <summary>
        /// Travel duration during this transition.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration TravelDuration {
          get { return travelDuration_; }
          set {
            travelDuration_ = value;
          }
        }

        /// <summary>Field number for the "travel_distance_meters" field.</summary>
        public const int TravelDistanceMetersFieldNumber = 2;
        private double travelDistanceMeters_;
        /// <summary>
        /// Distance traveled during the transition.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public double TravelDistanceMeters {
          get { return travelDistanceMeters_; }
          set {
            travelDistanceMeters_ = value;
          }
        }

        /// <summary>Field number for the "traffic_info_unavailable" field.</summary>
        public const int TrafficInfoUnavailableFieldNumber = 3;
        private bool trafficInfoUnavailable_;
        /// <summary>
        /// When traffic is requested via
        /// [OptimizeToursRequest.consider_road_traffic]
        /// [google.maps.routeoptimization.v1.OptimizeToursRequest.consider_road_traffic],
        /// and the traffic info couldn't be retrieved for a `Transition`, this
        /// boolean is set to true. This may be temporary (rare hiccup in the
        /// realtime traffic servers) or permanent (no data for this location).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool TrafficInfoUnavailable {
          get { return trafficInfoUnavailable_; }
          set {
            trafficInfoUnavailable_ = value;
          }
        }

        /// <summary>Field number for the "delay_duration" field.</summary>
        public const int DelayDurationFieldNumber = 4;
        private global::Google.Protobuf.WellKnownTypes.Duration delayDuration_;
        /// <summary>
        /// Sum of the delay durations applied to this transition. If any, the delay
        /// starts exactly `delay_duration` seconds before the next event (visit or
        /// vehicle end). See
        /// [TransitionAttributes.delay][google.maps.routeoptimization.v1.TransitionAttributes.delay].
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration DelayDuration {
          get { return delayDuration_; }
          set {
            delayDuration_ = value;
          }
        }

        /// <summary>Field number for the "break_duration" field.</summary>
        public const int BreakDurationFieldNumber = 5;
        private global::Google.Protobuf.WellKnownTypes.Duration breakDuration_;
        /// <summary>
        /// Sum of the duration of the breaks occurring during this transition, if
        /// any. Details about each break's start time and duration are stored in
        /// [ShipmentRoute.breaks][google.maps.routeoptimization.v1.ShipmentRoute.breaks].
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration BreakDuration {
          get { return breakDuration_; }
          set {
            breakDuration_ = value;
          }
        }

        /// <summary>Field number for the "wait_duration" field.</summary>
        public const int WaitDurationFieldNumber = 6;
        private global::Google.Protobuf.WellKnownTypes.Duration waitDuration_;
        /// <summary>
        /// Time spent waiting during this transition. Wait duration corresponds to
        /// idle time and does not include break time. Also note that this wait time
        /// may be split into several non-contiguous intervals.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration WaitDuration {
          get { return waitDuration_; }
          set {
            waitDuration_ = value;
          }
        }

        /// <summary>Field number for the "total_duration" field.</summary>
        public const int TotalDurationFieldNumber = 7;
        private global::Google.Protobuf.WellKnownTypes.Duration totalDuration_;
        /// <summary>
        /// Total duration of the transition, provided for convenience. It is equal
        /// to:
        ///
        /// * next visit `start_time` (or `vehicle_end_time` if this is the last
        /// transition) - this transition's `start_time`;
        /// * if `ShipmentRoute.has_traffic_infeasibilities` is false, the following
        /// additionally holds: `total_duration = travel_duration + delay_duration
        /// + break_duration + wait_duration`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration TotalDuration {
          get { return totalDuration_; }
          set {
            totalDuration_ = value;
          }
        }

        /// <summary>Field number for the "start_time" field.</summary>
        public const int StartTimeFieldNumber = 8;
        private global::Google.Protobuf.WellKnownTypes.Timestamp startTime_;
        /// <summary>
        /// Start time of this transition.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Timestamp StartTime {
          get { return startTime_; }
          set {
            startTime_ = value;
          }
        }

        /// <summary>Field number for the "route_polyline" field.</summary>
        public const int RoutePolylineFieldNumber = 9;
        private global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.EncodedPolyline routePolyline_;
        /// <summary>
        /// The encoded polyline representation of the route followed during the
        /// transition.
        /// This field is only populated if [populate_transition_polylines]
        /// [google.maps.routeoptimization.v1.OptimizeToursRequest.populate_transition_polylines]
        /// is set to true.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.EncodedPolyline RoutePolyline {
          get { return routePolyline_; }
          set {
            routePolyline_ = value;
          }
        }

        /// <summary>Field number for the "route_token" field.</summary>
        public const int RouteTokenFieldNumber = 12;
        private string routeToken_ = "";
        /// <summary>
        /// Output only. An opaque token that can be passed to [Navigation
        /// SDK](https://developers.google.com/maps/documentation/navigation) to
        /// reconstruct the route during navigation, and, in the event of rerouting,
        /// honor the original intention when the route was created. Treat this token
        /// as an opaque blob.  Don't compare its value across requests as its value
        /// may change even if the service returns the exact same route. This field
        /// is only populated if [populate_transition_polylines]
        /// [google.maps.routeoptimization.v1.OptimizeToursRequest.populate_transition_polylines]
        /// is set to true.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string RouteToken {
          get { return routeToken_; }
          set {
            routeToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "vehicle_loads" field.</summary>
        public const int VehicleLoadsFieldNumber = 11;
        private static readonly pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.VehicleLoad>.Codec _map_vehicleLoads_codec
            = new pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.VehicleLoad>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.VehicleLoad.Parser), 90);
        private readonly pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.VehicleLoad> vehicleLoads_ = new pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.VehicleLoad>();
        /// <summary>
        /// Vehicle loads during this transition, for each type that either appears
        /// in this vehicle's
        /// [Vehicle.load_limits][google.maps.routeoptimization.v1.Vehicle.load_limits],
        /// or that have non-zero
        /// [Shipment.load_demands][google.maps.routeoptimization.v1.Shipment.load_demands]
        /// on some shipment performed on this route.
        ///
        /// The loads during the first transition are the starting loads of the
        /// vehicle route. Then, after each visit, the visit's `load_demands` are
        /// either added or subtracted to get the next transition's loads, depending
        /// on whether the visit was a pickup or a delivery.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.VehicleLoad> VehicleLoads {
          get { return vehicleLoads_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Transition);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Transition other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(TravelDuration, other.TravelDuration)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(TravelDistanceMeters, other.TravelDistanceMeters)) return false;
          if (TrafficInfoUnavailable != other.TrafficInfoUnavailable) return false;
          if (!object.Equals(DelayDuration, other.DelayDuration)) return false;
          if (!object.Equals(BreakDuration, other.BreakDuration)) return false;
          if (!object.Equals(WaitDuration, other.WaitDuration)) return false;
          if (!object.Equals(TotalDuration, other.TotalDuration)) return false;
          if (!object.Equals(StartTime, other.StartTime)) return false;
          if (!object.Equals(RoutePolyline, other.RoutePolyline)) return false;
          if (RouteToken != other.RouteToken) return false;
          if (!VehicleLoads.Equals(other.VehicleLoads)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (travelDuration_ != null) hash ^= TravelDuration.GetHashCode();
          if (TravelDistanceMeters != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(TravelDistanceMeters);
          if (TrafficInfoUnavailable != false) hash ^= TrafficInfoUnavailable.GetHashCode();
          if (delayDuration_ != null) hash ^= DelayDuration.GetHashCode();
          if (breakDuration_ != null) hash ^= BreakDuration.GetHashCode();
          if (waitDuration_ != null) hash ^= WaitDuration.GetHashCode();
          if (totalDuration_ != null) hash ^= TotalDuration.GetHashCode();
          if (startTime_ != null) hash ^= StartTime.GetHashCode();
          if (routePolyline_ != null) hash ^= RoutePolyline.GetHashCode();
          if (RouteToken.Length != 0) hash ^= RouteToken.GetHashCode();
          hash ^= VehicleLoads.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (travelDuration_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(TravelDuration);
          }
          if (TravelDistanceMeters != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(TravelDistanceMeters);
          }
          if (TrafficInfoUnavailable != false) {
            output.WriteRawTag(24);
            output.WriteBool(TrafficInfoUnavailable);
          }
          if (delayDuration_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(DelayDuration);
          }
          if (breakDuration_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(BreakDuration);
          }
          if (waitDuration_ != null) {
            output.WriteRawTag(50);
            output.WriteMessage(WaitDuration);
          }
          if (totalDuration_ != null) {
            output.WriteRawTag(58);
            output.WriteMessage(TotalDuration);
          }
          if (startTime_ != null) {
            output.WriteRawTag(66);
            output.WriteMessage(StartTime);
          }
          if (routePolyline_ != null) {
            output.WriteRawTag(74);
            output.WriteMessage(RoutePolyline);
          }
          vehicleLoads_.WriteTo(output, _map_vehicleLoads_codec);
          if (RouteToken.Length != 0) {
            output.WriteRawTag(98);
            output.WriteString(RouteToken);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (travelDuration_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(TravelDuration);
          }
          if (TravelDistanceMeters != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(TravelDistanceMeters);
          }
          if (TrafficInfoUnavailable != false) {
            output.WriteRawTag(24);
            output.WriteBool(TrafficInfoUnavailable);
          }
          if (delayDuration_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(DelayDuration);
          }
          if (breakDuration_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(BreakDuration);
          }
          if (waitDuration_ != null) {
            output.WriteRawTag(50);
            output.WriteMessage(WaitDuration);
          }
          if (totalDuration_ != null) {
            output.WriteRawTag(58);
            output.WriteMessage(TotalDuration);
          }
          if (startTime_ != null) {
            output.WriteRawTag(66);
            output.WriteMessage(StartTime);
          }
          if (routePolyline_ != null) {
            output.WriteRawTag(74);
            output.WriteMessage(RoutePolyline);
          }
          vehicleLoads_.WriteTo(ref output, _map_vehicleLoads_codec);
          if (RouteToken.Length != 0) {
            output.WriteRawTag(98);
            output.WriteString(RouteToken);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (travelDuration_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(TravelDuration);
          }
          if (TravelDistanceMeters != 0D) {
            size += 1 + 8;
          }
          if (TrafficInfoUnavailable != false) {
            size += 1 + 1;
          }
          if (delayDuration_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(DelayDuration);
          }
          if (breakDuration_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(BreakDuration);
          }
          if (waitDuration_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(WaitDuration);
          }
          if (totalDuration_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(TotalDuration);
          }
          if (startTime_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(StartTime);
          }
          if (routePolyline_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(RoutePolyline);
          }
          if (RouteToken.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(RouteToken);
          }
          size += vehicleLoads_.CalculateSize(_map_vehicleLoads_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Transition other) {
          if (other == null) {
            return;
          }
          if (other.travelDuration_ != null) {
            if (travelDuration_ == null) {
              TravelDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            TravelDuration.MergeFrom(other.TravelDuration);
          }
          if (other.TravelDistanceMeters != 0D) {
            TravelDistanceMeters = other.TravelDistanceMeters;
          }
          if (other.TrafficInfoUnavailable != false) {
            TrafficInfoUnavailable = other.TrafficInfoUnavailable;
          }
          if (other.delayDuration_ != null) {
            if (delayDuration_ == null) {
              DelayDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            DelayDuration.MergeFrom(other.DelayDuration);
          }
          if (other.breakDuration_ != null) {
            if (breakDuration_ == null) {
              BreakDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            BreakDuration.MergeFrom(other.BreakDuration);
          }
          if (other.waitDuration_ != null) {
            if (waitDuration_ == null) {
              WaitDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            WaitDuration.MergeFrom(other.WaitDuration);
          }
          if (other.totalDuration_ != null) {
            if (totalDuration_ == null) {
              TotalDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            TotalDuration.MergeFrom(other.TotalDuration);
          }
          if (other.startTime_ != null) {
            if (startTime_ == null) {
              StartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            StartTime.MergeFrom(other.StartTime);
          }
          if (other.routePolyline_ != null) {
            if (routePolyline_ == null) {
              RoutePolyline = new global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.EncodedPolyline();
            }
            RoutePolyline.MergeFrom(other.RoutePolyline);
          }
          if (other.RouteToken.Length != 0) {
            RouteToken = other.RouteToken;
          }
          vehicleLoads_.MergeFrom(other.vehicleLoads_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (travelDuration_ == null) {
                  TravelDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(TravelDuration);
                break;
              }
              case 17: {
                TravelDistanceMeters = input.ReadDouble();
                break;
              }
              case 24: {
                TrafficInfoUnavailable = input.ReadBool();
                break;
              }
              case 34: {
                if (delayDuration_ == null) {
                  DelayDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(DelayDuration);
                break;
              }
              case 42: {
                if (breakDuration_ == null) {
                  BreakDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(BreakDuration);
                break;
              }
              case 50: {
                if (waitDuration_ == null) {
                  WaitDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(WaitDuration);
                break;
              }
              case 58: {
                if (totalDuration_ == null) {
                  TotalDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(TotalDuration);
                break;
              }
              case 66: {
                if (startTime_ == null) {
                  StartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(StartTime);
                break;
              }
              case 74: {
                if (routePolyline_ == null) {
                  RoutePolyline = new global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.EncodedPolyline();
                }
                input.ReadMessage(RoutePolyline);
                break;
              }
              case 90: {
                vehicleLoads_.AddEntriesFrom(input, _map_vehicleLoads_codec);
                break;
              }
              case 98: {
                RouteToken = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (travelDuration_ == null) {
                  TravelDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(TravelDuration);
                break;
              }
              case 17: {
                TravelDistanceMeters = input.ReadDouble();
                break;
              }
              case 24: {
                TrafficInfoUnavailable = input.ReadBool();
                break;
              }
              case 34: {
                if (delayDuration_ == null) {
                  DelayDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(DelayDuration);
                break;
              }
              case 42: {
                if (breakDuration_ == null) {
                  BreakDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(BreakDuration);
                break;
              }
              case 50: {
                if (waitDuration_ == null) {
                  WaitDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(WaitDuration);
                break;
              }
              case 58: {
                if (totalDuration_ == null) {
                  TotalDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(TotalDuration);
                break;
              }
              case 66: {
                if (startTime_ == null) {
                  StartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(StartTime);
                break;
              }
              case 74: {
                if (routePolyline_ == null) {
                  RoutePolyline = new global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.EncodedPolyline();
                }
                input.ReadMessage(RoutePolyline);
                break;
              }
              case 90: {
                vehicleLoads_.AddEntriesFrom(ref input, _map_vehicleLoads_codec);
                break;
              }
              case 98: {
                RouteToken = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Reports the actual load of the vehicle at some point along the route,
      /// for a given type (see
      /// [Transition.vehicle_loads][google.maps.routeoptimization.v1.ShipmentRoute.Transition.vehicle_loads]).
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class VehicleLoad : pb::IMessage<VehicleLoad>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<VehicleLoad> _parser = new pb::MessageParser<VehicleLoad>(() => new VehicleLoad());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<VehicleLoad> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VehicleLoad() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VehicleLoad(VehicleLoad other) : this() {
          amount_ = other.amount_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VehicleLoad Clone() {
          return new VehicleLoad(this);
        }

        /// <summary>Field number for the "amount" field.</summary>
        public const int AmountFieldNumber = 1;
        private long amount_;
        /// <summary>
        /// The amount of load on the vehicle, for the given type. The unit of load
        /// is usually indicated by the type. See
        /// [Transition.vehicle_loads][google.maps.routeoptimization.v1.ShipmentRoute.Transition.vehicle_loads].
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public long Amount {
          get { return amount_; }
          set {
            amount_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as VehicleLoad);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(VehicleLoad other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Amount != other.Amount) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Amount != 0L) hash ^= Amount.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Amount != 0L) {
            output.WriteRawTag(8);
            output.WriteInt64(Amount);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Amount != 0L) {
            output.WriteRawTag(8);
            output.WriteInt64(Amount);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Amount != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(Amount);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(VehicleLoad other) {
          if (other == null) {
            return;
          }
          if (other.Amount != 0L) {
            Amount = other.Amount;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Amount = input.ReadInt64();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Amount = input.ReadInt64();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// The encoded representation of a polyline. More information on polyline
      /// encoding can be found here:
      /// https://developers.google.com/maps/documentation/utilities/polylinealgorithm
      /// https://developers.google.com/maps/documentation/javascript/reference/geometry#encoding.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class EncodedPolyline : pb::IMessage<EncodedPolyline>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<EncodedPolyline> _parser = new pb::MessageParser<EncodedPolyline>(() => new EncodedPolyline());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<EncodedPolyline> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public EncodedPolyline() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public EncodedPolyline(EncodedPolyline other) : this() {
          points_ = other.points_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public EncodedPolyline Clone() {
          return new EncodedPolyline(this);
        }

        /// <summary>Field number for the "points" field.</summary>
        public const int PointsFieldNumber = 1;
        private string points_ = "";
        /// <summary>
        /// String representing encoded points of the polyline.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Points {
          get { return points_; }
          set {
            points_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as EncodedPolyline);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(EncodedPolyline other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Points != other.Points) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Points.Length != 0) hash ^= Points.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Points.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Points);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Points.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Points);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Points.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Points);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(EncodedPolyline other) {
          if (other == null) {
            return;
          }
          if (other.Points.Length != 0) {
            Points = other.Points;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Points = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Points = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Data representing the execution of a break.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class Break : pb::IMessage<Break>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Break> _parser = new pb::MessageParser<Break>(() => new Break());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Break> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Descriptor.NestedTypes[4]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Break() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Break(Break other) : this() {
          startTime_ = other.startTime_ != null ? other.startTime_.Clone() : null;
          duration_ = other.duration_ != null ? other.duration_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Break Clone() {
          return new Break(this);
        }

        /// <summary>Field number for the "start_time" field.</summary>
        public const int StartTimeFieldNumber = 1;
        private global::Google.Protobuf.WellKnownTypes.Timestamp startTime_;
        /// <summary>
        /// Start time of a break.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Timestamp StartTime {
          get { return startTime_; }
          set {
            startTime_ = value;
          }
        }

        /// <summary>Field number for the "duration" field.</summary>
        public const int DurationFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Duration duration_;
        /// <summary>
        /// Duration of a break.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Duration Duration {
          get { return duration_; }
          set {
            duration_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Break);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Break other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(StartTime, other.StartTime)) return false;
          if (!object.Equals(Duration, other.Duration)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (startTime_ != null) hash ^= StartTime.GetHashCode();
          if (duration_ != null) hash ^= Duration.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (startTime_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(StartTime);
          }
          if (duration_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Duration);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (startTime_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(StartTime);
          }
          if (duration_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Duration);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (startTime_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(StartTime);
          }
          if (duration_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Duration);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Break other) {
          if (other == null) {
            return;
          }
          if (other.startTime_ != null) {
            if (startTime_ == null) {
              StartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            StartTime.MergeFrom(other.StartTime);
          }
          if (other.duration_ != null) {
            if (duration_ == null) {
              Duration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            Duration.MergeFrom(other.Duration);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (startTime_ == null) {
                  StartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(StartTime);
                break;
              }
              case 18: {
                if (duration_ == null) {
                  Duration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(Duration);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (startTime_ == null) {
                  StartTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(StartTime);
                break;
              }
              case 18: {
                if (duration_ == null) {
                  Duration = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(Duration);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Specifies details of unperformed shipments in a solution. For trivial cases
  /// and/or if we are able to identify the cause for skipping, we report the
  /// reason here.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SkippedShipment : pb::IMessage<SkippedShipment>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SkippedShipment> _parser = new pb::MessageParser<SkippedShipment>(() => new SkippedShipment());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SkippedShipment> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[18]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SkippedShipment() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SkippedShipment(SkippedShipment other) : this() {
      index_ = other.index_;
      label_ = other.label_;
      reasons_ = other.reasons_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SkippedShipment Clone() {
      return new SkippedShipment(this);
    }

    /// <summary>Field number for the "index" field.</summary>
    public const int IndexFieldNumber = 1;
    private int index_;
    /// <summary>
    /// The index corresponds to the index of the shipment in the source
    /// `ShipmentModel`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Index {
      get { return index_; }
      set {
        index_ = value;
      }
    }

    /// <summary>Field number for the "label" field.</summary>
    public const int LabelFieldNumber = 2;
    private string label_ = "";
    /// <summary>
    /// Copy of the corresponding
    /// [Shipment.label][google.maps.routeoptimization.v1.Shipment.label], if
    /// specified in the `Shipment`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Label {
      get { return label_; }
      set {
        label_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "reasons" field.</summary>
    public const int ReasonsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.SkippedShipment.Types.Reason> _repeated_reasons_codec
        = pb::FieldCodec.ForMessage(26, global::Google.Maps.RouteOptimization.V1.SkippedShipment.Types.Reason.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.SkippedShipment.Types.Reason> reasons_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.SkippedShipment.Types.Reason>();
    /// <summary>
    /// A list of reasons that explain why the shipment was skipped. See comment
    /// above `Reason`. If we are unable to understand why a shipment was skipped,
    /// reasons will not be set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.SkippedShipment.Types.Reason> Reasons {
      get { return reasons_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SkippedShipment);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SkippedShipment other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Index != other.Index) return false;
      if (Label != other.Label) return false;
      if(!reasons_.Equals(other.reasons_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Index != 0) hash ^= Index.GetHashCode();
      if (Label.Length != 0) hash ^= Label.GetHashCode();
      hash ^= reasons_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Index != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(Index);
      }
      if (Label.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Label);
      }
      reasons_.WriteTo(output, _repeated_reasons_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Index != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(Index);
      }
      if (Label.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Label);
      }
      reasons_.WriteTo(ref output, _repeated_reasons_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Index != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Index);
      }
      if (Label.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Label);
      }
      size += reasons_.CalculateSize(_repeated_reasons_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SkippedShipment other) {
      if (other == null) {
        return;
      }
      if (other.Index != 0) {
        Index = other.Index;
      }
      if (other.Label.Length != 0) {
        Label = other.Label;
      }
      reasons_.Add(other.reasons_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Index = input.ReadInt32();
            break;
          }
          case 18: {
            Label = input.ReadString();
            break;
          }
          case 26: {
            reasons_.AddEntriesFrom(input, _repeated_reasons_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Index = input.ReadInt32();
            break;
          }
          case 18: {
            Label = input.ReadString();
            break;
          }
          case 26: {
            reasons_.AddEntriesFrom(ref input, _repeated_reasons_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the SkippedShipment message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// If we can explain why the shipment was skipped, reasons will be listed
      /// here. If the reason is not the same for all vehicles, `reason` will have
      /// more than 1 element. A skipped shipment cannot have duplicate reasons,
      /// i.e. where all fields are the same except for `example_vehicle_index`.
      /// Example:
      /// ```
      /// reasons {
      ///   code: DEMAND_EXCEEDS_VEHICLE_CAPACITY
      ///   example_vehicle_index: 1
      ///   example_exceeded_capacity_type: "Apples"
      /// }
      /// reasons {
      ///   code: DEMAND_EXCEEDS_VEHICLE_CAPACITY
      ///   example_vehicle_index: 3
      ///   example_exceeded_capacity_type: "Pears"
      /// }
      /// reasons {
      ///   code: CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DISTANCE_LIMIT
      ///   example_vehicle_index: 1
      /// }
      /// ```
      /// The skipped shipment is incompatible with all vehicles. The reasons may
      /// be different for all vehicles but at least one vehicle's "Apples"
      /// capacity would be exceeded (including vehicle 1), at least one vehicle's
      /// "Pears" capacity would be exceeded (including vehicle 3) and at least one
      /// vehicle's distance limit would be exceeded (including vehicle 1).
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class Reason : pb::IMessage<Reason>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Reason> _parser = new pb::MessageParser<Reason>(() => new Reason());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Reason> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.RouteOptimization.V1.SkippedShipment.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Reason() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Reason(Reason other) : this() {
          _hasBits0 = other._hasBits0;
          code_ = other.code_;
          exampleVehicleIndex_ = other.exampleVehicleIndex_;
          exampleExceededCapacityType_ = other.exampleExceededCapacityType_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Reason Clone() {
          return new Reason(this);
        }

        /// <summary>Field number for the "code" field.</summary>
        public const int CodeFieldNumber = 1;
        private global::Google.Maps.RouteOptimization.V1.SkippedShipment.Types.Reason.Types.Code code_ = global::Google.Maps.RouteOptimization.V1.SkippedShipment.Types.Reason.Types.Code.Unspecified;
        /// <summary>
        /// Refer to the comments of Code.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Maps.RouteOptimization.V1.SkippedShipment.Types.Reason.Types.Code Code {
          get { return code_; }
          set {
            code_ = value;
          }
        }

        /// <summary>Field number for the "example_vehicle_index" field.</summary>
        public const int ExampleVehicleIndexFieldNumber = 2;
        private readonly static int ExampleVehicleIndexDefaultValue = 0;

        private int exampleVehicleIndex_;
        /// <summary>
        /// If the reason is related to a shipment-vehicle incompatibility, this
        /// field provides the index of one relevant vehicle.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int ExampleVehicleIndex {
          get { if ((_hasBits0 & 1) != 0) { return exampleVehicleIndex_; } else { return ExampleVehicleIndexDefaultValue; } }
          set {
            _hasBits0 |= 1;
            exampleVehicleIndex_ = value;
          }
        }
        /// <summary>Gets whether the "example_vehicle_index" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasExampleVehicleIndex {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "example_vehicle_index" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearExampleVehicleIndex() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "example_exceeded_capacity_type" field.</summary>
        public const int ExampleExceededCapacityTypeFieldNumber = 3;
        private string exampleExceededCapacityType_ = "";
        /// <summary>
        /// If the reason code is `DEMAND_EXCEEDS_VEHICLE_CAPACITY`, documents one
        /// capacity type that is exceeded.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string ExampleExceededCapacityType {
          get { return exampleExceededCapacityType_; }
          set {
            exampleExceededCapacityType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Reason);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Reason other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Code != other.Code) return false;
          if (ExampleVehicleIndex != other.ExampleVehicleIndex) return false;
          if (ExampleExceededCapacityType != other.ExampleExceededCapacityType) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Code != global::Google.Maps.RouteOptimization.V1.SkippedShipment.Types.Reason.Types.Code.Unspecified) hash ^= Code.GetHashCode();
          if (HasExampleVehicleIndex) hash ^= ExampleVehicleIndex.GetHashCode();
          if (ExampleExceededCapacityType.Length != 0) hash ^= ExampleExceededCapacityType.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Code != global::Google.Maps.RouteOptimization.V1.SkippedShipment.Types.Reason.Types.Code.Unspecified) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Code);
          }
          if (HasExampleVehicleIndex) {
            output.WriteRawTag(16);
            output.WriteInt32(ExampleVehicleIndex);
          }
          if (ExampleExceededCapacityType.Length != 0) {
            output.WriteRawTag(26);
            output.WriteString(ExampleExceededCapacityType);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Code != global::Google.Maps.RouteOptimization.V1.SkippedShipment.Types.Reason.Types.Code.Unspecified) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Code);
          }
          if (HasExampleVehicleIndex) {
            output.WriteRawTag(16);
            output.WriteInt32(ExampleVehicleIndex);
          }
          if (ExampleExceededCapacityType.Length != 0) {
            output.WriteRawTag(26);
            output.WriteString(ExampleExceededCapacityType);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Code != global::Google.Maps.RouteOptimization.V1.SkippedShipment.Types.Reason.Types.Code.Unspecified) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Code);
          }
          if (HasExampleVehicleIndex) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(ExampleVehicleIndex);
          }
          if (ExampleExceededCapacityType.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(ExampleExceededCapacityType);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Reason other) {
          if (other == null) {
            return;
          }
          if (other.Code != global::Google.Maps.RouteOptimization.V1.SkippedShipment.Types.Reason.Types.Code.Unspecified) {
            Code = other.Code;
          }
          if (other.HasExampleVehicleIndex) {
            ExampleVehicleIndex = other.ExampleVehicleIndex;
          }
          if (other.ExampleExceededCapacityType.Length != 0) {
            ExampleExceededCapacityType = other.ExampleExceededCapacityType;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Code = (global::Google.Maps.RouteOptimization.V1.SkippedShipment.Types.Reason.Types.Code) input.ReadEnum();
                break;
              }
              case 16: {
                ExampleVehicleIndex = input.ReadInt32();
                break;
              }
              case 26: {
                ExampleExceededCapacityType = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Code = (global::Google.Maps.RouteOptimization.V1.SkippedShipment.Types.Reason.Types.Code) input.ReadEnum();
                break;
              }
              case 16: {
                ExampleVehicleIndex = input.ReadInt32();
                break;
              }
              case 26: {
                ExampleExceededCapacityType = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the Reason message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// Code identifying the reason type. The order here is meaningless. In
          /// particular, it gives no indication of whether a given reason will
          /// appear before another in the solution, if both apply.
          /// </summary>
          public enum Code {
            /// <summary>
            /// This should never be used.
            /// </summary>
            [pbr::OriginalName("CODE_UNSPECIFIED")] Unspecified = 0,
            /// <summary>
            /// There is no vehicle in the model making all shipments infeasible.
            /// </summary>
            [pbr::OriginalName("NO_VEHICLE")] NoVehicle = 1,
            /// <summary>
            /// The demand of the shipment exceeds a vehicle's capacity for some
            /// capacity types, one of which is `example_exceeded_capacity_type`.
            /// </summary>
            [pbr::OriginalName("DEMAND_EXCEEDS_VEHICLE_CAPACITY")] DemandExceedsVehicleCapacity = 2,
            /// <summary>
            /// The minimum distance necessary to perform this shipment, i.e. from
            /// the vehicle's `start_location` to the shipment's pickup and/or delivery
            /// locations and to the vehicle's end location exceeds the vehicle's
            /// `route_distance_limit`.
            ///
            /// Note that for this computation we use the geodesic distances.
            /// </summary>
            [pbr::OriginalName("CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DISTANCE_LIMIT")] CannotBePerformedWithinVehicleDistanceLimit = 3,
            /// <summary>
            /// The minimum time necessary to perform this shipment, including travel
            /// time, wait time and service time exceeds the vehicle's
            /// `route_duration_limit`.
            ///
            /// Note: travel time is computed in the best-case scenario, namely as
            /// geodesic distance x 36 m/s (roughly 130 km/hour).
            /// </summary>
            [pbr::OriginalName("CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DURATION_LIMIT")] CannotBePerformedWithinVehicleDurationLimit = 4,
            /// <summary>
            /// Same as above but we only compare minimum travel time and the
            /// vehicle's `travel_duration_limit`.
            /// </summary>
            [pbr::OriginalName("CANNOT_BE_PERFORMED_WITHIN_VEHICLE_TRAVEL_DURATION_LIMIT")] CannotBePerformedWithinVehicleTravelDurationLimit = 5,
            /// <summary>
            /// The vehicle cannot perform this shipment in the best-case scenario
            /// (see `CANNOT_BE_PERFORMED_WITHIN_VEHICLE_DURATION_LIMIT` for time
            /// computation) if it starts at its earliest start time: the total time
            /// would make the vehicle end after its latest end time.
            /// </summary>
            [pbr::OriginalName("CANNOT_BE_PERFORMED_WITHIN_VEHICLE_TIME_WINDOWS")] CannotBePerformedWithinVehicleTimeWindows = 6,
            /// <summary>
            /// The `allowed_vehicle_indices` field of the shipment is not empty and
            /// this vehicle does not belong to it.
            /// </summary>
            [pbr::OriginalName("VEHICLE_NOT_ALLOWED")] VehicleNotAllowed = 7,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// Aggregated metrics for
  /// [ShipmentRoute][google.maps.routeoptimization.v1.ShipmentRoute] (resp. for
  /// [OptimizeToursResponse][google.maps.routeoptimization.v1.OptimizeToursResponse]
  /// over all
  /// [Transition][google.maps.routeoptimization.v1.ShipmentRoute.Transition]
  /// and/or [Visit][google.maps.routeoptimization.v1.ShipmentRoute.Visit] (resp.
  /// over all [ShipmentRoute][google.maps.routeoptimization.v1.ShipmentRoute])
  /// elements.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class AggregatedMetrics : pb::IMessage<AggregatedMetrics>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AggregatedMetrics> _parser = new pb::MessageParser<AggregatedMetrics>(() => new AggregatedMetrics());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AggregatedMetrics> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[19]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AggregatedMetrics() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AggregatedMetrics(AggregatedMetrics other) : this() {
      performedShipmentCount_ = other.performedShipmentCount_;
      travelDuration_ = other.travelDuration_ != null ? other.travelDuration_.Clone() : null;
      waitDuration_ = other.waitDuration_ != null ? other.waitDuration_.Clone() : null;
      delayDuration_ = other.delayDuration_ != null ? other.delayDuration_.Clone() : null;
      breakDuration_ = other.breakDuration_ != null ? other.breakDuration_.Clone() : null;
      visitDuration_ = other.visitDuration_ != null ? other.visitDuration_.Clone() : null;
      totalDuration_ = other.totalDuration_ != null ? other.totalDuration_.Clone() : null;
      travelDistanceMeters_ = other.travelDistanceMeters_;
      maxLoads_ = other.maxLoads_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AggregatedMetrics Clone() {
      return new AggregatedMetrics(this);
    }

    /// <summary>Field number for the "performed_shipment_count" field.</summary>
    public const int PerformedShipmentCountFieldNumber = 1;
    private int performedShipmentCount_;
    /// <summary>
    /// Number of shipments performed. Note that a pickup and delivery pair only
    /// counts once.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int PerformedShipmentCount {
      get { return performedShipmentCount_; }
      set {
        performedShipmentCount_ = value;
      }
    }

    /// <summary>Field number for the "travel_duration" field.</summary>
    public const int TravelDurationFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Duration travelDuration_;
    /// <summary>
    /// Total travel duration for a route or a solution.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration TravelDuration {
      get { return travelDuration_; }
      set {
        travelDuration_ = value;
      }
    }

    /// <summary>Field number for the "wait_duration" field.</summary>
    public const int WaitDurationFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Duration waitDuration_;
    /// <summary>
    /// Total wait duration for a route or a solution.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration WaitDuration {
      get { return waitDuration_; }
      set {
        waitDuration_ = value;
      }
    }

    /// <summary>Field number for the "delay_duration" field.</summary>
    public const int DelayDurationFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Duration delayDuration_;
    /// <summary>
    /// Total delay duration for a route or a solution.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration DelayDuration {
      get { return delayDuration_; }
      set {
        delayDuration_ = value;
      }
    }

    /// <summary>Field number for the "break_duration" field.</summary>
    public const int BreakDurationFieldNumber = 5;
    private global::Google.Protobuf.WellKnownTypes.Duration breakDuration_;
    /// <summary>
    /// Total break duration for a route or a solution.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration BreakDuration {
      get { return breakDuration_; }
      set {
        breakDuration_ = value;
      }
    }

    /// <summary>Field number for the "visit_duration" field.</summary>
    public const int VisitDurationFieldNumber = 6;
    private global::Google.Protobuf.WellKnownTypes.Duration visitDuration_;
    /// <summary>
    /// Total visit duration for a route or a solution.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration VisitDuration {
      get { return visitDuration_; }
      set {
        visitDuration_ = value;
      }
    }

    /// <summary>Field number for the "total_duration" field.</summary>
    public const int TotalDurationFieldNumber = 7;
    private global::Google.Protobuf.WellKnownTypes.Duration totalDuration_;
    /// <summary>
    /// The total duration should be equal to the sum of all durations above.
    /// For routes, it also corresponds to:
    /// ```
    /// [ShipmentRoute.vehicle_end_time][google.maps.routeoptimization.v1.ShipmentRoute.vehicle_end_time]
    /// -
    /// [ShipmentRoute.vehicle_start_time][google.maps.routeoptimization.v1.ShipmentRoute.vehicle_start_time]
    /// ```
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration TotalDuration {
      get { return totalDuration_; }
      set {
        totalDuration_ = value;
      }
    }

    /// <summary>Field number for the "travel_distance_meters" field.</summary>
    public const int TravelDistanceMetersFieldNumber = 8;
    private double travelDistanceMeters_;
    /// <summary>
    /// Total travel distance for a route or a solution.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double TravelDistanceMeters {
      get { return travelDistanceMeters_; }
      set {
        travelDistanceMeters_ = value;
      }
    }

    /// <summary>Field number for the "max_loads" field.</summary>
    public const int MaxLoadsFieldNumber = 9;
    private static readonly pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.VehicleLoad>.Codec _map_maxLoads_codec
        = new pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.VehicleLoad>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.VehicleLoad.Parser), 74);
    private readonly pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.VehicleLoad> maxLoads_ = new pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.VehicleLoad>();
    /// <summary>
    /// Maximum load achieved over the entire route (resp. solution), for each of
    /// the quantities on this route (resp. solution), computed as the maximum over
    /// all
    /// [Transition.vehicle_loads][google.maps.routeoptimization.v1.ShipmentRoute.Transition.vehicle_loads]
    /// (resp.
    /// [ShipmentRoute.metrics.max_loads][google.maps.routeoptimization.v1.AggregatedMetrics.max_loads].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Types.VehicleLoad> MaxLoads {
      get { return maxLoads_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AggregatedMetrics);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AggregatedMetrics other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PerformedShipmentCount != other.PerformedShipmentCount) return false;
      if (!object.Equals(TravelDuration, other.TravelDuration)) return false;
      if (!object.Equals(WaitDuration, other.WaitDuration)) return false;
      if (!object.Equals(DelayDuration, other.DelayDuration)) return false;
      if (!object.Equals(BreakDuration, other.BreakDuration)) return false;
      if (!object.Equals(VisitDuration, other.VisitDuration)) return false;
      if (!object.Equals(TotalDuration, other.TotalDuration)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(TravelDistanceMeters, other.TravelDistanceMeters)) return false;
      if (!MaxLoads.Equals(other.MaxLoads)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (PerformedShipmentCount != 0) hash ^= PerformedShipmentCount.GetHashCode();
      if (travelDuration_ != null) hash ^= TravelDuration.GetHashCode();
      if (waitDuration_ != null) hash ^= WaitDuration.GetHashCode();
      if (delayDuration_ != null) hash ^= DelayDuration.GetHashCode();
      if (breakDuration_ != null) hash ^= BreakDuration.GetHashCode();
      if (visitDuration_ != null) hash ^= VisitDuration.GetHashCode();
      if (totalDuration_ != null) hash ^= TotalDuration.GetHashCode();
      if (TravelDistanceMeters != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(TravelDistanceMeters);
      hash ^= MaxLoads.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (PerformedShipmentCount != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(PerformedShipmentCount);
      }
      if (travelDuration_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(TravelDuration);
      }
      if (waitDuration_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(WaitDuration);
      }
      if (delayDuration_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(DelayDuration);
      }
      if (breakDuration_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(BreakDuration);
      }
      if (visitDuration_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(VisitDuration);
      }
      if (totalDuration_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(TotalDuration);
      }
      if (TravelDistanceMeters != 0D) {
        output.WriteRawTag(65);
        output.WriteDouble(TravelDistanceMeters);
      }
      maxLoads_.WriteTo(output, _map_maxLoads_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (PerformedShipmentCount != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(PerformedShipmentCount);
      }
      if (travelDuration_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(TravelDuration);
      }
      if (waitDuration_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(WaitDuration);
      }
      if (delayDuration_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(DelayDuration);
      }
      if (breakDuration_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(BreakDuration);
      }
      if (visitDuration_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(VisitDuration);
      }
      if (totalDuration_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(TotalDuration);
      }
      if (TravelDistanceMeters != 0D) {
        output.WriteRawTag(65);
        output.WriteDouble(TravelDistanceMeters);
      }
      maxLoads_.WriteTo(ref output, _map_maxLoads_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (PerformedShipmentCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(PerformedShipmentCount);
      }
      if (travelDuration_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TravelDuration);
      }
      if (waitDuration_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WaitDuration);
      }
      if (delayDuration_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DelayDuration);
      }
      if (breakDuration_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BreakDuration);
      }
      if (visitDuration_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VisitDuration);
      }
      if (totalDuration_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TotalDuration);
      }
      if (TravelDistanceMeters != 0D) {
        size += 1 + 8;
      }
      size += maxLoads_.CalculateSize(_map_maxLoads_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AggregatedMetrics other) {
      if (other == null) {
        return;
      }
      if (other.PerformedShipmentCount != 0) {
        PerformedShipmentCount = other.PerformedShipmentCount;
      }
      if (other.travelDuration_ != null) {
        if (travelDuration_ == null) {
          TravelDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        TravelDuration.MergeFrom(other.TravelDuration);
      }
      if (other.waitDuration_ != null) {
        if (waitDuration_ == null) {
          WaitDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        WaitDuration.MergeFrom(other.WaitDuration);
      }
      if (other.delayDuration_ != null) {
        if (delayDuration_ == null) {
          DelayDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        DelayDuration.MergeFrom(other.DelayDuration);
      }
      if (other.breakDuration_ != null) {
        if (breakDuration_ == null) {
          BreakDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        BreakDuration.MergeFrom(other.BreakDuration);
      }
      if (other.visitDuration_ != null) {
        if (visitDuration_ == null) {
          VisitDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        VisitDuration.MergeFrom(other.VisitDuration);
      }
      if (other.totalDuration_ != null) {
        if (totalDuration_ == null) {
          TotalDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        TotalDuration.MergeFrom(other.TotalDuration);
      }
      if (other.TravelDistanceMeters != 0D) {
        TravelDistanceMeters = other.TravelDistanceMeters;
      }
      maxLoads_.MergeFrom(other.maxLoads_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            PerformedShipmentCount = input.ReadInt32();
            break;
          }
          case 18: {
            if (travelDuration_ == null) {
              TravelDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(TravelDuration);
            break;
          }
          case 26: {
            if (waitDuration_ == null) {
              WaitDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(WaitDuration);
            break;
          }
          case 34: {
            if (delayDuration_ == null) {
              DelayDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(DelayDuration);
            break;
          }
          case 42: {
            if (breakDuration_ == null) {
              BreakDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(BreakDuration);
            break;
          }
          case 50: {
            if (visitDuration_ == null) {
              VisitDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(VisitDuration);
            break;
          }
          case 58: {
            if (totalDuration_ == null) {
              TotalDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(TotalDuration);
            break;
          }
          case 65: {
            TravelDistanceMeters = input.ReadDouble();
            break;
          }
          case 74: {
            maxLoads_.AddEntriesFrom(input, _map_maxLoads_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            PerformedShipmentCount = input.ReadInt32();
            break;
          }
          case 18: {
            if (travelDuration_ == null) {
              TravelDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(TravelDuration);
            break;
          }
          case 26: {
            if (waitDuration_ == null) {
              WaitDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(WaitDuration);
            break;
          }
          case 34: {
            if (delayDuration_ == null) {
              DelayDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(DelayDuration);
            break;
          }
          case 42: {
            if (breakDuration_ == null) {
              BreakDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(BreakDuration);
            break;
          }
          case 50: {
            if (visitDuration_ == null) {
              VisitDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(VisitDuration);
            break;
          }
          case 58: {
            if (totalDuration_ == null) {
              TotalDuration = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(TotalDuration);
            break;
          }
          case 65: {
            TravelDistanceMeters = input.ReadDouble();
            break;
          }
          case 74: {
            maxLoads_.AddEntriesFrom(ref input, _map_maxLoads_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Solution injected in the request including information about which visits
  /// must be constrained and how they must be constrained.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class InjectedSolutionConstraint : pb::IMessage<InjectedSolutionConstraint>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<InjectedSolutionConstraint> _parser = new pb::MessageParser<InjectedSolutionConstraint>(() => new InjectedSolutionConstraint());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<InjectedSolutionConstraint> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[20]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InjectedSolutionConstraint() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InjectedSolutionConstraint(InjectedSolutionConstraint other) : this() {
      routes_ = other.routes_.Clone();
      skippedShipments_ = other.skippedShipments_.Clone();
      constraintRelaxations_ = other.constraintRelaxations_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InjectedSolutionConstraint Clone() {
      return new InjectedSolutionConstraint(this);
    }

    /// <summary>Field number for the "routes" field.</summary>
    public const int RoutesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.ShipmentRoute> _repeated_routes_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Maps.RouteOptimization.V1.ShipmentRoute.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentRoute> routes_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentRoute>();
    /// <summary>
    /// Routes of the solution to inject. Some routes may be omitted from the
    /// original solution. The routes and skipped shipments must satisfy the basic
    /// validity assumptions listed for `injected_first_solution_routes`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.ShipmentRoute> Routes {
      get { return routes_; }
    }

    /// <summary>Field number for the "skipped_shipments" field.</summary>
    public const int SkippedShipmentsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.SkippedShipment> _repeated_skippedShipments_codec
        = pb::FieldCodec.ForMessage(18, global::Google.Maps.RouteOptimization.V1.SkippedShipment.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.SkippedShipment> skippedShipments_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.SkippedShipment>();
    /// <summary>
    /// Skipped shipments of the solution to inject. Some may be omitted from the
    /// original solution. See the `routes` field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.SkippedShipment> SkippedShipments {
      get { return skippedShipments_; }
    }

    /// <summary>Field number for the "constraint_relaxations" field.</summary>
    public const int ConstraintRelaxationsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation> _repeated_constraintRelaxations_codec
        = pb::FieldCodec.ForMessage(26, global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation> constraintRelaxations_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation>();
    /// <summary>
    /// For zero or more groups of vehicles, specifies when and how much to relax
    /// constraints. If this field is empty, all non-empty vehicle routes are
    /// fully constrained.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation> ConstraintRelaxations {
      get { return constraintRelaxations_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as InjectedSolutionConstraint);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(InjectedSolutionConstraint other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!routes_.Equals(other.routes_)) return false;
      if(!skippedShipments_.Equals(other.skippedShipments_)) return false;
      if(!constraintRelaxations_.Equals(other.constraintRelaxations_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= routes_.GetHashCode();
      hash ^= skippedShipments_.GetHashCode();
      hash ^= constraintRelaxations_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      routes_.WriteTo(output, _repeated_routes_codec);
      skippedShipments_.WriteTo(output, _repeated_skippedShipments_codec);
      constraintRelaxations_.WriteTo(output, _repeated_constraintRelaxations_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      routes_.WriteTo(ref output, _repeated_routes_codec);
      skippedShipments_.WriteTo(ref output, _repeated_skippedShipments_codec);
      constraintRelaxations_.WriteTo(ref output, _repeated_constraintRelaxations_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += routes_.CalculateSize(_repeated_routes_codec);
      size += skippedShipments_.CalculateSize(_repeated_skippedShipments_codec);
      size += constraintRelaxations_.CalculateSize(_repeated_constraintRelaxations_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(InjectedSolutionConstraint other) {
      if (other == null) {
        return;
      }
      routes_.Add(other.routes_);
      skippedShipments_.Add(other.skippedShipments_);
      constraintRelaxations_.Add(other.constraintRelaxations_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            routes_.AddEntriesFrom(input, _repeated_routes_codec);
            break;
          }
          case 18: {
            skippedShipments_.AddEntriesFrom(input, _repeated_skippedShipments_codec);
            break;
          }
          case 26: {
            constraintRelaxations_.AddEntriesFrom(input, _repeated_constraintRelaxations_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            routes_.AddEntriesFrom(ref input, _repeated_routes_codec);
            break;
          }
          case 18: {
            skippedShipments_.AddEntriesFrom(ref input, _repeated_skippedShipments_codec);
            break;
          }
          case 26: {
            constraintRelaxations_.AddEntriesFrom(ref input, _repeated_constraintRelaxations_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the InjectedSolutionConstraint message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// For a group of vehicles, specifies at what threshold(s) constraints on
      /// visits will be relaxed and to which level. Shipments listed in
      /// the `skipped_shipment` field are constrained to be skipped; i.e., they
      /// cannot be performed.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class ConstraintRelaxation : pb::IMessage<ConstraintRelaxation>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<ConstraintRelaxation> _parser = new pb::MessageParser<ConstraintRelaxation>(() => new ConstraintRelaxation());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<ConstraintRelaxation> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ConstraintRelaxation() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ConstraintRelaxation(ConstraintRelaxation other) : this() {
          relaxations_ = other.relaxations_.Clone();
          vehicleIndices_ = other.vehicleIndices_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ConstraintRelaxation Clone() {
          return new ConstraintRelaxation(this);
        }

        /// <summary>Field number for the "relaxations" field.</summary>
        public const int RelaxationsFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation.Types.Relaxation> _repeated_relaxations_codec
            = pb::FieldCodec.ForMessage(10, global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation.Types.Relaxation.Parser);
        private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation.Types.Relaxation> relaxations_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation.Types.Relaxation>();
        /// <summary>
        /// All the visit constraint relaxations that will apply to visits on
        /// routes with vehicles in `vehicle_indices`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation.Types.Relaxation> Relaxations {
          get { return relaxations_; }
        }

        /// <summary>Field number for the "vehicle_indices" field.</summary>
        public const int VehicleIndicesFieldNumber = 2;
        private static readonly pb::FieldCodec<int> _repeated_vehicleIndices_codec
            = pb::FieldCodec.ForInt32(18);
        private readonly pbc::RepeatedField<int> vehicleIndices_ = new pbc::RepeatedField<int>();
        /// <summary>
        /// Specifies the vehicle indices to which the visit constraint
        /// `relaxations` apply. If empty, this is considered the default and the
        /// `relaxations` apply to all vehicles that are not specified in other
        /// `constraint_relaxations`. There can be at most one default, i.e., at
        /// most one constraint relaxation field is allowed empty
        /// `vehicle_indices`. A vehicle index can only be listed once, even within
        /// several `constraint_relaxations`.
        ///
        /// A vehicle index is mapped the same as
        /// [ShipmentRoute.vehicle_index][google.maps.routeoptimization.v1.ShipmentRoute.vehicle_index],
        /// if `interpret_injected_solutions_using_labels` is true (see `fields`
        /// comment).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<int> VehicleIndices {
          get { return vehicleIndices_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as ConstraintRelaxation);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(ConstraintRelaxation other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!relaxations_.Equals(other.relaxations_)) return false;
          if(!vehicleIndices_.Equals(other.vehicleIndices_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= relaxations_.GetHashCode();
          hash ^= vehicleIndices_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          relaxations_.WriteTo(output, _repeated_relaxations_codec);
          vehicleIndices_.WriteTo(output, _repeated_vehicleIndices_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          relaxations_.WriteTo(ref output, _repeated_relaxations_codec);
          vehicleIndices_.WriteTo(ref output, _repeated_vehicleIndices_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          size += relaxations_.CalculateSize(_repeated_relaxations_codec);
          size += vehicleIndices_.CalculateSize(_repeated_vehicleIndices_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(ConstraintRelaxation other) {
          if (other == null) {
            return;
          }
          relaxations_.Add(other.relaxations_);
          vehicleIndices_.Add(other.vehicleIndices_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                relaxations_.AddEntriesFrom(input, _repeated_relaxations_codec);
                break;
              }
              case 18:
              case 16: {
                vehicleIndices_.AddEntriesFrom(input, _repeated_vehicleIndices_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                relaxations_.AddEntriesFrom(ref input, _repeated_relaxations_codec);
                break;
              }
              case 18:
              case 16: {
                vehicleIndices_.AddEntriesFrom(ref input, _repeated_vehicleIndices_codec);
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the ConstraintRelaxation message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// If `relaxations` is empty, the start time and sequence of all visits
          /// on `routes` are fully constrained and no new visits may be inserted or
          /// added to those routes. Also, a vehicle's start and end time in
          /// `routes` is fully constrained, unless the vehicle is empty (i.e., has no
          /// visits and has `used_if_route_is_empty` set to false in the model).
          ///
          /// `relaxations(i).level` specifies the constraint relaxation level applied
          /// to a visit #j that satisfies:
          ///
          ///   * `route.visits(j).start_time >= relaxations(i).threshold_time` AND
          ///   * `j + 1 >= relaxations(i).threshold_visit_count`
          ///
          /// Similarly, the vehicle start is relaxed to `relaxations(i).level` if it
          /// satisfies:
          ///
          ///   * `vehicle_start_time >= relaxations(i).threshold_time` AND
          ///   * `relaxations(i).threshold_visit_count == 0`
          /// and the vehicle end is relaxed to `relaxations(i).level` if it satisfies:
          ///   * `vehicle_end_time >= relaxations(i).threshold_time` AND
          ///   * `route.visits_size() + 1 >= relaxations(i).threshold_visit_count`
          ///
          /// To apply a relaxation level if a visit meets the `threshold_visit_count`
          /// OR the `threshold_time` add two `relaxations` with the same `level`:
          /// one with only `threshold_visit_count` set and the other with only
          /// `threshold_time` set. If a visit satisfies the conditions of multiple
          /// `relaxations`, the most relaxed level applies. As a result, from the
          /// vehicle start through the route visits in order to the vehicle end, the
          /// relaxation level becomes more relaxed: i.e., the relaxation level is
          /// non-decreasing as the route progresses.
          ///
          /// The timing and sequence of route visits that do not satisfy the
          /// threshold conditions of any `relaxations` are fully constrained
          /// and no visits may be inserted into these sequences. Also, if a
          /// vehicle start or end does not satisfy the conditions of any
          /// relaxation the time is fixed, unless the vehicle is empty.
          /// </summary>
          [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
          public sealed partial class Relaxation : pb::IMessage<Relaxation>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<Relaxation> _parser = new pb::MessageParser<Relaxation>(() => new Relaxation());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<Relaxation> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Relaxation() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Relaxation(Relaxation other) : this() {
              level_ = other.level_;
              thresholdTime_ = other.thresholdTime_ != null ? other.thresholdTime_.Clone() : null;
              thresholdVisitCount_ = other.thresholdVisitCount_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Relaxation Clone() {
              return new Relaxation(this);
            }

            /// <summary>Field number for the "level" field.</summary>
            public const int LevelFieldNumber = 1;
            private global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation.Types.Relaxation.Types.Level level_ = global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation.Types.Relaxation.Types.Level.Unspecified;
            /// <summary>
            /// The constraint relaxation level that applies when the conditions
            /// at or after `threshold_time` AND at least `threshold_visit_count` are
            /// satisfied.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation.Types.Relaxation.Types.Level Level {
              get { return level_; }
              set {
                level_ = value;
              }
            }

            /// <summary>Field number for the "threshold_time" field.</summary>
            public const int ThresholdTimeFieldNumber = 2;
            private global::Google.Protobuf.WellKnownTypes.Timestamp thresholdTime_;
            /// <summary>
            /// The time at or after which the relaxation `level` may be applied.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Google.Protobuf.WellKnownTypes.Timestamp ThresholdTime {
              get { return thresholdTime_; }
              set {
                thresholdTime_ = value;
              }
            }

            /// <summary>Field number for the "threshold_visit_count" field.</summary>
            public const int ThresholdVisitCountFieldNumber = 3;
            private int thresholdVisitCount_;
            /// <summary>
            /// The number of visits at or after which the relaxation `level` may be
            /// applied. If `threshold_visit_count` is 0 (or unset), the `level` may be
            /// applied directly at the vehicle start.
            ///
            /// If it is `route.visits_size() + 1`, the `level` may only be applied to
            /// the vehicle end. If it is more than `route.visits_size() + 1`,
            /// `level` is not applied at all for that route.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int ThresholdVisitCount {
              get { return thresholdVisitCount_; }
              set {
                thresholdVisitCount_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as Relaxation);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(Relaxation other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Level != other.Level) return false;
              if (!object.Equals(ThresholdTime, other.ThresholdTime)) return false;
              if (ThresholdVisitCount != other.ThresholdVisitCount) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (Level != global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation.Types.Relaxation.Types.Level.Unspecified) hash ^= Level.GetHashCode();
              if (thresholdTime_ != null) hash ^= ThresholdTime.GetHashCode();
              if (ThresholdVisitCount != 0) hash ^= ThresholdVisitCount.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (Level != global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation.Types.Relaxation.Types.Level.Unspecified) {
                output.WriteRawTag(8);
                output.WriteEnum((int) Level);
              }
              if (thresholdTime_ != null) {
                output.WriteRawTag(18);
                output.WriteMessage(ThresholdTime);
              }
              if (ThresholdVisitCount != 0) {
                output.WriteRawTag(24);
                output.WriteInt32(ThresholdVisitCount);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (Level != global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation.Types.Relaxation.Types.Level.Unspecified) {
                output.WriteRawTag(8);
                output.WriteEnum((int) Level);
              }
              if (thresholdTime_ != null) {
                output.WriteRawTag(18);
                output.WriteMessage(ThresholdTime);
              }
              if (ThresholdVisitCount != 0) {
                output.WriteRawTag(24);
                output.WriteInt32(ThresholdVisitCount);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (Level != global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation.Types.Relaxation.Types.Level.Unspecified) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Level);
              }
              if (thresholdTime_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(ThresholdTime);
              }
              if (ThresholdVisitCount != 0) {
                size += 1 + pb::CodedOutputStream.ComputeInt32Size(ThresholdVisitCount);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(Relaxation other) {
              if (other == null) {
                return;
              }
              if (other.Level != global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation.Types.Relaxation.Types.Level.Unspecified) {
                Level = other.Level;
              }
              if (other.thresholdTime_ != null) {
                if (thresholdTime_ == null) {
                  ThresholdTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                ThresholdTime.MergeFrom(other.ThresholdTime);
              }
              if (other.ThresholdVisitCount != 0) {
                ThresholdVisitCount = other.ThresholdVisitCount;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 8: {
                    Level = (global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation.Types.Relaxation.Types.Level) input.ReadEnum();
                    break;
                  }
                  case 18: {
                    if (thresholdTime_ == null) {
                      ThresholdTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                    }
                    input.ReadMessage(ThresholdTime);
                    break;
                  }
                  case 24: {
                    ThresholdVisitCount = input.ReadInt32();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 8: {
                    Level = (global::Google.Maps.RouteOptimization.V1.InjectedSolutionConstraint.Types.ConstraintRelaxation.Types.Relaxation.Types.Level) input.ReadEnum();
                    break;
                  }
                  case 18: {
                    if (thresholdTime_ == null) {
                      ThresholdTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                    }
                    input.ReadMessage(ThresholdTime);
                    break;
                  }
                  case 24: {
                    ThresholdVisitCount = input.ReadInt32();
                    break;
                  }
                }
              }
            }
            #endif

            #region Nested types
            /// <summary>Container for nested types declared in the Relaxation message type.</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static partial class Types {
              /// <summary>
              /// Expresses the different constraint relaxation levels, which are
              /// applied for a visit and those that follow when it satisfies the
              /// threshold conditions.
              ///
              /// The enumeration below is in order of increasing relaxation.
              /// </summary>
              public enum Level {
                /// <summary>
                /// Implicit default relaxation level: no constraints are relaxed,
                /// i.e., all visits are fully constrained.
                ///
                /// This value must not be explicitly used in `level`.
                /// </summary>
                [pbr::OriginalName("LEVEL_UNSPECIFIED")] Unspecified = 0,
                /// <summary>
                /// Visit start times and vehicle start/end times will be relaxed, but
                /// each visit remains bound to the same vehicle and the visit sequence
                /// must be observed: no visit can be inserted between them or before
                /// them.
                /// </summary>
                [pbr::OriginalName("RELAX_VISIT_TIMES_AFTER_THRESHOLD")] RelaxVisitTimesAfterThreshold = 1,
                /// <summary>
                /// Same as `RELAX_VISIT_TIMES_AFTER_THRESHOLD`, but the visit sequence
                /// is also relaxed: visits can only be performed by this vehicle, but
                /// can potentially become unperformed.
                /// </summary>
                [pbr::OriginalName("RELAX_VISIT_TIMES_AND_SEQUENCE_AFTER_THRESHOLD")] RelaxVisitTimesAndSequenceAfterThreshold = 2,
                /// <summary>
                /// Same as `RELAX_VISIT_TIMES_AND_SEQUENCE_AFTER_THRESHOLD`, but the
                /// vehicle is also relaxed: visits are completely free at or after the
                /// threshold time and can potentially become unperformed.
                /// </summary>
                [pbr::OriginalName("RELAX_ALL_AFTER_THRESHOLD")] RelaxAllAfterThreshold = 3,
              }

            }
            #endregion

          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// Describes an error or warning encountered when validating an
  /// `OptimizeToursRequest`.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class OptimizeToursValidationError : pb::IMessage<OptimizeToursValidationError>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OptimizeToursValidationError> _parser = new pb::MessageParser<OptimizeToursValidationError>(() => new OptimizeToursValidationError());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<OptimizeToursValidationError> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[21]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OptimizeToursValidationError() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OptimizeToursValidationError(OptimizeToursValidationError other) : this() {
      code_ = other.code_;
      displayName_ = other.displayName_;
      fields_ = other.fields_.Clone();
      errorMessage_ = other.errorMessage_;
      offendingValues_ = other.offendingValues_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OptimizeToursValidationError Clone() {
      return new OptimizeToursValidationError(this);
    }

    /// <summary>Field number for the "code" field.</summary>
    public const int CodeFieldNumber = 1;
    private int code_;
    /// <summary>
    /// A validation error is defined by the pair (`code`, `display_name`) which
    /// are always present.
    ///
    /// The fields following this section provide more context about the error.
    ///
    /// *MULTIPLE ERRORS*:
    /// When there are multiple errors, the validation process tries to output
    /// several of them. Much like a compiler, this is an imperfect process. Some
    /// validation errors will be "fatal", meaning that they stop the entire
    /// validation process. This is the case for `display_name="UNSPECIFIED"`
    /// errors, among others. Some errors may cause the validation process to skip
    /// other errors.
    ///
    /// *STABILITY*:
    /// `code` and `display_name` should be very stable. But new codes and
    /// display names may appear over time, which may cause a given (invalid)
    /// request to yield a different (`code`, `display_name`) pair because the new
    /// error hid the old one. For example, see "MULTIPLE ERRORS".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Code {
      get { return code_; }
      set {
        code_ = value;
      }
    }

    /// <summary>Field number for the "display_name" field.</summary>
    public const int DisplayNameFieldNumber = 2;
    private string displayName_ = "";
    /// <summary>
    /// The error display name.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DisplayName {
      get { return displayName_; }
      set {
        displayName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "fields" field.</summary>
    public const int FieldsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Google.Maps.RouteOptimization.V1.OptimizeToursValidationError.Types.FieldReference> _repeated_fields_codec
        = pb::FieldCodec.ForMessage(26, global::Google.Maps.RouteOptimization.V1.OptimizeToursValidationError.Types.FieldReference.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.OptimizeToursValidationError.Types.FieldReference> fields_ = new pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.OptimizeToursValidationError.Types.FieldReference>();
    /// <summary>
    /// An error context may involve 0, 1 (most of the time) or more fields. For
    /// example, referring to vehicle #4 and shipment #2's first pickup can be
    /// done as follows:
    /// ```
    /// fields { name: "vehicles" index: 4}
    /// fields { name: "shipments" index: 2 sub_field {name: "pickups" index: 0} }
    /// ```
    /// Note, however, that the cardinality of `fields` should not change for a
    /// given error code.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.RouteOptimization.V1.OptimizeToursValidationError.Types.FieldReference> Fields {
      get { return fields_; }
    }

    /// <summary>Field number for the "error_message" field.</summary>
    public const int ErrorMessageFieldNumber = 4;
    private string errorMessage_ = "";
    /// <summary>
    /// Human-readable string describing the error. There is a 1:1 mapping
    /// between `code` and `error_message` (when code != "UNSPECIFIED").
    ///
    /// *STABILITY*: Not stable: the error message associated to a given `code` may
    /// change (hopefully to clarify it) over time. Please rely on the
    /// `display_name` and `code` instead.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ErrorMessage {
      get { return errorMessage_; }
      set {
        errorMessage_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "offending_values" field.</summary>
    public const int OffendingValuesFieldNumber = 5;
    private string offendingValues_ = "";
    /// <summary>
    /// May contain the value(s) of the field(s). This is not always available. You
    /// should absolutely not rely on it and use it only for manual model
    /// debugging.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string OffendingValues {
      get { return offendingValues_; }
      set {
        offendingValues_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as OptimizeToursValidationError);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(OptimizeToursValidationError other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Code != other.Code) return false;
      if (DisplayName != other.DisplayName) return false;
      if(!fields_.Equals(other.fields_)) return false;
      if (ErrorMessage != other.ErrorMessage) return false;
      if (OffendingValues != other.OffendingValues) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Code != 0) hash ^= Code.GetHashCode();
      if (DisplayName.Length != 0) hash ^= DisplayName.GetHashCode();
      hash ^= fields_.GetHashCode();
      if (ErrorMessage.Length != 0) hash ^= ErrorMessage.GetHashCode();
      if (OffendingValues.Length != 0) hash ^= OffendingValues.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Code != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(Code);
      }
      if (DisplayName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(DisplayName);
      }
      fields_.WriteTo(output, _repeated_fields_codec);
      if (ErrorMessage.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(ErrorMessage);
      }
      if (OffendingValues.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(OffendingValues);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Code != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(Code);
      }
      if (DisplayName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(DisplayName);
      }
      fields_.WriteTo(ref output, _repeated_fields_codec);
      if (ErrorMessage.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(ErrorMessage);
      }
      if (OffendingValues.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(OffendingValues);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Code != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Code);
      }
      if (DisplayName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DisplayName);
      }
      size += fields_.CalculateSize(_repeated_fields_codec);
      if (ErrorMessage.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ErrorMessage);
      }
      if (OffendingValues.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(OffendingValues);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(OptimizeToursValidationError other) {
      if (other == null) {
        return;
      }
      if (other.Code != 0) {
        Code = other.Code;
      }
      if (other.DisplayName.Length != 0) {
        DisplayName = other.DisplayName;
      }
      fields_.Add(other.fields_);
      if (other.ErrorMessage.Length != 0) {
        ErrorMessage = other.ErrorMessage;
      }
      if (other.OffendingValues.Length != 0) {
        OffendingValues = other.OffendingValues;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Code = input.ReadInt32();
            break;
          }
          case 18: {
            DisplayName = input.ReadString();
            break;
          }
          case 26: {
            fields_.AddEntriesFrom(input, _repeated_fields_codec);
            break;
          }
          case 34: {
            ErrorMessage = input.ReadString();
            break;
          }
          case 42: {
            OffendingValues = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Code = input.ReadInt32();
            break;
          }
          case 18: {
            DisplayName = input.ReadString();
            break;
          }
          case 26: {
            fields_.AddEntriesFrom(ref input, _repeated_fields_codec);
            break;
          }
          case 34: {
            ErrorMessage = input.ReadString();
            break;
          }
          case 42: {
            OffendingValues = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the OptimizeToursValidationError message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Specifies a context for the validation error. A `FieldReference` always
      /// refers to a given field in this file and follows the same hierarchical
      /// structure. For example, we may specify element #2 of `start_time_windows`
      /// of vehicle #5 using:
      /// ```
      /// name: "vehicles" index: 5 sub_field { name: "end_time_windows" index: 2 }
      /// ```
      /// We however omit top-level entities such as `OptimizeToursRequest` or
      /// `ShipmentModel` to avoid crowding the message.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class FieldReference : pb::IMessage<FieldReference>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<FieldReference> _parser = new pb::MessageParser<FieldReference>(() => new FieldReference());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<FieldReference> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.RouteOptimization.V1.OptimizeToursValidationError.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public FieldReference() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public FieldReference(FieldReference other) : this() {
          name_ = other.name_;
          subField_ = other.subField_ != null ? other.subField_.Clone() : null;
          switch (other.IndexOrKeyCase) {
            case IndexOrKeyOneofCase.Index:
              Index = other.Index;
              break;
            case IndexOrKeyOneofCase.Key:
              Key = other.Key;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public FieldReference Clone() {
          return new FieldReference(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// Name of the field, e.g., "vehicles".
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "index" field.</summary>
        public const int IndexFieldNumber = 2;
        /// <summary>
        /// Index of the field if repeated.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int Index {
          get { return HasIndex ? (int) indexOrKey_ : 0; }
          set {
            indexOrKey_ = value;
            indexOrKeyCase_ = IndexOrKeyOneofCase.Index;
          }
        }
        /// <summary>Gets whether the "index" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasIndex {
          get { return indexOrKeyCase_ == IndexOrKeyOneofCase.Index; }
        }
        /// <summary> Clears the value of the oneof if it's currently set to "index" </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearIndex() {
          if (HasIndex) {
            ClearIndexOrKey();
          }
        }

        /// <summary>Field number for the "key" field.</summary>
        public const int KeyFieldNumber = 4;
        /// <summary>
        /// Key if the field is a map.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Key {
          get { return HasKey ? (string) indexOrKey_ : ""; }
          set {
            indexOrKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            indexOrKeyCase_ = IndexOrKeyOneofCase.Key;
          }
        }
        /// <summary>Gets whether the "key" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasKey {
          get { return indexOrKeyCase_ == IndexOrKeyOneofCase.Key; }
        }
        /// <summary> Clears the value of the oneof if it's currently set to "key" </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearKey() {
          if (HasKey) {
            ClearIndexOrKey();
          }
        }

        /// <summary>Field number for the "sub_field" field.</summary>
        public const int SubFieldFieldNumber = 3;
        private global::Google.Maps.RouteOptimization.V1.OptimizeToursValidationError.Types.FieldReference subField_;
        /// <summary>
        /// Recursively nested sub-field, if needed.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Maps.RouteOptimization.V1.OptimizeToursValidationError.Types.FieldReference SubField {
          get { return subField_; }
          set {
            subField_ = value;
          }
        }

        private object indexOrKey_;
        /// <summary>Enum of possible cases for the "index_or_key" oneof.</summary>
        public enum IndexOrKeyOneofCase {
          None = 0,
          Index = 2,
          Key = 4,
        }
        private IndexOrKeyOneofCase indexOrKeyCase_ = IndexOrKeyOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public IndexOrKeyOneofCase IndexOrKeyCase {
          get { return indexOrKeyCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearIndexOrKey() {
          indexOrKeyCase_ = IndexOrKeyOneofCase.None;
          indexOrKey_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as FieldReference);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(FieldReference other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (Index != other.Index) return false;
          if (Key != other.Key) return false;
          if (!object.Equals(SubField, other.SubField)) return false;
          if (IndexOrKeyCase != other.IndexOrKeyCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (HasIndex) hash ^= Index.GetHashCode();
          if (HasKey) hash ^= Key.GetHashCode();
          if (subField_ != null) hash ^= SubField.GetHashCode();
          hash ^= (int) indexOrKeyCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (HasIndex) {
            output.WriteRawTag(16);
            output.WriteInt32(Index);
          }
          if (subField_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(SubField);
          }
          if (HasKey) {
            output.WriteRawTag(34);
            output.WriteString(Key);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (HasIndex) {
            output.WriteRawTag(16);
            output.WriteInt32(Index);
          }
          if (subField_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(SubField);
          }
          if (HasKey) {
            output.WriteRawTag(34);
            output.WriteString(Key);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (HasIndex) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(Index);
          }
          if (HasKey) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
          }
          if (subField_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(SubField);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(FieldReference other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          if (other.subField_ != null) {
            if (subField_ == null) {
              SubField = new global::Google.Maps.RouteOptimization.V1.OptimizeToursValidationError.Types.FieldReference();
            }
            SubField.MergeFrom(other.SubField);
          }
          switch (other.IndexOrKeyCase) {
            case IndexOrKeyOneofCase.Index:
              Index = other.Index;
              break;
            case IndexOrKeyOneofCase.Key:
              Key = other.Key;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 16: {
                Index = input.ReadInt32();
                break;
              }
              case 26: {
                if (subField_ == null) {
                  SubField = new global::Google.Maps.RouteOptimization.V1.OptimizeToursValidationError.Types.FieldReference();
                }
                input.ReadMessage(SubField);
                break;
              }
              case 34: {
                Key = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 16: {
                Index = input.ReadInt32();
                break;
              }
              case 26: {
                if (subField_ == null) {
                  SubField = new global::Google.Maps.RouteOptimization.V1.OptimizeToursValidationError.Types.FieldReference();
                }
                input.ReadMessage(SubField);
                break;
              }
              case 34: {
                Key = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Specify an input for
  /// [BatchOptimizeTours][google.maps.routeoptimization.v1.RouteOptimizationService.BatchOptimizeTours].
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class InputConfig : pb::IMessage<InputConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<InputConfig> _parser = new pb::MessageParser<InputConfig>(() => new InputConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<InputConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[22]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InputConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InputConfig(InputConfig other) : this() {
      dataFormat_ = other.dataFormat_;
      switch (other.SourceCase) {
        case SourceOneofCase.GcsSource:
          GcsSource = other.GcsSource.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InputConfig Clone() {
      return new InputConfig(this);
    }

    /// <summary>Field number for the "gcs_source" field.</summary>
    public const int GcsSourceFieldNumber = 1;
    /// <summary>
    /// A Google Cloud Storage location. This must be a single object (file).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.GcsSource GcsSource {
      get { return sourceCase_ == SourceOneofCase.GcsSource ? (global::Google.Maps.RouteOptimization.V1.GcsSource) source_ : null; }
      set {
        source_ = value;
        sourceCase_ = value == null ? SourceOneofCase.None : SourceOneofCase.GcsSource;
      }
    }

    /// <summary>Field number for the "data_format" field.</summary>
    public const int DataFormatFieldNumber = 2;
    private global::Google.Maps.RouteOptimization.V1.DataFormat dataFormat_ = global::Google.Maps.RouteOptimization.V1.DataFormat.Unspecified;
    /// <summary>
    /// Required. The input data format.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.DataFormat DataFormat {
      get { return dataFormat_; }
      set {
        dataFormat_ = value;
      }
    }

    private object source_;
    /// <summary>Enum of possible cases for the "source" oneof.</summary>
    public enum SourceOneofCase {
      None = 0,
      GcsSource = 1,
    }
    private SourceOneofCase sourceCase_ = SourceOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SourceOneofCase SourceCase {
      get { return sourceCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSource() {
      sourceCase_ = SourceOneofCase.None;
      source_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as InputConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(InputConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(GcsSource, other.GcsSource)) return false;
      if (DataFormat != other.DataFormat) return false;
      if (SourceCase != other.SourceCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (sourceCase_ == SourceOneofCase.GcsSource) hash ^= GcsSource.GetHashCode();
      if (DataFormat != global::Google.Maps.RouteOptimization.V1.DataFormat.Unspecified) hash ^= DataFormat.GetHashCode();
      hash ^= (int) sourceCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (sourceCase_ == SourceOneofCase.GcsSource) {
        output.WriteRawTag(10);
        output.WriteMessage(GcsSource);
      }
      if (DataFormat != global::Google.Maps.RouteOptimization.V1.DataFormat.Unspecified) {
        output.WriteRawTag(16);
        output.WriteEnum((int) DataFormat);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (sourceCase_ == SourceOneofCase.GcsSource) {
        output.WriteRawTag(10);
        output.WriteMessage(GcsSource);
      }
      if (DataFormat != global::Google.Maps.RouteOptimization.V1.DataFormat.Unspecified) {
        output.WriteRawTag(16);
        output.WriteEnum((int) DataFormat);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (sourceCase_ == SourceOneofCase.GcsSource) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(GcsSource);
      }
      if (DataFormat != global::Google.Maps.RouteOptimization.V1.DataFormat.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DataFormat);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(InputConfig other) {
      if (other == null) {
        return;
      }
      if (other.DataFormat != global::Google.Maps.RouteOptimization.V1.DataFormat.Unspecified) {
        DataFormat = other.DataFormat;
      }
      switch (other.SourceCase) {
        case SourceOneofCase.GcsSource:
          if (GcsSource == null) {
            GcsSource = new global::Google.Maps.RouteOptimization.V1.GcsSource();
          }
          GcsSource.MergeFrom(other.GcsSource);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Google.Maps.RouteOptimization.V1.GcsSource subBuilder = new global::Google.Maps.RouteOptimization.V1.GcsSource();
            if (sourceCase_ == SourceOneofCase.GcsSource) {
              subBuilder.MergeFrom(GcsSource);
            }
            input.ReadMessage(subBuilder);
            GcsSource = subBuilder;
            break;
          }
          case 16: {
            DataFormat = (global::Google.Maps.RouteOptimization.V1.DataFormat) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::Google.Maps.RouteOptimization.V1.GcsSource subBuilder = new global::Google.Maps.RouteOptimization.V1.GcsSource();
            if (sourceCase_ == SourceOneofCase.GcsSource) {
              subBuilder.MergeFrom(GcsSource);
            }
            input.ReadMessage(subBuilder);
            GcsSource = subBuilder;
            break;
          }
          case 16: {
            DataFormat = (global::Google.Maps.RouteOptimization.V1.DataFormat) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Specify a destination for
  /// [BatchOptimizeTours][google.maps.routeoptimization.v1.RouteOptimizationService.BatchOptimizeTours]
  /// results.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class OutputConfig : pb::IMessage<OutputConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OutputConfig> _parser = new pb::MessageParser<OutputConfig>(() => new OutputConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<OutputConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[23]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OutputConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OutputConfig(OutputConfig other) : this() {
      dataFormat_ = other.dataFormat_;
      switch (other.DestinationCase) {
        case DestinationOneofCase.GcsDestination:
          GcsDestination = other.GcsDestination.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public OutputConfig Clone() {
      return new OutputConfig(this);
    }

    /// <summary>Field number for the "gcs_destination" field.</summary>
    public const int GcsDestinationFieldNumber = 1;
    /// <summary>
    /// The Google Cloud Storage location to write the output to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.GcsDestination GcsDestination {
      get { return destinationCase_ == DestinationOneofCase.GcsDestination ? (global::Google.Maps.RouteOptimization.V1.GcsDestination) destination_ : null; }
      set {
        destination_ = value;
        destinationCase_ = value == null ? DestinationOneofCase.None : DestinationOneofCase.GcsDestination;
      }
    }

    /// <summary>Field number for the "data_format" field.</summary>
    public const int DataFormatFieldNumber = 2;
    private global::Google.Maps.RouteOptimization.V1.DataFormat dataFormat_ = global::Google.Maps.RouteOptimization.V1.DataFormat.Unspecified;
    /// <summary>
    /// Required. The output data format.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.RouteOptimization.V1.DataFormat DataFormat {
      get { return dataFormat_; }
      set {
        dataFormat_ = value;
      }
    }

    private object destination_;
    /// <summary>Enum of possible cases for the "destination" oneof.</summary>
    public enum DestinationOneofCase {
      None = 0,
      GcsDestination = 1,
    }
    private DestinationOneofCase destinationCase_ = DestinationOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DestinationOneofCase DestinationCase {
      get { return destinationCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDestination() {
      destinationCase_ = DestinationOneofCase.None;
      destination_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as OutputConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(OutputConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(GcsDestination, other.GcsDestination)) return false;
      if (DataFormat != other.DataFormat) return false;
      if (DestinationCase != other.DestinationCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (destinationCase_ == DestinationOneofCase.GcsDestination) hash ^= GcsDestination.GetHashCode();
      if (DataFormat != global::Google.Maps.RouteOptimization.V1.DataFormat.Unspecified) hash ^= DataFormat.GetHashCode();
      hash ^= (int) destinationCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (destinationCase_ == DestinationOneofCase.GcsDestination) {
        output.WriteRawTag(10);
        output.WriteMessage(GcsDestination);
      }
      if (DataFormat != global::Google.Maps.RouteOptimization.V1.DataFormat.Unspecified) {
        output.WriteRawTag(16);
        output.WriteEnum((int) DataFormat);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (destinationCase_ == DestinationOneofCase.GcsDestination) {
        output.WriteRawTag(10);
        output.WriteMessage(GcsDestination);
      }
      if (DataFormat != global::Google.Maps.RouteOptimization.V1.DataFormat.Unspecified) {
        output.WriteRawTag(16);
        output.WriteEnum((int) DataFormat);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (destinationCase_ == DestinationOneofCase.GcsDestination) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(GcsDestination);
      }
      if (DataFormat != global::Google.Maps.RouteOptimization.V1.DataFormat.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DataFormat);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(OutputConfig other) {
      if (other == null) {
        return;
      }
      if (other.DataFormat != global::Google.Maps.RouteOptimization.V1.DataFormat.Unspecified) {
        DataFormat = other.DataFormat;
      }
      switch (other.DestinationCase) {
        case DestinationOneofCase.GcsDestination:
          if (GcsDestination == null) {
            GcsDestination = new global::Google.Maps.RouteOptimization.V1.GcsDestination();
          }
          GcsDestination.MergeFrom(other.GcsDestination);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Google.Maps.RouteOptimization.V1.GcsDestination subBuilder = new global::Google.Maps.RouteOptimization.V1.GcsDestination();
            if (destinationCase_ == DestinationOneofCase.GcsDestination) {
              subBuilder.MergeFrom(GcsDestination);
            }
            input.ReadMessage(subBuilder);
            GcsDestination = subBuilder;
            break;
          }
          case 16: {
            DataFormat = (global::Google.Maps.RouteOptimization.V1.DataFormat) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::Google.Maps.RouteOptimization.V1.GcsDestination subBuilder = new global::Google.Maps.RouteOptimization.V1.GcsDestination();
            if (destinationCase_ == DestinationOneofCase.GcsDestination) {
              subBuilder.MergeFrom(GcsDestination);
            }
            input.ReadMessage(subBuilder);
            GcsDestination = subBuilder;
            break;
          }
          case 16: {
            DataFormat = (global::Google.Maps.RouteOptimization.V1.DataFormat) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// The Google Cloud Storage location where the input file will be read from.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class GcsSource : pb::IMessage<GcsSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GcsSource> _parser = new pb::MessageParser<GcsSource>(() => new GcsSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<GcsSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[24]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GcsSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GcsSource(GcsSource other) : this() {
      uri_ = other.uri_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GcsSource Clone() {
      return new GcsSource(this);
    }

    /// <summary>Field number for the "uri" field.</summary>
    public const int UriFieldNumber = 1;
    private string uri_ = "";
    /// <summary>
    /// Required. URI of a Google Cloud Storage object with the format
    /// `gs://bucket/path/to/object`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Uri {
      get { return uri_; }
      set {
        uri_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as GcsSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(GcsSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Uri != other.Uri) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Uri.Length != 0) hash ^= Uri.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Uri.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Uri);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Uri.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Uri);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Uri.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Uri);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(GcsSource other) {
      if (other == null) {
        return;
      }
      if (other.Uri.Length != 0) {
        Uri = other.Uri;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Uri = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Uri = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// The Google Cloud Storage location where the output file(s) will be written
  /// to.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class GcsDestination : pb::IMessage<GcsDestination>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GcsDestination> _parser = new pb::MessageParser<GcsDestination>(() => new GcsDestination());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<GcsDestination> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.RouteOptimization.V1.RouteOptimizationServiceReflection.Descriptor.MessageTypes[25]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GcsDestination() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GcsDestination(GcsDestination other) : this() {
      uri_ = other.uri_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GcsDestination Clone() {
      return new GcsDestination(this);
    }

    /// <summary>Field number for the "uri" field.</summary>
    public const int UriFieldNumber = 1;
    private string uri_ = "";
    /// <summary>
    /// Required. Google Cloud Storage URI.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Uri {
      get { return uri_; }
      set {
        uri_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as GcsDestination);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(GcsDestination other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Uri != other.Uri) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Uri.Length != 0) hash ^= Uri.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Uri.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Uri);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Uri.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Uri);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Uri.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Uri);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(GcsDestination other) {
      if (other == null) {
        return;
      }
      if (other.Uri.Length != 0) {
        Uri = other.Uri;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Uri = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Uri = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
