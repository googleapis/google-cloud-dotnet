// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/shopping/merchant/inventories/v1/inventories_common.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Shopping.Merchant.Inventories.V1 {

  /// <summary>Holder for reflection information generated from google/shopping/merchant/inventories/v1/inventories_common.proto</summary>
  public static partial class InventoriesCommonReflection {

    #region Descriptor
    /// <summary>File descriptor for google/shopping/merchant/inventories/v1/inventories_common.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static InventoriesCommonReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CkBnb29nbGUvc2hvcHBpbmcvbWVyY2hhbnQvaW52ZW50b3JpZXMvdjEvaW52",
            "ZW50b3JpZXNfY29tbW9uLnByb3RvEidnb29nbGUuc2hvcHBpbmcubWVyY2hh",
            "bnQuaW52ZW50b3JpZXMudjEaH2dvb2dsZS9hcGkvZmllbGRfYmVoYXZpb3Iu",
            "cHJvdG8aIGdvb2dsZS9zaG9wcGluZy90eXBlL3R5cGVzLnByb3RvGhpnb29n",
            "bGUvdHlwZS9pbnRlcnZhbC5wcm90byLSCAoYTG9jYWxJbnZlbnRvcnlBdHRy",
            "aWJ1dGVzEi8KBXByaWNlGAEgASgLMhsuZ29vZ2xlLnNob3BwaW5nLnR5cGUu",
            "UHJpY2VCA+BBARI0CgpzYWxlX3ByaWNlGAIgASgLMhsuZ29vZ2xlLnNob3Bw",
            "aW5nLnR5cGUuUHJpY2VCA+BBARI9ChlzYWxlX3ByaWNlX2VmZmVjdGl2ZV9k",
            "YXRlGAMgASgLMhUuZ29vZ2xlLnR5cGUuSW50ZXJ2YWxCA+BBARJpCgxhdmFp",
            "bGFiaWxpdHkYBCABKA4yTi5nb29nbGUuc2hvcHBpbmcubWVyY2hhbnQuaW52",
            "ZW50b3JpZXMudjEuTG9jYWxJbnZlbnRvcnlBdHRyaWJ1dGVzLkF2YWlsYWJp",
            "bGl0eUgAiAEBEhoKCHF1YW50aXR5GAUgASgDQgPgQQFIAYgBARJvCg1waWNr",
            "dXBfbWV0aG9kGAYgASgOMk4uZ29vZ2xlLnNob3BwaW5nLm1lcmNoYW50Lmlu",
            "dmVudG9yaWVzLnYxLkxvY2FsSW52ZW50b3J5QXR0cmlidXRlcy5QaWNrdXBN",
            "ZXRob2RCA+BBAUgCiAEBEmkKCnBpY2t1cF9zbGEYByABKA4ySy5nb29nbGUu",
            "c2hvcHBpbmcubWVyY2hhbnQuaW52ZW50b3JpZXMudjEuTG9jYWxJbnZlbnRv",
            "cnlBdHRyaWJ1dGVzLlBpY2t1cFNsYUID4EEBSAOIAQESKgoYaW5zdG9yZV9w",
            "cm9kdWN0X2xvY2F0aW9uGAggASgJQgPgQQFIBIgBASKPAQoMQXZhaWxhYmls",
            "aXR5EiwKKExPQ0FMX0lOVkVOVE9SWV9BVkFJTEFCSUxJVFlfVU5TUEVDSUZJ",
            "RUQQABIMCghJTl9TVE9DSxABEhgKFExJTUlURURfQVZBSUxBQklMSVRZEAIS",
            "FwoTT05fRElTUExBWV9UT19PUkRFUhADEhAKDE9VVF9PRl9TVE9DSxAEImkK",
            "DFBpY2t1cE1ldGhvZBIdChlQSUNLVVBfTUVUSE9EX1VOU1BFQ0lGSUVEEAAS",
            "BwoDQlVZEAESCwoHUkVTRVJWRRACEhEKDVNISVBfVE9fU1RPUkUQAxIRCg1O",
            "T1RfU1VQUE9SVEVEEAQipwEKCVBpY2t1cFNsYRIaChZQSUNLVVBfU0xBX1VO",
            "U1BFQ0lGSUVEEAASDAoIU0FNRV9EQVkQARIMCghORVhUX0RBWRACEgsKB1RX",
            "T19EQVkQAxINCglUSFJFRV9EQVkQBBIMCghGT1VSX0RBWRAFEgwKCEZJVkVf",
            "REFZEAYSCwoHU0lYX0RBWRAHEg0KCVNFVkVOX0RBWRAIEg4KCk1VTFRJX1dF",
            "RUsQCUIPCg1fYXZhaWxhYmlsaXR5QgsKCV9xdWFudGl0eUIQCg5fcGlja3Vw",
            "X21ldGhvZEINCgtfcGlja3VwX3NsYUIbChlfaW5zdG9yZV9wcm9kdWN0X2xv",
            "Y2F0aW9uIqgDChtSZWdpb25hbEludmVudG9yeUF0dHJpYnV0ZXMSLwoFcHJp",
            "Y2UYASABKAsyGy5nb29nbGUuc2hvcHBpbmcudHlwZS5QcmljZUID4EEBEjQK",
            "CnNhbGVfcHJpY2UYAiABKAsyGy5nb29nbGUuc2hvcHBpbmcudHlwZS5Qcmlj",
            "ZUID4EEBEj0KGXNhbGVfcHJpY2VfZWZmZWN0aXZlX2RhdGUYAyABKAsyFS5n",
            "b29nbGUudHlwZS5JbnRlcnZhbEID4EEBEnEKDGF2YWlsYWJpbGl0eRgEIAEo",
            "DjJRLmdvb2dsZS5zaG9wcGluZy5tZXJjaGFudC5pbnZlbnRvcmllcy52MS5S",
            "ZWdpb25hbEludmVudG9yeUF0dHJpYnV0ZXMuQXZhaWxhYmlsaXR5QgPgQQFI",
            "AIgBASJfCgxBdmFpbGFiaWxpdHkSLworUkVHSU9OQUxfSU5WRU5UT1JZX0FW",
            "QUlMQUJJTElUWV9VTlNQRUNJRklFRBAAEgwKCElOX1NUT0NLEAESEAoMT1VU",
            "X09GX1NUT0NLEAJCDwoNX2F2YWlsYWJpbGl0eUKeAgorY29tLmdvb2dsZS5z",
            "aG9wcGluZy5tZXJjaGFudC5pbnZlbnRvcmllcy52MUIWSW52ZW50b3JpZXND",
            "b21tb25Qcm90b1ABWlNjbG91ZC5nb29nbGUuY29tL2dvL3Nob3BwaW5nL21l",
            "cmNoYW50L2ludmVudG9yaWVzL2FwaXYxL2ludmVudG9yaWVzcGI7aW52ZW50",
            "b3JpZXNwYqoCJ0dvb2dsZS5TaG9wcGluZy5NZXJjaGFudC5JbnZlbnRvcmll",
            "cy5WMcoCJ0dvb2dsZVxTaG9wcGluZ1xNZXJjaGFudFxJbnZlbnRvcmllc1xW",
            "MeoCK0dvb2dsZTo6U2hvcHBpbmc6Ok1lcmNoYW50OjpJbnZlbnRvcmllczo6",
            "VjFiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.FieldBehaviorReflection.Descriptor, global::Google.Shopping.Type.TypesReflection.Descriptor, global::Google.Type.IntervalReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Shopping.Merchant.Inventories.V1.LocalInventoryAttributes), global::Google.Shopping.Merchant.Inventories.V1.LocalInventoryAttributes.Parser, new[]{ "Price", "SalePrice", "SalePriceEffectiveDate", "Availability", "Quantity", "PickupMethod", "PickupSla", "InstoreProductLocation" }, new[]{ "Availability", "Quantity", "PickupMethod", "PickupSla", "InstoreProductLocation" }, new[]{ typeof(global::Google.Shopping.Merchant.Inventories.V1.LocalInventoryAttributes.Types.Availability), typeof(global::Google.Shopping.Merchant.Inventories.V1.LocalInventoryAttributes.Types.PickupMethod), typeof(global::Google.Shopping.Merchant.Inventories.V1.LocalInventoryAttributes.Types.PickupSla) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Shopping.Merchant.Inventories.V1.RegionalInventoryAttributes), global::Google.Shopping.Merchant.Inventories.V1.RegionalInventoryAttributes.Parser, new[]{ "Price", "SalePrice", "SalePriceEffectiveDate", "Availability" }, new[]{ "Availability" }, new[]{ typeof(global::Google.Shopping.Merchant.Inventories.V1.RegionalInventoryAttributes.Types.Availability) }, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Local inventory attributes.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class LocalInventoryAttributes : pb::IMessage<LocalInventoryAttributes>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LocalInventoryAttributes> _parser = new pb::MessageParser<LocalInventoryAttributes>(() => new LocalInventoryAttributes());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<LocalInventoryAttributes> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Shopping.Merchant.Inventories.V1.InventoriesCommonReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LocalInventoryAttributes() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LocalInventoryAttributes(LocalInventoryAttributes other) : this() {
      _hasBits0 = other._hasBits0;
      price_ = other.price_ != null ? other.price_.Clone() : null;
      salePrice_ = other.salePrice_ != null ? other.salePrice_.Clone() : null;
      salePriceEffectiveDate_ = other.salePriceEffectiveDate_ != null ? other.salePriceEffectiveDate_.Clone() : null;
      availability_ = other.availability_;
      quantity_ = other.quantity_;
      pickupMethod_ = other.pickupMethod_;
      pickupSla_ = other.pickupSla_;
      instoreProductLocation_ = other.instoreProductLocation_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LocalInventoryAttributes Clone() {
      return new LocalInventoryAttributes(this);
    }

    /// <summary>Field number for the "price" field.</summary>
    public const int PriceFieldNumber = 1;
    private global::Google.Shopping.Type.Price price_;
    /// <summary>
    /// Optional. Price of the product at this store.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Shopping.Type.Price Price {
      get { return price_; }
      set {
        price_ = value;
      }
    }

    /// <summary>Field number for the "sale_price" field.</summary>
    public const int SalePriceFieldNumber = 2;
    private global::Google.Shopping.Type.Price salePrice_;
    /// <summary>
    /// Optional. Sale price of the product at this store. Mandatory if
    /// [`salePriceEffectiveDate`][LocalInventory.sale_price_effective_date] is
    /// defined.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Shopping.Type.Price SalePrice {
      get { return salePrice_; }
      set {
        salePrice_ = value;
      }
    }

    /// <summary>Field number for the "sale_price_effective_date" field.</summary>
    public const int SalePriceEffectiveDateFieldNumber = 3;
    private global::Google.Type.Interval salePriceEffectiveDate_;
    /// <summary>
    /// Optional. The `TimePeriod` of the
    /// sale at this store.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Type.Interval SalePriceEffectiveDate {
      get { return salePriceEffectiveDate_; }
      set {
        salePriceEffectiveDate_ = value;
      }
    }

    /// <summary>Field number for the "availability" field.</summary>
    public const int AvailabilityFieldNumber = 4;
    private readonly static global::Google.Shopping.Merchant.Inventories.V1.LocalInventoryAttributes.Types.Availability AvailabilityDefaultValue = global::Google.Shopping.Merchant.Inventories.V1.LocalInventoryAttributes.Types.Availability.LocalInventoryAvailabilityUnspecified;

    private global::Google.Shopping.Merchant.Inventories.V1.LocalInventoryAttributes.Types.Availability availability_;
    /// <summary>
    /// [Availability](https://support.google.com/merchants/answer/3061342) of the
    /// product at this store.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Shopping.Merchant.Inventories.V1.LocalInventoryAttributes.Types.Availability Availability {
      get { if ((_hasBits0 & 1) != 0) { return availability_; } else { return AvailabilityDefaultValue; } }
      set {
        _hasBits0 |= 1;
        availability_ = value;
      }
    }
    /// <summary>Gets whether the "availability" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAvailability {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "availability" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAvailability() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "quantity" field.</summary>
    public const int QuantityFieldNumber = 5;
    private readonly static long QuantityDefaultValue = 0L;

    private long quantity_;
    /// <summary>
    /// Optional. Quantity of the product available at this store. Must be greater
    /// than or equal to zero.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Quantity {
      get { if ((_hasBits0 & 2) != 0) { return quantity_; } else { return QuantityDefaultValue; } }
      set {
        _hasBits0 |= 2;
        quantity_ = value;
      }
    }
    /// <summary>Gets whether the "quantity" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasQuantity {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "quantity" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearQuantity() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "pickup_method" field.</summary>
    public const int PickupMethodFieldNumber = 6;
    private readonly static global::Google.Shopping.Merchant.Inventories.V1.LocalInventoryAttributes.Types.PickupMethod PickupMethodDefaultValue = global::Google.Shopping.Merchant.Inventories.V1.LocalInventoryAttributes.Types.PickupMethod.Unspecified;

    private global::Google.Shopping.Merchant.Inventories.V1.LocalInventoryAttributes.Types.PickupMethod pickupMethod_;
    /// <summary>
    /// Optional. Supported [pickup
    /// method](https://support.google.com/merchants/answer/3061342) for this
    /// product. Unless the value is `"not supported"`, this field must be
    /// submitted together with `pickupSla`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Shopping.Merchant.Inventories.V1.LocalInventoryAttributes.Types.PickupMethod PickupMethod {
      get { if ((_hasBits0 & 4) != 0) { return pickupMethod_; } else { return PickupMethodDefaultValue; } }
      set {
        _hasBits0 |= 4;
        pickupMethod_ = value;
      }
    }
    /// <summary>Gets whether the "pickup_method" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPickupMethod {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "pickup_method" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPickupMethod() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "pickup_sla" field.</summary>
    public const int PickupSlaFieldNumber = 7;
    private readonly static global::Google.Shopping.Merchant.Inventories.V1.LocalInventoryAttributes.Types.PickupSla PickupSlaDefaultValue = global::Google.Shopping.Merchant.Inventories.V1.LocalInventoryAttributes.Types.PickupSla.Unspecified;

    private global::Google.Shopping.Merchant.Inventories.V1.LocalInventoryAttributes.Types.PickupSla pickupSla_;
    /// <summary>
    /// Optional. Relative time period from the order date for an order for this
    /// product, from this store, to be ready for pickup. Must be submitted with
    /// `pickupMethod`. See more details
    /// [here](https://support.google.com/merchants/answer/3061342).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Shopping.Merchant.Inventories.V1.LocalInventoryAttributes.Types.PickupSla PickupSla {
      get { if ((_hasBits0 & 8) != 0) { return pickupSla_; } else { return PickupSlaDefaultValue; } }
      set {
        _hasBits0 |= 8;
        pickupSla_ = value;
      }
    }
    /// <summary>Gets whether the "pickup_sla" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPickupSla {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "pickup_sla" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPickupSla() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "instore_product_location" field.</summary>
    public const int InstoreProductLocationFieldNumber = 8;
    private readonly static string InstoreProductLocationDefaultValue = "";

    private string instoreProductLocation_;
    /// <summary>
    /// Optional. Location of the product inside the store. Maximum length is 20
    /// bytes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string InstoreProductLocation {
      get { return instoreProductLocation_ ?? InstoreProductLocationDefaultValue; }
      set {
        instoreProductLocation_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "instore_product_location" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasInstoreProductLocation {
      get { return instoreProductLocation_ != null; }
    }
    /// <summary>Clears the value of the "instore_product_location" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearInstoreProductLocation() {
      instoreProductLocation_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as LocalInventoryAttributes);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(LocalInventoryAttributes other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Price, other.Price)) return false;
      if (!object.Equals(SalePrice, other.SalePrice)) return false;
      if (!object.Equals(SalePriceEffectiveDate, other.SalePriceEffectiveDate)) return false;
      if (Availability != other.Availability) return false;
      if (Quantity != other.Quantity) return false;
      if (PickupMethod != other.PickupMethod) return false;
      if (PickupSla != other.PickupSla) return false;
      if (InstoreProductLocation != other.InstoreProductLocation) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (price_ != null) hash ^= Price.GetHashCode();
      if (salePrice_ != null) hash ^= SalePrice.GetHashCode();
      if (salePriceEffectiveDate_ != null) hash ^= SalePriceEffectiveDate.GetHashCode();
      if (HasAvailability) hash ^= Availability.GetHashCode();
      if (HasQuantity) hash ^= Quantity.GetHashCode();
      if (HasPickupMethod) hash ^= PickupMethod.GetHashCode();
      if (HasPickupSla) hash ^= PickupSla.GetHashCode();
      if (HasInstoreProductLocation) hash ^= InstoreProductLocation.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (price_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Price);
      }
      if (salePrice_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(SalePrice);
      }
      if (salePriceEffectiveDate_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(SalePriceEffectiveDate);
      }
      if (HasAvailability) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Availability);
      }
      if (HasQuantity) {
        output.WriteRawTag(40);
        output.WriteInt64(Quantity);
      }
      if (HasPickupMethod) {
        output.WriteRawTag(48);
        output.WriteEnum((int) PickupMethod);
      }
      if (HasPickupSla) {
        output.WriteRawTag(56);
        output.WriteEnum((int) PickupSla);
      }
      if (HasInstoreProductLocation) {
        output.WriteRawTag(66);
        output.WriteString(InstoreProductLocation);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (price_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Price);
      }
      if (salePrice_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(SalePrice);
      }
      if (salePriceEffectiveDate_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(SalePriceEffectiveDate);
      }
      if (HasAvailability) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Availability);
      }
      if (HasQuantity) {
        output.WriteRawTag(40);
        output.WriteInt64(Quantity);
      }
      if (HasPickupMethod) {
        output.WriteRawTag(48);
        output.WriteEnum((int) PickupMethod);
      }
      if (HasPickupSla) {
        output.WriteRawTag(56);
        output.WriteEnum((int) PickupSla);
      }
      if (HasInstoreProductLocation) {
        output.WriteRawTag(66);
        output.WriteString(InstoreProductLocation);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (price_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Price);
      }
      if (salePrice_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SalePrice);
      }
      if (salePriceEffectiveDate_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SalePriceEffectiveDate);
      }
      if (HasAvailability) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Availability);
      }
      if (HasQuantity) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Quantity);
      }
      if (HasPickupMethod) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) PickupMethod);
      }
      if (HasPickupSla) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) PickupSla);
      }
      if (HasInstoreProductLocation) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(InstoreProductLocation);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(LocalInventoryAttributes other) {
      if (other == null) {
        return;
      }
      if (other.price_ != null) {
        if (price_ == null) {
          Price = new global::Google.Shopping.Type.Price();
        }
        Price.MergeFrom(other.Price);
      }
      if (other.salePrice_ != null) {
        if (salePrice_ == null) {
          SalePrice = new global::Google.Shopping.Type.Price();
        }
        SalePrice.MergeFrom(other.SalePrice);
      }
      if (other.salePriceEffectiveDate_ != null) {
        if (salePriceEffectiveDate_ == null) {
          SalePriceEffectiveDate = new global::Google.Type.Interval();
        }
        SalePriceEffectiveDate.MergeFrom(other.SalePriceEffectiveDate);
      }
      if (other.HasAvailability) {
        Availability = other.Availability;
      }
      if (other.HasQuantity) {
        Quantity = other.Quantity;
      }
      if (other.HasPickupMethod) {
        PickupMethod = other.PickupMethod;
      }
      if (other.HasPickupSla) {
        PickupSla = other.PickupSla;
      }
      if (other.HasInstoreProductLocation) {
        InstoreProductLocation = other.InstoreProductLocation;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (price_ == null) {
              Price = new global::Google.Shopping.Type.Price();
            }
            input.ReadMessage(Price);
            break;
          }
          case 18: {
            if (salePrice_ == null) {
              SalePrice = new global::Google.Shopping.Type.Price();
            }
            input.ReadMessage(SalePrice);
            break;
          }
          case 26: {
            if (salePriceEffectiveDate_ == null) {
              SalePriceEffectiveDate = new global::Google.Type.Interval();
            }
            input.ReadMessage(SalePriceEffectiveDate);
            break;
          }
          case 32: {
            Availability = (global::Google.Shopping.Merchant.Inventories.V1.LocalInventoryAttributes.Types.Availability) input.ReadEnum();
            break;
          }
          case 40: {
            Quantity = input.ReadInt64();
            break;
          }
          case 48: {
            PickupMethod = (global::Google.Shopping.Merchant.Inventories.V1.LocalInventoryAttributes.Types.PickupMethod) input.ReadEnum();
            break;
          }
          case 56: {
            PickupSla = (global::Google.Shopping.Merchant.Inventories.V1.LocalInventoryAttributes.Types.PickupSla) input.ReadEnum();
            break;
          }
          case 66: {
            InstoreProductLocation = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (price_ == null) {
              Price = new global::Google.Shopping.Type.Price();
            }
            input.ReadMessage(Price);
            break;
          }
          case 18: {
            if (salePrice_ == null) {
              SalePrice = new global::Google.Shopping.Type.Price();
            }
            input.ReadMessage(SalePrice);
            break;
          }
          case 26: {
            if (salePriceEffectiveDate_ == null) {
              SalePriceEffectiveDate = new global::Google.Type.Interval();
            }
            input.ReadMessage(SalePriceEffectiveDate);
            break;
          }
          case 32: {
            Availability = (global::Google.Shopping.Merchant.Inventories.V1.LocalInventoryAttributes.Types.Availability) input.ReadEnum();
            break;
          }
          case 40: {
            Quantity = input.ReadInt64();
            break;
          }
          case 48: {
            PickupMethod = (global::Google.Shopping.Merchant.Inventories.V1.LocalInventoryAttributes.Types.PickupMethod) input.ReadEnum();
            break;
          }
          case 56: {
            PickupSla = (global::Google.Shopping.Merchant.Inventories.V1.LocalInventoryAttributes.Types.PickupSla) input.ReadEnum();
            break;
          }
          case 66: {
            InstoreProductLocation = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the LocalInventoryAttributes message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// [Availability](https://support.google.com/merchants/answer/3061342) of the
      /// product at this store.
      /// </summary>
      public enum Availability {
        /// <summary>
        /// Indicates that the availability is unspecified.
        /// </summary>
        [pbr::OriginalName("LOCAL_INVENTORY_AVAILABILITY_UNSPECIFIED")] LocalInventoryAvailabilityUnspecified = 0,
        /// <summary>
        /// Indicates that the product is in stock.
        /// </summary>
        [pbr::OriginalName("IN_STOCK")] InStock = 1,
        /// <summary>
        /// Indicates that the product is out of stock.
        /// </summary>
        [pbr::OriginalName("LIMITED_AVAILABILITY")] LimitedAvailability = 2,
        /// <summary>
        /// Indicates that the product is on display to order.
        /// </summary>
        [pbr::OriginalName("ON_DISPLAY_TO_ORDER")] OnDisplayToOrder = 3,
        /// <summary>
        /// Indicates that the product is out of stock.
        /// </summary>
        [pbr::OriginalName("OUT_OF_STOCK")] OutOfStock = 4,
      }

      /// <summary>
      /// Supported [pickup
      /// method](https://support.google.com/merchants/answer/3061342) for this
      /// product. Unless the value is `"not supported"`, this field must be
      /// submitted together with `pickupSla`.
      /// </summary>
      public enum PickupMethod {
        /// <summary>
        /// Indicates that the pickup method is unspecified.
        /// </summary>
        [pbr::OriginalName("PICKUP_METHOD_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Indicates that the pickup method is Buy.
        /// </summary>
        [pbr::OriginalName("BUY")] Buy = 1,
        /// <summary>
        /// Indicates that the pickup method is Reserve.
        /// </summary>
        [pbr::OriginalName("RESERVE")] Reserve = 2,
        /// <summary>
        /// Indicates that the pickup method is Ship to store.
        /// </summary>
        [pbr::OriginalName("SHIP_TO_STORE")] ShipToStore = 3,
        /// <summary>
        /// Indicates that the pickup method is not supported.
        /// </summary>
        [pbr::OriginalName("NOT_SUPPORTED")] NotSupported = 4,
      }

      /// <summary>
      /// Relative time period from the order date for an order for this product,
      /// from this store, to be ready for pickup. Must be submitted with
      /// `pickupMethod`. See more details
      /// [here](https://support.google.com/merchants/answer/3061342).
      /// </summary>
      public enum PickupSla {
        /// <summary>
        /// Indicates that the pickup SLA is unspecified.
        /// </summary>
        [pbr::OriginalName("PICKUP_SLA_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Indicates that the pickup SLA is same day.
        /// </summary>
        [pbr::OriginalName("SAME_DAY")] SameDay = 1,
        /// <summary>
        /// Indicates that the pickup SLA is next day.
        /// </summary>
        [pbr::OriginalName("NEXT_DAY")] NextDay = 2,
        /// <summary>
        /// Indicates that the pickup SLA is two days.
        /// </summary>
        [pbr::OriginalName("TWO_DAY")] TwoDay = 3,
        /// <summary>
        /// Indicates that the pickup SLA is three days.
        /// </summary>
        [pbr::OriginalName("THREE_DAY")] ThreeDay = 4,
        /// <summary>
        /// Indicates that the pickup SLA is four days.
        /// </summary>
        [pbr::OriginalName("FOUR_DAY")] FourDay = 5,
        /// <summary>
        /// Indicates that the pickup SLA is five days.
        /// </summary>
        [pbr::OriginalName("FIVE_DAY")] FiveDay = 6,
        /// <summary>
        /// Indicates that the pickup SLA is six days.
        /// </summary>
        [pbr::OriginalName("SIX_DAY")] SixDay = 7,
        /// <summary>
        /// Indicates that the pickup SLA is seven days.
        /// </summary>
        [pbr::OriginalName("SEVEN_DAY")] SevenDay = 8,
        /// <summary>
        /// Indicates that the pickup SLA is multi-week.
        /// </summary>
        [pbr::OriginalName("MULTI_WEEK")] MultiWeek = 9,
      }

    }
    #endregion

  }

  /// <summary>
  /// Regional inventory attributes.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class RegionalInventoryAttributes : pb::IMessage<RegionalInventoryAttributes>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RegionalInventoryAttributes> _parser = new pb::MessageParser<RegionalInventoryAttributes>(() => new RegionalInventoryAttributes());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RegionalInventoryAttributes> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Shopping.Merchant.Inventories.V1.InventoriesCommonReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RegionalInventoryAttributes() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RegionalInventoryAttributes(RegionalInventoryAttributes other) : this() {
      _hasBits0 = other._hasBits0;
      price_ = other.price_ != null ? other.price_.Clone() : null;
      salePrice_ = other.salePrice_ != null ? other.salePrice_.Clone() : null;
      salePriceEffectiveDate_ = other.salePriceEffectiveDate_ != null ? other.salePriceEffectiveDate_.Clone() : null;
      availability_ = other.availability_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RegionalInventoryAttributes Clone() {
      return new RegionalInventoryAttributes(this);
    }

    /// <summary>Field number for the "price" field.</summary>
    public const int PriceFieldNumber = 1;
    private global::Google.Shopping.Type.Price price_;
    /// <summary>
    /// Optional. Price of the product in this region.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Shopping.Type.Price Price {
      get { return price_; }
      set {
        price_ = value;
      }
    }

    /// <summary>Field number for the "sale_price" field.</summary>
    public const int SalePriceFieldNumber = 2;
    private global::Google.Shopping.Type.Price salePrice_;
    /// <summary>
    /// Optional. Sale price of the product in this region. Mandatory if
    /// [`salePriceEffectiveDate`][RegionalInventory.sale_price_effective_date] is
    /// defined.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Shopping.Type.Price SalePrice {
      get { return salePrice_; }
      set {
        salePrice_ = value;
      }
    }

    /// <summary>Field number for the "sale_price_effective_date" field.</summary>
    public const int SalePriceEffectiveDateFieldNumber = 3;
    private global::Google.Type.Interval salePriceEffectiveDate_;
    /// <summary>
    /// Optional. The `TimePeriod` of the
    /// sale price in this region.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Type.Interval SalePriceEffectiveDate {
      get { return salePriceEffectiveDate_; }
      set {
        salePriceEffectiveDate_ = value;
      }
    }

    /// <summary>Field number for the "availability" field.</summary>
    public const int AvailabilityFieldNumber = 4;
    private readonly static global::Google.Shopping.Merchant.Inventories.V1.RegionalInventoryAttributes.Types.Availability AvailabilityDefaultValue = global::Google.Shopping.Merchant.Inventories.V1.RegionalInventoryAttributes.Types.Availability.RegionalInventoryAvailabilityUnspecified;

    private global::Google.Shopping.Merchant.Inventories.V1.RegionalInventoryAttributes.Types.Availability availability_;
    /// <summary>
    /// Optional.
    /// [Availability](https://support.google.com/merchants/answer/14644124) of the
    /// product in this region.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Shopping.Merchant.Inventories.V1.RegionalInventoryAttributes.Types.Availability Availability {
      get { if ((_hasBits0 & 1) != 0) { return availability_; } else { return AvailabilityDefaultValue; } }
      set {
        _hasBits0 |= 1;
        availability_ = value;
      }
    }
    /// <summary>Gets whether the "availability" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAvailability {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "availability" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAvailability() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RegionalInventoryAttributes);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RegionalInventoryAttributes other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Price, other.Price)) return false;
      if (!object.Equals(SalePrice, other.SalePrice)) return false;
      if (!object.Equals(SalePriceEffectiveDate, other.SalePriceEffectiveDate)) return false;
      if (Availability != other.Availability) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (price_ != null) hash ^= Price.GetHashCode();
      if (salePrice_ != null) hash ^= SalePrice.GetHashCode();
      if (salePriceEffectiveDate_ != null) hash ^= SalePriceEffectiveDate.GetHashCode();
      if (HasAvailability) hash ^= Availability.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (price_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Price);
      }
      if (salePrice_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(SalePrice);
      }
      if (salePriceEffectiveDate_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(SalePriceEffectiveDate);
      }
      if (HasAvailability) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Availability);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (price_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Price);
      }
      if (salePrice_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(SalePrice);
      }
      if (salePriceEffectiveDate_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(SalePriceEffectiveDate);
      }
      if (HasAvailability) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Availability);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (price_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Price);
      }
      if (salePrice_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SalePrice);
      }
      if (salePriceEffectiveDate_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SalePriceEffectiveDate);
      }
      if (HasAvailability) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Availability);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RegionalInventoryAttributes other) {
      if (other == null) {
        return;
      }
      if (other.price_ != null) {
        if (price_ == null) {
          Price = new global::Google.Shopping.Type.Price();
        }
        Price.MergeFrom(other.Price);
      }
      if (other.salePrice_ != null) {
        if (salePrice_ == null) {
          SalePrice = new global::Google.Shopping.Type.Price();
        }
        SalePrice.MergeFrom(other.SalePrice);
      }
      if (other.salePriceEffectiveDate_ != null) {
        if (salePriceEffectiveDate_ == null) {
          SalePriceEffectiveDate = new global::Google.Type.Interval();
        }
        SalePriceEffectiveDate.MergeFrom(other.SalePriceEffectiveDate);
      }
      if (other.HasAvailability) {
        Availability = other.Availability;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (price_ == null) {
              Price = new global::Google.Shopping.Type.Price();
            }
            input.ReadMessage(Price);
            break;
          }
          case 18: {
            if (salePrice_ == null) {
              SalePrice = new global::Google.Shopping.Type.Price();
            }
            input.ReadMessage(SalePrice);
            break;
          }
          case 26: {
            if (salePriceEffectiveDate_ == null) {
              SalePriceEffectiveDate = new global::Google.Type.Interval();
            }
            input.ReadMessage(SalePriceEffectiveDate);
            break;
          }
          case 32: {
            Availability = (global::Google.Shopping.Merchant.Inventories.V1.RegionalInventoryAttributes.Types.Availability) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (price_ == null) {
              Price = new global::Google.Shopping.Type.Price();
            }
            input.ReadMessage(Price);
            break;
          }
          case 18: {
            if (salePrice_ == null) {
              SalePrice = new global::Google.Shopping.Type.Price();
            }
            input.ReadMessage(SalePrice);
            break;
          }
          case 26: {
            if (salePriceEffectiveDate_ == null) {
              SalePriceEffectiveDate = new global::Google.Type.Interval();
            }
            input.ReadMessage(SalePriceEffectiveDate);
            break;
          }
          case 32: {
            Availability = (global::Google.Shopping.Merchant.Inventories.V1.RegionalInventoryAttributes.Types.Availability) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the RegionalInventoryAttributes message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// [Availability](https://support.google.com/merchants/answer/14644124) of the
      /// product in this region.
      /// </summary>
      public enum Availability {
        /// <summary>
        /// Indicates that the availability is unspecified.
        /// </summary>
        [pbr::OriginalName("REGIONAL_INVENTORY_AVAILABILITY_UNSPECIFIED")] RegionalInventoryAvailabilityUnspecified = 0,
        /// <summary>
        /// Indicates that the product is in stock.
        /// </summary>
        [pbr::OriginalName("IN_STOCK")] InStock = 1,
        /// <summary>
        /// Indicates that the product is out of stock.
        /// </summary>
        [pbr::OriginalName("OUT_OF_STOCK")] OutOfStock = 2,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
