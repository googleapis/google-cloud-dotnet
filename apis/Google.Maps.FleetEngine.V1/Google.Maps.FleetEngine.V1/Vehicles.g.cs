// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/maps/fleetengine/v1/vehicles.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Maps.FleetEngine.V1 {

  /// <summary>Holder for reflection information generated from google/maps/fleetengine/v1/vehicles.proto</summary>
  public static partial class VehiclesReflection {

    #region Descriptor
    /// <summary>File descriptor for google/maps/fleetengine/v1/vehicles.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static VehiclesReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cilnb29nbGUvbWFwcy9mbGVldGVuZ2luZS92MS92ZWhpY2xlcy5wcm90bxIT",
            "bWFwcy5mbGVldGVuZ2luZS52MRofZ29vZ2xlL2FwaS9maWVsZF9iZWhhdmlv",
            "ci5wcm90bxoZZ29vZ2xlL2FwaS9yZXNvdXJjZS5wcm90bxosZ29vZ2xlL21h",
            "cHMvZmxlZXRlbmdpbmUvdjEvZmxlZXRlbmdpbmUucHJvdG8aH2dvb2dsZS9w",
            "cm90b2J1Zi90aW1lc3RhbXAucHJvdG8aHmdvb2dsZS9wcm90b2J1Zi93cmFw",
            "cGVycy5wcm90byKlDAoHVmVoaWNsZRIRCgRuYW1lGAEgASgJQgPgQQMSOAoN",
            "dmVoaWNsZV9zdGF0ZRgCIAEoDjIhLm1hcHMuZmxlZXRlbmdpbmUudjEuVmVo",
            "aWNsZVN0YXRlEjsKFHN1cHBvcnRlZF90cmlwX3R5cGVzGAMgAygOMh0ubWFw",
            "cy5mbGVldGVuZ2luZS52MS5UcmlwVHlwZRIaCg1jdXJyZW50X3RyaXBzGAQg",
            "AygJQgPgQQMSOwoNbGFzdF9sb2NhdGlvbhgFIAEoCzIkLm1hcHMuZmxlZXRl",
            "bmdpbmUudjEuVmVoaWNsZUxvY2F0aW9uEkEKDnBhc3RfbG9jYXRpb25zGB4g",
            "AygLMiQubWFwcy5mbGVldGVuZ2luZS52MS5WZWhpY2xlTG9jYXRpb25CA+BB",
            "BBIYChBtYXhpbXVtX2NhcGFjaXR5GAYgASgFEjkKCmF0dHJpYnV0ZXMYCCAD",
            "KAsyJS5tYXBzLmZsZWV0ZW5naW5lLnYxLlZlaGljbGVBdHRyaWJ1dGUSQwoM",
            "dmVoaWNsZV90eXBlGAkgASgLMigubWFwcy5mbGVldGVuZ2luZS52MS5WZWhp",
            "Y2xlLlZlaGljbGVUeXBlQgPgQQISOAoNbGljZW5zZV9wbGF0ZRgKIAEoCzIh",
            "Lm1hcHMuZmxlZXRlbmdpbmUudjEuTGljZW5zZVBsYXRlEjgKBXJvdXRlGAwg",
            "AygLMiUubWFwcy5mbGVldGVuZ2luZS52MS5UZXJtaW5hbExvY2F0aW9uQgIY",
            "ARIdChVjdXJyZW50X3JvdXRlX3NlZ21lbnQYFCABKAkSVAodY3VycmVudF9y",
            "b3V0ZV9zZWdtZW50X3RyYWZmaWMYHCABKAsyKC5tYXBzLmZsZWV0ZW5naW5l",
            "LnYxLlRyYWZmaWNQb2x5bGluZURhdGFCA+BBBBJGCh1jdXJyZW50X3JvdXRl",
            "X3NlZ21lbnRfdmVyc2lvbhgPIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1l",
            "c3RhbXBCA+BBAxJKCh9jdXJyZW50X3JvdXRlX3NlZ21lbnRfZW5kX3BvaW50",
            "GBggASgLMiEubWFwcy5mbGVldGVuZ2luZS52MS5UcmlwV2F5cG9pbnQSPgoZ",
            "cmVtYWluaW5nX2Rpc3RhbmNlX21ldGVycxgSIAEoCzIbLmdvb2dsZS5wcm90",
            "b2J1Zi5JbnQzMlZhbHVlEjkKFWV0YV90b19maXJzdF93YXlwb2ludBgTIAEo",
            "CzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASQAoWcmVtYWluaW5nX3Rp",
            "bWVfc2Vjb25kcxgZIAEoCzIbLmdvb2dsZS5wcm90b2J1Zi5JbnQzMlZhbHVl",
            "QgPgQQQSNAoJd2F5cG9pbnRzGBYgAygLMiEubWFwcy5mbGVldGVuZ2luZS52",
            "MS5UcmlwV2F5cG9pbnQSOgoRd2F5cG9pbnRzX3ZlcnNpb24YECABKAsyGi5n",
            "b29nbGUucHJvdG9idWYuVGltZXN0YW1wQgPgQQMSHAoUYmFja190b19iYWNr",
            "X2VuYWJsZWQYFyABKAgSQAoRbmF2aWdhdGlvbl9zdGF0dXMYGiABKA4yJS5t",
            "YXBzLmZsZWV0ZW5naW5lLnYxLk5hdmlnYXRpb25TdGF0dXMSQQoPZGV2aWNl",
            "X3NldHRpbmdzGBsgASgLMiMubWFwcy5mbGVldGVuZ2luZS52MS5EZXZpY2VT",
            "ZXR0aW5nc0ID4EEEGrgBCgtWZWhpY2xlVHlwZRJDCghjYXRlZ29yeRgBIAEo",
            "DjIxLm1hcHMuZmxlZXRlbmdpbmUudjEuVmVoaWNsZS5WZWhpY2xlVHlwZS5D",
            "YXRlZ29yeSJkCghDYXRlZ29yeRILCgdVTktOT1dOEAASCAoEQVVUTxABEggK",
            "BFRBWEkQAhIJCgVUUlVDSxADEg8KC1RXT19XSEVFTEVSEAQSCwoHQklDWUNM",
            "RRAFEg4KClBFREVTVFJJQU4QBjpQ6kFNCiJmbGVldGVuZ2luZS5nb29nbGVh",
            "cGlzLmNvbS9WZWhpY2xlEidwcm92aWRlcnMve3Byb3ZpZGVyfS92ZWhpY2xl",
            "cy97dmVoaWNsZX0inQEKC0JhdHRlcnlJbmZvEjoKDmJhdHRlcnlfc3RhdHVz",
            "GAEgASgOMiIubWFwcy5mbGVldGVuZ2luZS52MS5CYXR0ZXJ5U3RhdHVzEjYK",
            "DHBvd2VyX3NvdXJjZRgCIAEoDjIgLm1hcHMuZmxlZXRlbmdpbmUudjEuUG93",
            "ZXJTb3VyY2USGgoSYmF0dGVyeV9wZXJjZW50YWdlGAMgASgCIsoBCg5EZXZp",
            "Y2VTZXR0aW5ncxJMChhsb2NhdGlvbl9wb3dlcl9zYXZlX21vZGUYASABKA4y",
            "Ki5tYXBzLmZsZWV0ZW5naW5lLnYxLkxvY2F0aW9uUG93ZXJTYXZlTW9kZRIa",
            "ChJpc19wb3dlcl9zYXZlX21vZGUYAiABKAgSFgoOaXNfaW50ZXJhY3RpdmUY",
            "AyABKAgSNgoMYmF0dGVyeV9pbmZvGAQgASgLMiAubWFwcy5mbGVldGVuZ2lu",
            "ZS52MS5CYXR0ZXJ5SW5mbyJBCgxMaWNlbnNlUGxhdGUSGQoMY291bnRyeV9j",
            "b2RlGAEgASgJQgPgQQISFgoObGFzdF9jaGFyYWN0ZXIYAiABKAki9gIKJFZp",
            "c3VhbFRyYWZmaWNSZXBvcnRQb2x5bGluZVJlbmRlcmluZxJgCgxyb2FkX3N0",
            "cmV0Y2gYASADKAsyRS5tYXBzLmZsZWV0ZW5naW5lLnYxLlZpc3VhbFRyYWZm",
            "aWNSZXBvcnRQb2x5bGluZVJlbmRlcmluZy5Sb2FkU3RyZXRjaEID4EEBGusB",
            "CgtSb2FkU3RyZXRjaBJfCgVzdHlsZRgBIAEoDjJLLm1hcHMuZmxlZXRlbmdp",
            "bmUudjEuVmlzdWFsVHJhZmZpY1JlcG9ydFBvbHlsaW5lUmVuZGVyaW5nLlJv",
            "YWRTdHJldGNoLlN0eWxlQgPgQQISGgoNb2Zmc2V0X21ldGVycxgCIAEoBUID",
            "4EECEhoKDWxlbmd0aF9tZXRlcnMYAyABKAVCA+BBAiJDCgVTdHlsZRIVChFT",
            "VFlMRV9VTlNQRUNJRklFRBAAEhIKDlNMT1dFUl9UUkFGRklDEAESDwoLVFJB",
            "RkZJQ19KQU0QAiJrChNUcmFmZmljUG9seWxpbmVEYXRhElQKEXRyYWZmaWNf",
            "cmVuZGVyaW5nGAEgASgLMjkubWFwcy5mbGVldGVuZ2luZS52MS5WaXN1YWxU",
            "cmFmZmljUmVwb3J0UG9seWxpbmVSZW5kZXJpbmcqQgoMVmVoaWNsZVN0YXRl",
            "EhkKFVVOS05PV05fVkVISUNMRV9TVEFURRAAEgsKB09GRkxJTkUQARIKCgZP",
            "TkxJTkUQAiqSAgoVTG9jYXRpb25Qb3dlclNhdmVNb2RlEiQKIFVOS05PV05f",
            "TE9DQVRJT05fUE9XRVJfU0FWRV9NT0RFEAASGwoXTE9DQVRJT05fTU9ERV9O",
            "T19DSEFOR0UQARIuCipMT0NBVElPTl9NT0RFX0dQU19ESVNBQkxFRF9XSEVO",
            "X1NDUkVFTl9PRkYQAhIuCipMT0NBVElPTl9NT0RFX0FMTF9ESVNBQkxFRF9X",
            "SEVOX1NDUkVFTl9PRkYQAxIhCh1MT0NBVElPTl9NT0RFX0ZPUkVHUk9VTkRf",
            "T05MWRAEEjMKL0xPQ0FUSU9OX01PREVfVEhST1RUTEVfUkVRVUVTVFNfV0hF",
            "Tl9TQ1JFRU5fT0ZGEAUqwAEKDUJhdHRlcnlTdGF0dXMSGgoWVU5LTk9XTl9C",
            "QVRURVJZX1NUQVRVUxAAEhsKF0JBVFRFUllfU1RBVFVTX0NIQVJHSU5HEAES",
            "HgoaQkFUVEVSWV9TVEFUVVNfRElTQ0hBUkdJTkcQAhIXChNCQVRURVJZX1NU",
            "QVRVU19GVUxMEAMSHwobQkFUVEVSWV9TVEFUVVNfTk9UX0NIQVJHSU5HEAQS",
            "HAoYQkFUVEVSWV9TVEFUVVNfUE9XRVJfTE9XEAUqiQEKC1Bvd2VyU291cmNl",
            "EhgKFFVOS05PV05fUE9XRVJfU09VUkNFEAASEwoPUE9XRVJfU09VUkNFX0FD",
            "EAESFAoQUE9XRVJfU09VUkNFX1VTQhACEhkKFVBPV0VSX1NPVVJDRV9XSVJF",
            "TEVTUxADEhoKFlBPV0VSX1NPVVJDRV9VTlBMVUdHRUQQBELUAQoeY29tLmdv",
            "b2dsZS5tYXBzLmZsZWV0ZW5naW5lLnYxQghWZWhpY2xlc1ABWkZjbG91ZC5n",
            "b29nbGUuY29tL2dvL21hcHMvZmxlZXRlbmdpbmUvYXBpdjEvZmxlZXRlbmdp",
            "bmVwYjtmbGVldGVuZ2luZXBiogIDQ0ZFqgIaR29vZ2xlLk1hcHMuRmxlZXRF",
            "bmdpbmUuVjHKAhpHb29nbGVcTWFwc1xGbGVldEVuZ2luZVxWMeoCHUdvb2ds",
            "ZTo6TWFwczo6RmxlZXRFbmdpbmU6OlYxYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.FieldBehaviorReflection.Descriptor, global::Google.Api.ResourceReflection.Descriptor, global::Google.Maps.FleetEngine.V1.FleetengineReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Google.Maps.FleetEngine.V1.VehicleState), typeof(global::Google.Maps.FleetEngine.V1.LocationPowerSaveMode), typeof(global::Google.Maps.FleetEngine.V1.BatteryStatus), typeof(global::Google.Maps.FleetEngine.V1.PowerSource), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.FleetEngine.V1.Vehicle), global::Google.Maps.FleetEngine.V1.Vehicle.Parser, new[]{ "Name", "VehicleState", "SupportedTripTypes", "CurrentTrips", "LastLocation", "PastLocations", "MaximumCapacity", "Attributes", "VehicleType", "LicensePlate", "Route", "CurrentRouteSegment", "CurrentRouteSegmentTraffic", "CurrentRouteSegmentVersion", "CurrentRouteSegmentEndPoint", "RemainingDistanceMeters", "EtaToFirstWaypoint", "RemainingTimeSeconds", "Waypoints", "WaypointsVersion", "BackToBackEnabled", "NavigationStatus", "DeviceSettings" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType), global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType.Parser, new[]{ "Category" }, null, new[]{ typeof(global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType.Types.Category) }, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.FleetEngine.V1.BatteryInfo), global::Google.Maps.FleetEngine.V1.BatteryInfo.Parser, new[]{ "BatteryStatus", "PowerSource", "BatteryPercentage" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.FleetEngine.V1.DeviceSettings), global::Google.Maps.FleetEngine.V1.DeviceSettings.Parser, new[]{ "LocationPowerSaveMode", "IsPowerSaveMode", "IsInteractive", "BatteryInfo" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.FleetEngine.V1.LicensePlate), global::Google.Maps.FleetEngine.V1.LicensePlate.Parser, new[]{ "CountryCode", "LastCharacter" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering), global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering.Parser, new[]{ "RoadStretch" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering.Types.RoadStretch), global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering.Types.RoadStretch.Parser, new[]{ "Style", "OffsetMeters", "LengthMeters" }, null, new[]{ typeof(global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering.Types.RoadStretch.Types.Style) }, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.FleetEngine.V1.TrafficPolylineData), global::Google.Maps.FleetEngine.V1.TrafficPolylineData.Parser, new[]{ "TrafficRendering" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// The state of a `Vehicle`.
  /// </summary>
  public enum VehicleState {
    /// <summary>
    /// Default, used for unspecified or unrecognized vehicle states.
    /// </summary>
    [pbr::OriginalName("UNKNOWN_VEHICLE_STATE")] UnknownVehicleState = 0,
    /// <summary>
    /// The vehicle is not accepting new trips. Note: the vehicle may continue to
    /// operate in this state while completing a trip assigned to it.
    /// </summary>
    [pbr::OriginalName("OFFLINE")] Offline = 1,
    /// <summary>
    /// The vehicle is accepting new trips.
    /// </summary>
    [pbr::OriginalName("ONLINE")] Online = 2,
  }

  /// <summary>
  /// How location features are configured to behave on the mobile device when the
  /// devices "battery saver" feature is on.
  /// (https://developer.android.com/reference/android/os/PowerManager#getLocationPowerSaveMode())
  /// </summary>
  public enum LocationPowerSaveMode {
    /// <summary>
    /// Undefined LocationPowerSaveMode
    /// </summary>
    [pbr::OriginalName("UNKNOWN_LOCATION_POWER_SAVE_MODE")] UnknownLocationPowerSaveMode = 0,
    /// <summary>
    /// Either the location providers shouldn't be affected by battery saver, or
    /// battery saver is off.
    /// </summary>
    [pbr::OriginalName("LOCATION_MODE_NO_CHANGE")] LocationModeNoChange = 1,
    /// <summary>
    /// The GPS based location provider should be disabled when battery saver is on
    /// and the device is non-interactive.
    /// </summary>
    [pbr::OriginalName("LOCATION_MODE_GPS_DISABLED_WHEN_SCREEN_OFF")] LocationModeGpsDisabledWhenScreenOff = 2,
    /// <summary>
    /// All location providers should be disabled when battery saver is on and the
    /// device is non-interactive.
    /// </summary>
    [pbr::OriginalName("LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF")] LocationModeAllDisabledWhenScreenOff = 3,
    /// <summary>
    /// All the location providers will be kept available, but location fixes
    /// should only be provided to foreground apps.
    /// </summary>
    [pbr::OriginalName("LOCATION_MODE_FOREGROUND_ONLY")] LocationModeForegroundOnly = 4,
    /// <summary>
    /// Location will not be turned off, but LocationManager will throttle all
    /// requests to providers when the device is non-interactive.
    /// </summary>
    [pbr::OriginalName("LOCATION_MODE_THROTTLE_REQUESTS_WHEN_SCREEN_OFF")] LocationModeThrottleRequestsWhenScreenOff = 5,
  }

  /// <summary>
  /// Status of the battery, whether full or charging etc.
  /// </summary>
  public enum BatteryStatus {
    /// <summary>
    /// Battery status unknown.
    /// </summary>
    [pbr::OriginalName("UNKNOWN_BATTERY_STATUS")] UnknownBatteryStatus = 0,
    /// <summary>
    /// Battery is being charged.
    /// </summary>
    [pbr::OriginalName("BATTERY_STATUS_CHARGING")] Charging = 1,
    /// <summary>
    /// Battery is discharging.
    /// </summary>
    [pbr::OriginalName("BATTERY_STATUS_DISCHARGING")] Discharging = 2,
    /// <summary>
    /// Battery is full.
    /// </summary>
    [pbr::OriginalName("BATTERY_STATUS_FULL")] Full = 3,
    /// <summary>
    /// Battery is not charging.
    /// </summary>
    [pbr::OriginalName("BATTERY_STATUS_NOT_CHARGING")] NotCharging = 4,
    /// <summary>
    /// Battery is low on power.
    /// </summary>
    [pbr::OriginalName("BATTERY_STATUS_POWER_LOW")] PowerLow = 5,
  }

  /// <summary>
  /// Type of the charger being used to charge the battery.
  /// </summary>
  public enum PowerSource {
    /// <summary>
    /// Power source unknown.
    /// </summary>
    [pbr::OriginalName("UNKNOWN_POWER_SOURCE")] UnknownPowerSource = 0,
    /// <summary>
    /// Power source is an AC charger.
    /// </summary>
    [pbr::OriginalName("POWER_SOURCE_AC")] Ac = 1,
    /// <summary>
    /// Power source is a USB port.
    /// </summary>
    [pbr::OriginalName("POWER_SOURCE_USB")] Usb = 2,
    /// <summary>
    /// Power source is wireless.
    /// </summary>
    [pbr::OriginalName("POWER_SOURCE_WIRELESS")] Wireless = 3,
    /// <summary>
    /// Battery is unplugged.
    /// </summary>
    [pbr::OriginalName("POWER_SOURCE_UNPLUGGED")] Unplugged = 4,
  }

  #endregion

  #region Messages
  /// <summary>
  /// Vehicle metadata.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Vehicle : pb::IMessage<Vehicle>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Vehicle> _parser = new pb::MessageParser<Vehicle>(() => new Vehicle());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Vehicle> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.FleetEngine.V1.VehiclesReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Vehicle() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Vehicle(Vehicle other) : this() {
      name_ = other.name_;
      vehicleState_ = other.vehicleState_;
      supportedTripTypes_ = other.supportedTripTypes_.Clone();
      currentTrips_ = other.currentTrips_.Clone();
      lastLocation_ = other.lastLocation_ != null ? other.lastLocation_.Clone() : null;
      pastLocations_ = other.pastLocations_.Clone();
      maximumCapacity_ = other.maximumCapacity_;
      attributes_ = other.attributes_.Clone();
      vehicleType_ = other.vehicleType_ != null ? other.vehicleType_.Clone() : null;
      licensePlate_ = other.licensePlate_ != null ? other.licensePlate_.Clone() : null;
      route_ = other.route_.Clone();
      currentRouteSegment_ = other.currentRouteSegment_;
      currentRouteSegmentTraffic_ = other.currentRouteSegmentTraffic_ != null ? other.currentRouteSegmentTraffic_.Clone() : null;
      currentRouteSegmentVersion_ = other.currentRouteSegmentVersion_ != null ? other.currentRouteSegmentVersion_.Clone() : null;
      currentRouteSegmentEndPoint_ = other.currentRouteSegmentEndPoint_ != null ? other.currentRouteSegmentEndPoint_.Clone() : null;
      RemainingDistanceMeters = other.RemainingDistanceMeters;
      etaToFirstWaypoint_ = other.etaToFirstWaypoint_ != null ? other.etaToFirstWaypoint_.Clone() : null;
      RemainingTimeSeconds = other.RemainingTimeSeconds;
      waypoints_ = other.waypoints_.Clone();
      waypointsVersion_ = other.waypointsVersion_ != null ? other.waypointsVersion_.Clone() : null;
      backToBackEnabled_ = other.backToBackEnabled_;
      navigationStatus_ = other.navigationStatus_;
      deviceSettings_ = other.deviceSettings_ != null ? other.deviceSettings_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Vehicle Clone() {
      return new Vehicle(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Output only. The unique name for this vehicle.
    /// The format is `providers/{provider}/vehicles/{vehicle}`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "vehicle_state" field.</summary>
    public const int VehicleStateFieldNumber = 2;
    private global::Google.Maps.FleetEngine.V1.VehicleState vehicleState_ = global::Google.Maps.FleetEngine.V1.VehicleState.UnknownVehicleState;
    /// <summary>
    /// The vehicle state.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.VehicleState VehicleState {
      get { return vehicleState_; }
      set {
        vehicleState_ = value;
      }
    }

    /// <summary>Field number for the "supported_trip_types" field.</summary>
    public const int SupportedTripTypesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Google.Maps.FleetEngine.V1.TripType> _repeated_supportedTripTypes_codec
        = pb::FieldCodec.ForEnum(26, x => (int) x, x => (global::Google.Maps.FleetEngine.V1.TripType) x);
    private readonly pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.TripType> supportedTripTypes_ = new pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.TripType>();
    /// <summary>
    /// Trip types supported by this vehicle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.TripType> SupportedTripTypes {
      get { return supportedTripTypes_; }
    }

    /// <summary>Field number for the "current_trips" field.</summary>
    public const int CurrentTripsFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_currentTrips_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> currentTrips_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Output only. List of `trip_id`'s for trips currently assigned to this
    /// vehicle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> CurrentTrips {
      get { return currentTrips_; }
    }

    /// <summary>Field number for the "last_location" field.</summary>
    public const int LastLocationFieldNumber = 5;
    private global::Google.Maps.FleetEngine.V1.VehicleLocation lastLocation_;
    /// <summary>
    /// Last reported location of the vehicle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.VehicleLocation LastLocation {
      get { return lastLocation_; }
      set {
        lastLocation_ = value;
      }
    }

    /// <summary>Field number for the "past_locations" field.</summary>
    public const int PastLocationsFieldNumber = 30;
    private static readonly pb::FieldCodec<global::Google.Maps.FleetEngine.V1.VehicleLocation> _repeated_pastLocations_codec
        = pb::FieldCodec.ForMessage(242, global::Google.Maps.FleetEngine.V1.VehicleLocation.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleLocation> pastLocations_ = new pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleLocation>();
    /// <summary>
    /// Input only. Locations where this vehicle has been in the past that haven't
    /// yet been reported to Fleet Engine. This is used in `UpdateVehicleRequest`
    /// to record locations which were previously unable to be sent to the server.
    /// Typically this happens when the vehicle does not have internet
    /// connectivity.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleLocation> PastLocations {
      get { return pastLocations_; }
    }

    /// <summary>Field number for the "maximum_capacity" field.</summary>
    public const int MaximumCapacityFieldNumber = 6;
    private int maximumCapacity_;
    /// <summary>
    /// The total numbers of riders this vehicle can carry.  The driver is not
    /// considered in this value. This value must be greater than or equal to one.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MaximumCapacity {
      get { return maximumCapacity_; }
      set {
        maximumCapacity_ = value;
      }
    }

    /// <summary>Field number for the "attributes" field.</summary>
    public const int AttributesFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Google.Maps.FleetEngine.V1.VehicleAttribute> _repeated_attributes_codec
        = pb::FieldCodec.ForMessage(66, global::Google.Maps.FleetEngine.V1.VehicleAttribute.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleAttribute> attributes_ = new pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleAttribute>();
    /// <summary>
    /// List of vehicle attributes. A vehicle can have at most 100
    /// attributes, and each attribute must have a unique key.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleAttribute> Attributes {
      get { return attributes_; }
    }

    /// <summary>Field number for the "vehicle_type" field.</summary>
    public const int VehicleTypeFieldNumber = 9;
    private global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType vehicleType_;
    /// <summary>
    /// Required. The type of this vehicle.  Can be used to filter vehicles in
    /// `SearchVehicles` results.  Also influences ETA and route calculations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType VehicleType {
      get { return vehicleType_; }
      set {
        vehicleType_ = value;
      }
    }

    /// <summary>Field number for the "license_plate" field.</summary>
    public const int LicensePlateFieldNumber = 10;
    private global::Google.Maps.FleetEngine.V1.LicensePlate licensePlate_;
    /// <summary>
    /// License plate information for the vehicle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.LicensePlate LicensePlate {
      get { return licensePlate_; }
      set {
        licensePlate_ = value;
      }
    }

    /// <summary>Field number for the "route" field.</summary>
    public const int RouteFieldNumber = 12;
    private static readonly pb::FieldCodec<global::Google.Maps.FleetEngine.V1.TerminalLocation> _repeated_route_codec
        = pb::FieldCodec.ForMessage(98, global::Google.Maps.FleetEngine.V1.TerminalLocation.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.TerminalLocation> route_ = new pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.TerminalLocation>();
    /// <summary>
    /// Deprecated: Use `Vehicle.waypoints` instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.TerminalLocation> Route {
      get { return route_; }
    }

    /// <summary>Field number for the "current_route_segment" field.</summary>
    public const int CurrentRouteSegmentFieldNumber = 20;
    private string currentRouteSegment_ = "";
    /// <summary>
    /// The polyline specifying the route the driver app intends to take to
    /// the next waypoint. This list is also returned in
    /// `Trip.current_route_segment` for all active trips assigned to the vehicle.
    ///
    /// Note: This field is intended only for use by the Driver SDK. Decoding is
    /// not yet supported.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string CurrentRouteSegment {
      get { return currentRouteSegment_; }
      set {
        currentRouteSegment_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "current_route_segment_traffic" field.</summary>
    public const int CurrentRouteSegmentTrafficFieldNumber = 28;
    private global::Google.Maps.FleetEngine.V1.TrafficPolylineData currentRouteSegmentTraffic_;
    /// <summary>
    /// Input only. Fleet Engine uses this information to improve journey sharing.
    /// Note: This field is intended only for use by the Driver SDK.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.TrafficPolylineData CurrentRouteSegmentTraffic {
      get { return currentRouteSegmentTraffic_; }
      set {
        currentRouteSegmentTraffic_ = value;
      }
    }

    /// <summary>Field number for the "current_route_segment_version" field.</summary>
    public const int CurrentRouteSegmentVersionFieldNumber = 15;
    private global::Google.Protobuf.WellKnownTypes.Timestamp currentRouteSegmentVersion_;
    /// <summary>
    /// Output only. Time when `current_route_segment` was set. It can be stored by
    /// the client and passed in future `GetVehicle` requests to prevent returning
    /// routes that haven't changed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp CurrentRouteSegmentVersion {
      get { return currentRouteSegmentVersion_; }
      set {
        currentRouteSegmentVersion_ = value;
      }
    }

    /// <summary>Field number for the "current_route_segment_end_point" field.</summary>
    public const int CurrentRouteSegmentEndPointFieldNumber = 24;
    private global::Google.Maps.FleetEngine.V1.TripWaypoint currentRouteSegmentEndPoint_;
    /// <summary>
    /// The waypoint where `current_route_segment` ends. This can be supplied by
    /// drivers on `UpdateVehicle` calls either as a full trip waypoint, a waypoint
    /// `LatLng`, or as the last `LatLng` of the `current_route_segment`. Fleet
    /// Engine will then do its best to interpolate to an actual waypoint if it is
    /// not fully specified. This field is ignored in `UpdateVehicle` calls unless
    /// `current_route_segment` is also specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.TripWaypoint CurrentRouteSegmentEndPoint {
      get { return currentRouteSegmentEndPoint_; }
      set {
        currentRouteSegmentEndPoint_ = value;
      }
    }

    /// <summary>Field number for the "remaining_distance_meters" field.</summary>
    public const int RemainingDistanceMetersFieldNumber = 18;
    private static readonly pb::FieldCodec<int?> _single_remainingDistanceMeters_codec = pb::FieldCodec.ForStructWrapper<int>(146);
    private int? remainingDistanceMeters_;
    /// <summary>
    /// The remaining driving distance for the `current_route_segment`.
    /// This value is also returned in `Trip.remaining_distance_meters` for all
    /// active trips assigned to the vehicle. The value is unspecified if the
    /// `current_route_segment` field is empty.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int? RemainingDistanceMeters {
      get { return remainingDistanceMeters_; }
      set {
        remainingDistanceMeters_ = value;
      }
    }


    /// <summary>Field number for the "eta_to_first_waypoint" field.</summary>
    public const int EtaToFirstWaypointFieldNumber = 19;
    private global::Google.Protobuf.WellKnownTypes.Timestamp etaToFirstWaypoint_;
    /// <summary>
    /// The ETA to the first entry in the `waypoints` field.  The value is
    /// unspecified if the `waypoints` field is empty or the
    /// `Vehicle.current_route_segment` field is empty.
    ///
    /// When updating a vehicle, `remaining_time_seconds` takes precedence over
    /// `eta_to_first_waypoint` in the same request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp EtaToFirstWaypoint {
      get { return etaToFirstWaypoint_; }
      set {
        etaToFirstWaypoint_ = value;
      }
    }

    /// <summary>Field number for the "remaining_time_seconds" field.</summary>
    public const int RemainingTimeSecondsFieldNumber = 25;
    private static readonly pb::FieldCodec<int?> _single_remainingTimeSeconds_codec = pb::FieldCodec.ForStructWrapper<int>(202);
    private int? remainingTimeSeconds_;
    /// <summary>
    /// Input only. The remaining driving time for the `current_route_segment`. The
    /// value is unspecified if the `waypoints` field is empty or the
    /// `Vehicle.current_route_segment` field is empty. This value should match
    /// `eta_to_first_waypoint` - `current_time` if all parties are using the same
    /// clock.
    ///
    /// When updating a vehicle, `remaining_time_seconds` takes precedence over
    /// `eta_to_first_waypoint` in the same request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int? RemainingTimeSeconds {
      get { return remainingTimeSeconds_; }
      set {
        remainingTimeSeconds_ = value;
      }
    }


    /// <summary>Field number for the "waypoints" field.</summary>
    public const int WaypointsFieldNumber = 22;
    private static readonly pb::FieldCodec<global::Google.Maps.FleetEngine.V1.TripWaypoint> _repeated_waypoints_codec
        = pb::FieldCodec.ForMessage(178, global::Google.Maps.FleetEngine.V1.TripWaypoint.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.TripWaypoint> waypoints_ = new pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.TripWaypoint>();
    /// <summary>
    /// The remaining waypoints assigned to this Vehicle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.TripWaypoint> Waypoints {
      get { return waypoints_; }
    }

    /// <summary>Field number for the "waypoints_version" field.</summary>
    public const int WaypointsVersionFieldNumber = 16;
    private global::Google.Protobuf.WellKnownTypes.Timestamp waypointsVersion_;
    /// <summary>
    /// Output only. Last time the `waypoints` field was updated. Clients should
    /// cache this value and pass it in `GetVehicleRequest` to ensure the
    /// `waypoints` field is only returned if it is updated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp WaypointsVersion {
      get { return waypointsVersion_; }
      set {
        waypointsVersion_ = value;
      }
    }

    /// <summary>Field number for the "back_to_back_enabled" field.</summary>
    public const int BackToBackEnabledFieldNumber = 23;
    private bool backToBackEnabled_;
    /// <summary>
    /// Indicates if the driver accepts back-to-back trips. If `true`,
    /// `SearchVehicles` may include the vehicle even if it is currently assigned
    /// to a trip. The default value is `false`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool BackToBackEnabled {
      get { return backToBackEnabled_; }
      set {
        backToBackEnabled_ = value;
      }
    }

    /// <summary>Field number for the "navigation_status" field.</summary>
    public const int NavigationStatusFieldNumber = 26;
    private global::Google.Maps.FleetEngine.V1.NavigationStatus navigationStatus_ = global::Google.Maps.FleetEngine.V1.NavigationStatus.UnknownNavigationStatus;
    /// <summary>
    /// The vehicle's navigation status.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.NavigationStatus NavigationStatus {
      get { return navigationStatus_; }
      set {
        navigationStatus_ = value;
      }
    }

    /// <summary>Field number for the "device_settings" field.</summary>
    public const int DeviceSettingsFieldNumber = 27;
    private global::Google.Maps.FleetEngine.V1.DeviceSettings deviceSettings_;
    /// <summary>
    /// Input only. Information about settings in the mobile device being used by
    /// the driver.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.DeviceSettings DeviceSettings {
      get { return deviceSettings_; }
      set {
        deviceSettings_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Vehicle);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Vehicle other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (VehicleState != other.VehicleState) return false;
      if(!supportedTripTypes_.Equals(other.supportedTripTypes_)) return false;
      if(!currentTrips_.Equals(other.currentTrips_)) return false;
      if (!object.Equals(LastLocation, other.LastLocation)) return false;
      if(!pastLocations_.Equals(other.pastLocations_)) return false;
      if (MaximumCapacity != other.MaximumCapacity) return false;
      if(!attributes_.Equals(other.attributes_)) return false;
      if (!object.Equals(VehicleType, other.VehicleType)) return false;
      if (!object.Equals(LicensePlate, other.LicensePlate)) return false;
      if(!route_.Equals(other.route_)) return false;
      if (CurrentRouteSegment != other.CurrentRouteSegment) return false;
      if (!object.Equals(CurrentRouteSegmentTraffic, other.CurrentRouteSegmentTraffic)) return false;
      if (!object.Equals(CurrentRouteSegmentVersion, other.CurrentRouteSegmentVersion)) return false;
      if (!object.Equals(CurrentRouteSegmentEndPoint, other.CurrentRouteSegmentEndPoint)) return false;
      if (RemainingDistanceMeters != other.RemainingDistanceMeters) return false;
      if (!object.Equals(EtaToFirstWaypoint, other.EtaToFirstWaypoint)) return false;
      if (RemainingTimeSeconds != other.RemainingTimeSeconds) return false;
      if(!waypoints_.Equals(other.waypoints_)) return false;
      if (!object.Equals(WaypointsVersion, other.WaypointsVersion)) return false;
      if (BackToBackEnabled != other.BackToBackEnabled) return false;
      if (NavigationStatus != other.NavigationStatus) return false;
      if (!object.Equals(DeviceSettings, other.DeviceSettings)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (VehicleState != global::Google.Maps.FleetEngine.V1.VehicleState.UnknownVehicleState) hash ^= VehicleState.GetHashCode();
      hash ^= supportedTripTypes_.GetHashCode();
      hash ^= currentTrips_.GetHashCode();
      if (lastLocation_ != null) hash ^= LastLocation.GetHashCode();
      hash ^= pastLocations_.GetHashCode();
      if (MaximumCapacity != 0) hash ^= MaximumCapacity.GetHashCode();
      hash ^= attributes_.GetHashCode();
      if (vehicleType_ != null) hash ^= VehicleType.GetHashCode();
      if (licensePlate_ != null) hash ^= LicensePlate.GetHashCode();
      hash ^= route_.GetHashCode();
      if (CurrentRouteSegment.Length != 0) hash ^= CurrentRouteSegment.GetHashCode();
      if (currentRouteSegmentTraffic_ != null) hash ^= CurrentRouteSegmentTraffic.GetHashCode();
      if (currentRouteSegmentVersion_ != null) hash ^= CurrentRouteSegmentVersion.GetHashCode();
      if (currentRouteSegmentEndPoint_ != null) hash ^= CurrentRouteSegmentEndPoint.GetHashCode();
      if (remainingDistanceMeters_ != null) hash ^= RemainingDistanceMeters.GetHashCode();
      if (etaToFirstWaypoint_ != null) hash ^= EtaToFirstWaypoint.GetHashCode();
      if (remainingTimeSeconds_ != null) hash ^= RemainingTimeSeconds.GetHashCode();
      hash ^= waypoints_.GetHashCode();
      if (waypointsVersion_ != null) hash ^= WaypointsVersion.GetHashCode();
      if (BackToBackEnabled != false) hash ^= BackToBackEnabled.GetHashCode();
      if (NavigationStatus != global::Google.Maps.FleetEngine.V1.NavigationStatus.UnknownNavigationStatus) hash ^= NavigationStatus.GetHashCode();
      if (deviceSettings_ != null) hash ^= DeviceSettings.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (VehicleState != global::Google.Maps.FleetEngine.V1.VehicleState.UnknownVehicleState) {
        output.WriteRawTag(16);
        output.WriteEnum((int) VehicleState);
      }
      supportedTripTypes_.WriteTo(output, _repeated_supportedTripTypes_codec);
      currentTrips_.WriteTo(output, _repeated_currentTrips_codec);
      if (lastLocation_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(LastLocation);
      }
      if (MaximumCapacity != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(MaximumCapacity);
      }
      attributes_.WriteTo(output, _repeated_attributes_codec);
      if (vehicleType_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(VehicleType);
      }
      if (licensePlate_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(LicensePlate);
      }
      route_.WriteTo(output, _repeated_route_codec);
      if (currentRouteSegmentVersion_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(CurrentRouteSegmentVersion);
      }
      if (waypointsVersion_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(WaypointsVersion);
      }
      if (remainingDistanceMeters_ != null) {
        _single_remainingDistanceMeters_codec.WriteTagAndValue(output, RemainingDistanceMeters);
      }
      if (etaToFirstWaypoint_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(EtaToFirstWaypoint);
      }
      if (CurrentRouteSegment.Length != 0) {
        output.WriteRawTag(162, 1);
        output.WriteString(CurrentRouteSegment);
      }
      waypoints_.WriteTo(output, _repeated_waypoints_codec);
      if (BackToBackEnabled != false) {
        output.WriteRawTag(184, 1);
        output.WriteBool(BackToBackEnabled);
      }
      if (currentRouteSegmentEndPoint_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(CurrentRouteSegmentEndPoint);
      }
      if (remainingTimeSeconds_ != null) {
        _single_remainingTimeSeconds_codec.WriteTagAndValue(output, RemainingTimeSeconds);
      }
      if (NavigationStatus != global::Google.Maps.FleetEngine.V1.NavigationStatus.UnknownNavigationStatus) {
        output.WriteRawTag(208, 1);
        output.WriteEnum((int) NavigationStatus);
      }
      if (deviceSettings_ != null) {
        output.WriteRawTag(218, 1);
        output.WriteMessage(DeviceSettings);
      }
      if (currentRouteSegmentTraffic_ != null) {
        output.WriteRawTag(226, 1);
        output.WriteMessage(CurrentRouteSegmentTraffic);
      }
      pastLocations_.WriteTo(output, _repeated_pastLocations_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (VehicleState != global::Google.Maps.FleetEngine.V1.VehicleState.UnknownVehicleState) {
        output.WriteRawTag(16);
        output.WriteEnum((int) VehicleState);
      }
      supportedTripTypes_.WriteTo(ref output, _repeated_supportedTripTypes_codec);
      currentTrips_.WriteTo(ref output, _repeated_currentTrips_codec);
      if (lastLocation_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(LastLocation);
      }
      if (MaximumCapacity != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(MaximumCapacity);
      }
      attributes_.WriteTo(ref output, _repeated_attributes_codec);
      if (vehicleType_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(VehicleType);
      }
      if (licensePlate_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(LicensePlate);
      }
      route_.WriteTo(ref output, _repeated_route_codec);
      if (currentRouteSegmentVersion_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(CurrentRouteSegmentVersion);
      }
      if (waypointsVersion_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(WaypointsVersion);
      }
      if (remainingDistanceMeters_ != null) {
        _single_remainingDistanceMeters_codec.WriteTagAndValue(ref output, RemainingDistanceMeters);
      }
      if (etaToFirstWaypoint_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(EtaToFirstWaypoint);
      }
      if (CurrentRouteSegment.Length != 0) {
        output.WriteRawTag(162, 1);
        output.WriteString(CurrentRouteSegment);
      }
      waypoints_.WriteTo(ref output, _repeated_waypoints_codec);
      if (BackToBackEnabled != false) {
        output.WriteRawTag(184, 1);
        output.WriteBool(BackToBackEnabled);
      }
      if (currentRouteSegmentEndPoint_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(CurrentRouteSegmentEndPoint);
      }
      if (remainingTimeSeconds_ != null) {
        _single_remainingTimeSeconds_codec.WriteTagAndValue(ref output, RemainingTimeSeconds);
      }
      if (NavigationStatus != global::Google.Maps.FleetEngine.V1.NavigationStatus.UnknownNavigationStatus) {
        output.WriteRawTag(208, 1);
        output.WriteEnum((int) NavigationStatus);
      }
      if (deviceSettings_ != null) {
        output.WriteRawTag(218, 1);
        output.WriteMessage(DeviceSettings);
      }
      if (currentRouteSegmentTraffic_ != null) {
        output.WriteRawTag(226, 1);
        output.WriteMessage(CurrentRouteSegmentTraffic);
      }
      pastLocations_.WriteTo(ref output, _repeated_pastLocations_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (VehicleState != global::Google.Maps.FleetEngine.V1.VehicleState.UnknownVehicleState) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) VehicleState);
      }
      size += supportedTripTypes_.CalculateSize(_repeated_supportedTripTypes_codec);
      size += currentTrips_.CalculateSize(_repeated_currentTrips_codec);
      if (lastLocation_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LastLocation);
      }
      size += pastLocations_.CalculateSize(_repeated_pastLocations_codec);
      if (MaximumCapacity != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaximumCapacity);
      }
      size += attributes_.CalculateSize(_repeated_attributes_codec);
      if (vehicleType_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VehicleType);
      }
      if (licensePlate_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LicensePlate);
      }
      size += route_.CalculateSize(_repeated_route_codec);
      if (CurrentRouteSegment.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(CurrentRouteSegment);
      }
      if (currentRouteSegmentTraffic_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(CurrentRouteSegmentTraffic);
      }
      if (currentRouteSegmentVersion_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CurrentRouteSegmentVersion);
      }
      if (currentRouteSegmentEndPoint_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(CurrentRouteSegmentEndPoint);
      }
      if (remainingDistanceMeters_ != null) {
        size += _single_remainingDistanceMeters_codec.CalculateSizeWithTag(RemainingDistanceMeters);
      }
      if (etaToFirstWaypoint_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(EtaToFirstWaypoint);
      }
      if (remainingTimeSeconds_ != null) {
        size += _single_remainingTimeSeconds_codec.CalculateSizeWithTag(RemainingTimeSeconds);
      }
      size += waypoints_.CalculateSize(_repeated_waypoints_codec);
      if (waypointsVersion_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(WaypointsVersion);
      }
      if (BackToBackEnabled != false) {
        size += 2 + 1;
      }
      if (NavigationStatus != global::Google.Maps.FleetEngine.V1.NavigationStatus.UnknownNavigationStatus) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) NavigationStatus);
      }
      if (deviceSettings_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(DeviceSettings);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Vehicle other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.VehicleState != global::Google.Maps.FleetEngine.V1.VehicleState.UnknownVehicleState) {
        VehicleState = other.VehicleState;
      }
      supportedTripTypes_.Add(other.supportedTripTypes_);
      currentTrips_.Add(other.currentTrips_);
      if (other.lastLocation_ != null) {
        if (lastLocation_ == null) {
          LastLocation = new global::Google.Maps.FleetEngine.V1.VehicleLocation();
        }
        LastLocation.MergeFrom(other.LastLocation);
      }
      pastLocations_.Add(other.pastLocations_);
      if (other.MaximumCapacity != 0) {
        MaximumCapacity = other.MaximumCapacity;
      }
      attributes_.Add(other.attributes_);
      if (other.vehicleType_ != null) {
        if (vehicleType_ == null) {
          VehicleType = new global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType();
        }
        VehicleType.MergeFrom(other.VehicleType);
      }
      if (other.licensePlate_ != null) {
        if (licensePlate_ == null) {
          LicensePlate = new global::Google.Maps.FleetEngine.V1.LicensePlate();
        }
        LicensePlate.MergeFrom(other.LicensePlate);
      }
      route_.Add(other.route_);
      if (other.CurrentRouteSegment.Length != 0) {
        CurrentRouteSegment = other.CurrentRouteSegment;
      }
      if (other.currentRouteSegmentTraffic_ != null) {
        if (currentRouteSegmentTraffic_ == null) {
          CurrentRouteSegmentTraffic = new global::Google.Maps.FleetEngine.V1.TrafficPolylineData();
        }
        CurrentRouteSegmentTraffic.MergeFrom(other.CurrentRouteSegmentTraffic);
      }
      if (other.currentRouteSegmentVersion_ != null) {
        if (currentRouteSegmentVersion_ == null) {
          CurrentRouteSegmentVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        CurrentRouteSegmentVersion.MergeFrom(other.CurrentRouteSegmentVersion);
      }
      if (other.currentRouteSegmentEndPoint_ != null) {
        if (currentRouteSegmentEndPoint_ == null) {
          CurrentRouteSegmentEndPoint = new global::Google.Maps.FleetEngine.V1.TripWaypoint();
        }
        CurrentRouteSegmentEndPoint.MergeFrom(other.CurrentRouteSegmentEndPoint);
      }
      if (other.remainingDistanceMeters_ != null) {
        if (remainingDistanceMeters_ == null || other.RemainingDistanceMeters != 0) {
          RemainingDistanceMeters = other.RemainingDistanceMeters;
        }
      }
      if (other.etaToFirstWaypoint_ != null) {
        if (etaToFirstWaypoint_ == null) {
          EtaToFirstWaypoint = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        EtaToFirstWaypoint.MergeFrom(other.EtaToFirstWaypoint);
      }
      if (other.remainingTimeSeconds_ != null) {
        if (remainingTimeSeconds_ == null || other.RemainingTimeSeconds != 0) {
          RemainingTimeSeconds = other.RemainingTimeSeconds;
        }
      }
      waypoints_.Add(other.waypoints_);
      if (other.waypointsVersion_ != null) {
        if (waypointsVersion_ == null) {
          WaypointsVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        WaypointsVersion.MergeFrom(other.WaypointsVersion);
      }
      if (other.BackToBackEnabled != false) {
        BackToBackEnabled = other.BackToBackEnabled;
      }
      if (other.NavigationStatus != global::Google.Maps.FleetEngine.V1.NavigationStatus.UnknownNavigationStatus) {
        NavigationStatus = other.NavigationStatus;
      }
      if (other.deviceSettings_ != null) {
        if (deviceSettings_ == null) {
          DeviceSettings = new global::Google.Maps.FleetEngine.V1.DeviceSettings();
        }
        DeviceSettings.MergeFrom(other.DeviceSettings);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            VehicleState = (global::Google.Maps.FleetEngine.V1.VehicleState) input.ReadEnum();
            break;
          }
          case 26:
          case 24: {
            supportedTripTypes_.AddEntriesFrom(input, _repeated_supportedTripTypes_codec);
            break;
          }
          case 34: {
            currentTrips_.AddEntriesFrom(input, _repeated_currentTrips_codec);
            break;
          }
          case 42: {
            if (lastLocation_ == null) {
              LastLocation = new global::Google.Maps.FleetEngine.V1.VehicleLocation();
            }
            input.ReadMessage(LastLocation);
            break;
          }
          case 48: {
            MaximumCapacity = input.ReadInt32();
            break;
          }
          case 66: {
            attributes_.AddEntriesFrom(input, _repeated_attributes_codec);
            break;
          }
          case 74: {
            if (vehicleType_ == null) {
              VehicleType = new global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType();
            }
            input.ReadMessage(VehicleType);
            break;
          }
          case 82: {
            if (licensePlate_ == null) {
              LicensePlate = new global::Google.Maps.FleetEngine.V1.LicensePlate();
            }
            input.ReadMessage(LicensePlate);
            break;
          }
          case 98: {
            route_.AddEntriesFrom(input, _repeated_route_codec);
            break;
          }
          case 122: {
            if (currentRouteSegmentVersion_ == null) {
              CurrentRouteSegmentVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CurrentRouteSegmentVersion);
            break;
          }
          case 130: {
            if (waypointsVersion_ == null) {
              WaypointsVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(WaypointsVersion);
            break;
          }
          case 146: {
            int? value = _single_remainingDistanceMeters_codec.Read(input);
            if (remainingDistanceMeters_ == null || value != 0) {
              RemainingDistanceMeters = value;
            }
            break;
          }
          case 154: {
            if (etaToFirstWaypoint_ == null) {
              EtaToFirstWaypoint = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(EtaToFirstWaypoint);
            break;
          }
          case 162: {
            CurrentRouteSegment = input.ReadString();
            break;
          }
          case 178: {
            waypoints_.AddEntriesFrom(input, _repeated_waypoints_codec);
            break;
          }
          case 184: {
            BackToBackEnabled = input.ReadBool();
            break;
          }
          case 194: {
            if (currentRouteSegmentEndPoint_ == null) {
              CurrentRouteSegmentEndPoint = new global::Google.Maps.FleetEngine.V1.TripWaypoint();
            }
            input.ReadMessage(CurrentRouteSegmentEndPoint);
            break;
          }
          case 202: {
            int? value = _single_remainingTimeSeconds_codec.Read(input);
            if (remainingTimeSeconds_ == null || value != 0) {
              RemainingTimeSeconds = value;
            }
            break;
          }
          case 208: {
            NavigationStatus = (global::Google.Maps.FleetEngine.V1.NavigationStatus) input.ReadEnum();
            break;
          }
          case 218: {
            if (deviceSettings_ == null) {
              DeviceSettings = new global::Google.Maps.FleetEngine.V1.DeviceSettings();
            }
            input.ReadMessage(DeviceSettings);
            break;
          }
          case 226: {
            if (currentRouteSegmentTraffic_ == null) {
              CurrentRouteSegmentTraffic = new global::Google.Maps.FleetEngine.V1.TrafficPolylineData();
            }
            input.ReadMessage(CurrentRouteSegmentTraffic);
            break;
          }
          case 242: {
            pastLocations_.AddEntriesFrom(input, _repeated_pastLocations_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            VehicleState = (global::Google.Maps.FleetEngine.V1.VehicleState) input.ReadEnum();
            break;
          }
          case 26:
          case 24: {
            supportedTripTypes_.AddEntriesFrom(ref input, _repeated_supportedTripTypes_codec);
            break;
          }
          case 34: {
            currentTrips_.AddEntriesFrom(ref input, _repeated_currentTrips_codec);
            break;
          }
          case 42: {
            if (lastLocation_ == null) {
              LastLocation = new global::Google.Maps.FleetEngine.V1.VehicleLocation();
            }
            input.ReadMessage(LastLocation);
            break;
          }
          case 48: {
            MaximumCapacity = input.ReadInt32();
            break;
          }
          case 66: {
            attributes_.AddEntriesFrom(ref input, _repeated_attributes_codec);
            break;
          }
          case 74: {
            if (vehicleType_ == null) {
              VehicleType = new global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType();
            }
            input.ReadMessage(VehicleType);
            break;
          }
          case 82: {
            if (licensePlate_ == null) {
              LicensePlate = new global::Google.Maps.FleetEngine.V1.LicensePlate();
            }
            input.ReadMessage(LicensePlate);
            break;
          }
          case 98: {
            route_.AddEntriesFrom(ref input, _repeated_route_codec);
            break;
          }
          case 122: {
            if (currentRouteSegmentVersion_ == null) {
              CurrentRouteSegmentVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CurrentRouteSegmentVersion);
            break;
          }
          case 130: {
            if (waypointsVersion_ == null) {
              WaypointsVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(WaypointsVersion);
            break;
          }
          case 146: {
            int? value = _single_remainingDistanceMeters_codec.Read(ref input);
            if (remainingDistanceMeters_ == null || value != 0) {
              RemainingDistanceMeters = value;
            }
            break;
          }
          case 154: {
            if (etaToFirstWaypoint_ == null) {
              EtaToFirstWaypoint = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(EtaToFirstWaypoint);
            break;
          }
          case 162: {
            CurrentRouteSegment = input.ReadString();
            break;
          }
          case 178: {
            waypoints_.AddEntriesFrom(ref input, _repeated_waypoints_codec);
            break;
          }
          case 184: {
            BackToBackEnabled = input.ReadBool();
            break;
          }
          case 194: {
            if (currentRouteSegmentEndPoint_ == null) {
              CurrentRouteSegmentEndPoint = new global::Google.Maps.FleetEngine.V1.TripWaypoint();
            }
            input.ReadMessage(CurrentRouteSegmentEndPoint);
            break;
          }
          case 202: {
            int? value = _single_remainingTimeSeconds_codec.Read(ref input);
            if (remainingTimeSeconds_ == null || value != 0) {
              RemainingTimeSeconds = value;
            }
            break;
          }
          case 208: {
            NavigationStatus = (global::Google.Maps.FleetEngine.V1.NavigationStatus) input.ReadEnum();
            break;
          }
          case 218: {
            if (deviceSettings_ == null) {
              DeviceSettings = new global::Google.Maps.FleetEngine.V1.DeviceSettings();
            }
            input.ReadMessage(DeviceSettings);
            break;
          }
          case 226: {
            if (currentRouteSegmentTraffic_ == null) {
              CurrentRouteSegmentTraffic = new global::Google.Maps.FleetEngine.V1.TrafficPolylineData();
            }
            input.ReadMessage(CurrentRouteSegmentTraffic);
            break;
          }
          case 242: {
            pastLocations_.AddEntriesFrom(ref input, _repeated_pastLocations_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Vehicle message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// The type of vehicle.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class VehicleType : pb::IMessage<VehicleType>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<VehicleType> _parser = new pb::MessageParser<VehicleType>(() => new VehicleType());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<VehicleType> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.FleetEngine.V1.Vehicle.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VehicleType() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VehicleType(VehicleType other) : this() {
          category_ = other.category_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public VehicleType Clone() {
          return new VehicleType(this);
        }

        /// <summary>Field number for the "category" field.</summary>
        public const int CategoryFieldNumber = 1;
        private global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType.Types.Category category_ = global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType.Types.Category.Unknown;
        /// <summary>
        /// Vehicle type category
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType.Types.Category Category {
          get { return category_; }
          set {
            category_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as VehicleType);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(VehicleType other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Category != other.Category) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Category != global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType.Types.Category.Unknown) hash ^= Category.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Category != global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType.Types.Category.Unknown) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Category);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Category != global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType.Types.Category.Unknown) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Category);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Category != global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType.Types.Category.Unknown) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Category);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(VehicleType other) {
          if (other == null) {
            return;
          }
          if (other.Category != global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType.Types.Category.Unknown) {
            Category = other.Category;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Category = (global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType.Types.Category) input.ReadEnum();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Category = (global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType.Types.Category) input.ReadEnum();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the VehicleType message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// Vehicle type categories
          /// </summary>
          public enum Category {
            /// <summary>
            /// Default, used for unspecified or unrecognized vehicle categories.
            /// </summary>
            [pbr::OriginalName("UNKNOWN")] Unknown = 0,
            /// <summary>
            /// An automobile.
            /// </summary>
            [pbr::OriginalName("AUTO")] Auto = 1,
            /// <summary>
            /// Any vehicle that acts as a taxi (typically licensed or regulated).
            /// </summary>
            [pbr::OriginalName("TAXI")] Taxi = 2,
            /// <summary>
            /// Generally, a vehicle with a large storage capacity.
            /// </summary>
            [pbr::OriginalName("TRUCK")] Truck = 3,
            /// <summary>
            /// A motorcycle, moped, or other two-wheeled vehicle
            /// </summary>
            [pbr::OriginalName("TWO_WHEELER")] TwoWheeler = 4,
            /// <summary>
            /// Human-powered transport.
            /// </summary>
            [pbr::OriginalName("BICYCLE")] Bicycle = 5,
            /// <summary>
            /// A human transporter, typically walking or running, traveling along
            /// pedestrian pathways.
            /// </summary>
            [pbr::OriginalName("PEDESTRIAN")] Pedestrian = 6,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// Information about the device's battery.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class BatteryInfo : pb::IMessage<BatteryInfo>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<BatteryInfo> _parser = new pb::MessageParser<BatteryInfo>(() => new BatteryInfo());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<BatteryInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.FleetEngine.V1.VehiclesReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BatteryInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BatteryInfo(BatteryInfo other) : this() {
      batteryStatus_ = other.batteryStatus_;
      powerSource_ = other.powerSource_;
      batteryPercentage_ = other.batteryPercentage_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BatteryInfo Clone() {
      return new BatteryInfo(this);
    }

    /// <summary>Field number for the "battery_status" field.</summary>
    public const int BatteryStatusFieldNumber = 1;
    private global::Google.Maps.FleetEngine.V1.BatteryStatus batteryStatus_ = global::Google.Maps.FleetEngine.V1.BatteryStatus.UnknownBatteryStatus;
    /// <summary>
    /// Status of the battery, whether full or charging etc.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.BatteryStatus BatteryStatus {
      get { return batteryStatus_; }
      set {
        batteryStatus_ = value;
      }
    }

    /// <summary>Field number for the "power_source" field.</summary>
    public const int PowerSourceFieldNumber = 2;
    private global::Google.Maps.FleetEngine.V1.PowerSource powerSource_ = global::Google.Maps.FleetEngine.V1.PowerSource.UnknownPowerSource;
    /// <summary>
    /// Status of battery power source.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.PowerSource PowerSource {
      get { return powerSource_; }
      set {
        powerSource_ = value;
      }
    }

    /// <summary>Field number for the "battery_percentage" field.</summary>
    public const int BatteryPercentageFieldNumber = 3;
    private float batteryPercentage_;
    /// <summary>
    /// Current battery percentage [0-100].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public float BatteryPercentage {
      get { return batteryPercentage_; }
      set {
        batteryPercentage_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as BatteryInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(BatteryInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BatteryStatus != other.BatteryStatus) return false;
      if (PowerSource != other.PowerSource) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(BatteryPercentage, other.BatteryPercentage)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (BatteryStatus != global::Google.Maps.FleetEngine.V1.BatteryStatus.UnknownBatteryStatus) hash ^= BatteryStatus.GetHashCode();
      if (PowerSource != global::Google.Maps.FleetEngine.V1.PowerSource.UnknownPowerSource) hash ^= PowerSource.GetHashCode();
      if (BatteryPercentage != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(BatteryPercentage);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (BatteryStatus != global::Google.Maps.FleetEngine.V1.BatteryStatus.UnknownBatteryStatus) {
        output.WriteRawTag(8);
        output.WriteEnum((int) BatteryStatus);
      }
      if (PowerSource != global::Google.Maps.FleetEngine.V1.PowerSource.UnknownPowerSource) {
        output.WriteRawTag(16);
        output.WriteEnum((int) PowerSource);
      }
      if (BatteryPercentage != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(BatteryPercentage);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (BatteryStatus != global::Google.Maps.FleetEngine.V1.BatteryStatus.UnknownBatteryStatus) {
        output.WriteRawTag(8);
        output.WriteEnum((int) BatteryStatus);
      }
      if (PowerSource != global::Google.Maps.FleetEngine.V1.PowerSource.UnknownPowerSource) {
        output.WriteRawTag(16);
        output.WriteEnum((int) PowerSource);
      }
      if (BatteryPercentage != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(BatteryPercentage);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (BatteryStatus != global::Google.Maps.FleetEngine.V1.BatteryStatus.UnknownBatteryStatus) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) BatteryStatus);
      }
      if (PowerSource != global::Google.Maps.FleetEngine.V1.PowerSource.UnknownPowerSource) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) PowerSource);
      }
      if (BatteryPercentage != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(BatteryInfo other) {
      if (other == null) {
        return;
      }
      if (other.BatteryStatus != global::Google.Maps.FleetEngine.V1.BatteryStatus.UnknownBatteryStatus) {
        BatteryStatus = other.BatteryStatus;
      }
      if (other.PowerSource != global::Google.Maps.FleetEngine.V1.PowerSource.UnknownPowerSource) {
        PowerSource = other.PowerSource;
      }
      if (other.BatteryPercentage != 0F) {
        BatteryPercentage = other.BatteryPercentage;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            BatteryStatus = (global::Google.Maps.FleetEngine.V1.BatteryStatus) input.ReadEnum();
            break;
          }
          case 16: {
            PowerSource = (global::Google.Maps.FleetEngine.V1.PowerSource) input.ReadEnum();
            break;
          }
          case 29: {
            BatteryPercentage = input.ReadFloat();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            BatteryStatus = (global::Google.Maps.FleetEngine.V1.BatteryStatus) input.ReadEnum();
            break;
          }
          case 16: {
            PowerSource = (global::Google.Maps.FleetEngine.V1.PowerSource) input.ReadEnum();
            break;
          }
          case 29: {
            BatteryPercentage = input.ReadFloat();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Information about various settings on the mobile device.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class DeviceSettings : pb::IMessage<DeviceSettings>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DeviceSettings> _parser = new pb::MessageParser<DeviceSettings>(() => new DeviceSettings());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<DeviceSettings> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.FleetEngine.V1.VehiclesReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DeviceSettings() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DeviceSettings(DeviceSettings other) : this() {
      locationPowerSaveMode_ = other.locationPowerSaveMode_;
      isPowerSaveMode_ = other.isPowerSaveMode_;
      isInteractive_ = other.isInteractive_;
      batteryInfo_ = other.batteryInfo_ != null ? other.batteryInfo_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DeviceSettings Clone() {
      return new DeviceSettings(this);
    }

    /// <summary>Field number for the "location_power_save_mode" field.</summary>
    public const int LocationPowerSaveModeFieldNumber = 1;
    private global::Google.Maps.FleetEngine.V1.LocationPowerSaveMode locationPowerSaveMode_ = global::Google.Maps.FleetEngine.V1.LocationPowerSaveMode.UnknownLocationPowerSaveMode;
    /// <summary>
    /// How location features are set to behave on the device when battery saver is
    /// on.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.LocationPowerSaveMode LocationPowerSaveMode {
      get { return locationPowerSaveMode_; }
      set {
        locationPowerSaveMode_ = value;
      }
    }

    /// <summary>Field number for the "is_power_save_mode" field.</summary>
    public const int IsPowerSaveModeFieldNumber = 2;
    private bool isPowerSaveMode_;
    /// <summary>
    /// Whether the device is currently in power save mode.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsPowerSaveMode {
      get { return isPowerSaveMode_; }
      set {
        isPowerSaveMode_ = value;
      }
    }

    /// <summary>Field number for the "is_interactive" field.</summary>
    public const int IsInteractiveFieldNumber = 3;
    private bool isInteractive_;
    /// <summary>
    /// Whether the device is in an interactive state.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsInteractive {
      get { return isInteractive_; }
      set {
        isInteractive_ = value;
      }
    }

    /// <summary>Field number for the "battery_info" field.</summary>
    public const int BatteryInfoFieldNumber = 4;
    private global::Google.Maps.FleetEngine.V1.BatteryInfo batteryInfo_;
    /// <summary>
    /// Information about the battery state.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.BatteryInfo BatteryInfo {
      get { return batteryInfo_; }
      set {
        batteryInfo_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as DeviceSettings);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(DeviceSettings other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (LocationPowerSaveMode != other.LocationPowerSaveMode) return false;
      if (IsPowerSaveMode != other.IsPowerSaveMode) return false;
      if (IsInteractive != other.IsInteractive) return false;
      if (!object.Equals(BatteryInfo, other.BatteryInfo)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (LocationPowerSaveMode != global::Google.Maps.FleetEngine.V1.LocationPowerSaveMode.UnknownLocationPowerSaveMode) hash ^= LocationPowerSaveMode.GetHashCode();
      if (IsPowerSaveMode != false) hash ^= IsPowerSaveMode.GetHashCode();
      if (IsInteractive != false) hash ^= IsInteractive.GetHashCode();
      if (batteryInfo_ != null) hash ^= BatteryInfo.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (LocationPowerSaveMode != global::Google.Maps.FleetEngine.V1.LocationPowerSaveMode.UnknownLocationPowerSaveMode) {
        output.WriteRawTag(8);
        output.WriteEnum((int) LocationPowerSaveMode);
      }
      if (IsPowerSaveMode != false) {
        output.WriteRawTag(16);
        output.WriteBool(IsPowerSaveMode);
      }
      if (IsInteractive != false) {
        output.WriteRawTag(24);
        output.WriteBool(IsInteractive);
      }
      if (batteryInfo_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(BatteryInfo);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (LocationPowerSaveMode != global::Google.Maps.FleetEngine.V1.LocationPowerSaveMode.UnknownLocationPowerSaveMode) {
        output.WriteRawTag(8);
        output.WriteEnum((int) LocationPowerSaveMode);
      }
      if (IsPowerSaveMode != false) {
        output.WriteRawTag(16);
        output.WriteBool(IsPowerSaveMode);
      }
      if (IsInteractive != false) {
        output.WriteRawTag(24);
        output.WriteBool(IsInteractive);
      }
      if (batteryInfo_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(BatteryInfo);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (LocationPowerSaveMode != global::Google.Maps.FleetEngine.V1.LocationPowerSaveMode.UnknownLocationPowerSaveMode) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LocationPowerSaveMode);
      }
      if (IsPowerSaveMode != false) {
        size += 1 + 1;
      }
      if (IsInteractive != false) {
        size += 1 + 1;
      }
      if (batteryInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BatteryInfo);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(DeviceSettings other) {
      if (other == null) {
        return;
      }
      if (other.LocationPowerSaveMode != global::Google.Maps.FleetEngine.V1.LocationPowerSaveMode.UnknownLocationPowerSaveMode) {
        LocationPowerSaveMode = other.LocationPowerSaveMode;
      }
      if (other.IsPowerSaveMode != false) {
        IsPowerSaveMode = other.IsPowerSaveMode;
      }
      if (other.IsInteractive != false) {
        IsInteractive = other.IsInteractive;
      }
      if (other.batteryInfo_ != null) {
        if (batteryInfo_ == null) {
          BatteryInfo = new global::Google.Maps.FleetEngine.V1.BatteryInfo();
        }
        BatteryInfo.MergeFrom(other.BatteryInfo);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            LocationPowerSaveMode = (global::Google.Maps.FleetEngine.V1.LocationPowerSaveMode) input.ReadEnum();
            break;
          }
          case 16: {
            IsPowerSaveMode = input.ReadBool();
            break;
          }
          case 24: {
            IsInteractive = input.ReadBool();
            break;
          }
          case 34: {
            if (batteryInfo_ == null) {
              BatteryInfo = new global::Google.Maps.FleetEngine.V1.BatteryInfo();
            }
            input.ReadMessage(BatteryInfo);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            LocationPowerSaveMode = (global::Google.Maps.FleetEngine.V1.LocationPowerSaveMode) input.ReadEnum();
            break;
          }
          case 16: {
            IsPowerSaveMode = input.ReadBool();
            break;
          }
          case 24: {
            IsInteractive = input.ReadBool();
            break;
          }
          case 34: {
            if (batteryInfo_ == null) {
              BatteryInfo = new global::Google.Maps.FleetEngine.V1.BatteryInfo();
            }
            input.ReadMessage(BatteryInfo);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// The license plate information of the Vehicle.  To avoid storing
  /// personally-identifiable information, only the minimum information
  /// about the license plate is stored as part of the entity.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class LicensePlate : pb::IMessage<LicensePlate>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LicensePlate> _parser = new pb::MessageParser<LicensePlate>(() => new LicensePlate());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<LicensePlate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.FleetEngine.V1.VehiclesReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LicensePlate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LicensePlate(LicensePlate other) : this() {
      countryCode_ = other.countryCode_;
      lastCharacter_ = other.lastCharacter_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LicensePlate Clone() {
      return new LicensePlate(this);
    }

    /// <summary>Field number for the "country_code" field.</summary>
    public const int CountryCodeFieldNumber = 1;
    private string countryCode_ = "";
    /// <summary>
    /// Required. CLDR Country/Region Code.  For example, `US` for United States,
    /// or `IN` for India.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string CountryCode {
      get { return countryCode_; }
      set {
        countryCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "last_character" field.</summary>
    public const int LastCharacterFieldNumber = 2;
    private string lastCharacter_ = "";
    /// <summary>
    /// The last digit of the license plate or "-1" to denote no numeric value
    /// is present in the license plate.
    ///
    /// * "ABC 1234" -> "4"
    /// * "AB 123 CD" -> "3"
    /// * "ABCDEF" -> "-1"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string LastCharacter {
      get { return lastCharacter_; }
      set {
        lastCharacter_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as LicensePlate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(LicensePlate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CountryCode != other.CountryCode) return false;
      if (LastCharacter != other.LastCharacter) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (CountryCode.Length != 0) hash ^= CountryCode.GetHashCode();
      if (LastCharacter.Length != 0) hash ^= LastCharacter.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (CountryCode.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(CountryCode);
      }
      if (LastCharacter.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(LastCharacter);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (CountryCode.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(CountryCode);
      }
      if (LastCharacter.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(LastCharacter);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (CountryCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CountryCode);
      }
      if (LastCharacter.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LastCharacter);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(LicensePlate other) {
      if (other == null) {
        return;
      }
      if (other.CountryCode.Length != 0) {
        CountryCode = other.CountryCode;
      }
      if (other.LastCharacter.Length != 0) {
        LastCharacter = other.LastCharacter;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            CountryCode = input.ReadString();
            break;
          }
          case 18: {
            LastCharacter = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            CountryCode = input.ReadString();
            break;
          }
          case 18: {
            LastCharacter = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Describes how clients should color one portion of the polyline along the
  /// route.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class VisualTrafficReportPolylineRendering : pb::IMessage<VisualTrafficReportPolylineRendering>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<VisualTrafficReportPolylineRendering> _parser = new pb::MessageParser<VisualTrafficReportPolylineRendering>(() => new VisualTrafficReportPolylineRendering());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<VisualTrafficReportPolylineRendering> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.FleetEngine.V1.VehiclesReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VisualTrafficReportPolylineRendering() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VisualTrafficReportPolylineRendering(VisualTrafficReportPolylineRendering other) : this() {
      roadStretch_ = other.roadStretch_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VisualTrafficReportPolylineRendering Clone() {
      return new VisualTrafficReportPolylineRendering(this);
    }

    /// <summary>Field number for the "road_stretch" field.</summary>
    public const int RoadStretchFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering.Types.RoadStretch> _repeated_roadStretch_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering.Types.RoadStretch.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering.Types.RoadStretch> roadStretch_ = new pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering.Types.RoadStretch>();
    /// <summary>
    /// Optional. Road stretches that should be rendered along the polyline.
    /// Stretches are guaranteed to not overlap, and do not necessarily span the
    /// full route.
    ///
    /// In the absence of a road stretch to style, the client should apply the
    /// default for the route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering.Types.RoadStretch> RoadStretch {
      get { return roadStretch_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as VisualTrafficReportPolylineRendering);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(VisualTrafficReportPolylineRendering other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!roadStretch_.Equals(other.roadStretch_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= roadStretch_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      roadStretch_.WriteTo(output, _repeated_roadStretch_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      roadStretch_.WriteTo(ref output, _repeated_roadStretch_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += roadStretch_.CalculateSize(_repeated_roadStretch_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(VisualTrafficReportPolylineRendering other) {
      if (other == null) {
        return;
      }
      roadStretch_.Add(other.roadStretch_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            roadStretch_.AddEntriesFrom(input, _repeated_roadStretch_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            roadStretch_.AddEntriesFrom(ref input, _repeated_roadStretch_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the VisualTrafficReportPolylineRendering message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// One road stretch that should be rendered.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class RoadStretch : pb::IMessage<RoadStretch>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<RoadStretch> _parser = new pb::MessageParser<RoadStretch>(() => new RoadStretch());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<RoadStretch> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RoadStretch() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RoadStretch(RoadStretch other) : this() {
          style_ = other.style_;
          offsetMeters_ = other.offsetMeters_;
          lengthMeters_ = other.lengthMeters_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public RoadStretch Clone() {
          return new RoadStretch(this);
        }

        /// <summary>Field number for the "style" field.</summary>
        public const int StyleFieldNumber = 1;
        private global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering.Types.RoadStretch.Types.Style style_ = global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering.Types.RoadStretch.Types.Style.Unspecified;
        /// <summary>
        /// Required. The style to apply.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering.Types.RoadStretch.Types.Style Style {
          get { return style_; }
          set {
            style_ = value;
          }
        }

        /// <summary>Field number for the "offset_meters" field.</summary>
        public const int OffsetMetersFieldNumber = 2;
        private int offsetMeters_;
        /// <summary>
        /// Required. The style should be applied between `[offset_meters,
        /// offset_meters + length_meters)`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int OffsetMeters {
          get { return offsetMeters_; }
          set {
            offsetMeters_ = value;
          }
        }

        /// <summary>Field number for the "length_meters" field.</summary>
        public const int LengthMetersFieldNumber = 3;
        private int lengthMeters_;
        /// <summary>
        /// Required. The length of the path where to apply the style.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int LengthMeters {
          get { return lengthMeters_; }
          set {
            lengthMeters_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as RoadStretch);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(RoadStretch other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Style != other.Style) return false;
          if (OffsetMeters != other.OffsetMeters) return false;
          if (LengthMeters != other.LengthMeters) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Style != global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering.Types.RoadStretch.Types.Style.Unspecified) hash ^= Style.GetHashCode();
          if (OffsetMeters != 0) hash ^= OffsetMeters.GetHashCode();
          if (LengthMeters != 0) hash ^= LengthMeters.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Style != global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering.Types.RoadStretch.Types.Style.Unspecified) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Style);
          }
          if (OffsetMeters != 0) {
            output.WriteRawTag(16);
            output.WriteInt32(OffsetMeters);
          }
          if (LengthMeters != 0) {
            output.WriteRawTag(24);
            output.WriteInt32(LengthMeters);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Style != global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering.Types.RoadStretch.Types.Style.Unspecified) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Style);
          }
          if (OffsetMeters != 0) {
            output.WriteRawTag(16);
            output.WriteInt32(OffsetMeters);
          }
          if (LengthMeters != 0) {
            output.WriteRawTag(24);
            output.WriteInt32(LengthMeters);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Style != global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering.Types.RoadStretch.Types.Style.Unspecified) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Style);
          }
          if (OffsetMeters != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(OffsetMeters);
          }
          if (LengthMeters != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(LengthMeters);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(RoadStretch other) {
          if (other == null) {
            return;
          }
          if (other.Style != global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering.Types.RoadStretch.Types.Style.Unspecified) {
            Style = other.Style;
          }
          if (other.OffsetMeters != 0) {
            OffsetMeters = other.OffsetMeters;
          }
          if (other.LengthMeters != 0) {
            LengthMeters = other.LengthMeters;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Style = (global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering.Types.RoadStretch.Types.Style) input.ReadEnum();
                break;
              }
              case 16: {
                OffsetMeters = input.ReadInt32();
                break;
              }
              case 24: {
                LengthMeters = input.ReadInt32();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Style = (global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering.Types.RoadStretch.Types.Style) input.ReadEnum();
                break;
              }
              case 16: {
                OffsetMeters = input.ReadInt32();
                break;
              }
              case 24: {
                LengthMeters = input.ReadInt32();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the RoadStretch message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// The traffic style, indicating traffic speed.
          /// </summary>
          public enum Style {
            /// <summary>
            /// No style selected.
            /// </summary>
            [pbr::OriginalName("STYLE_UNSPECIFIED")] Unspecified = 0,
            /// <summary>
            /// Traffic is slowing down.
            /// </summary>
            [pbr::OriginalName("SLOWER_TRAFFIC")] SlowerTraffic = 1,
            /// <summary>
            /// There is a traffic jam.
            /// </summary>
            [pbr::OriginalName("TRAFFIC_JAM")] TrafficJam = 2,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// Traffic conditions along the expected vehicle route.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class TrafficPolylineData : pb::IMessage<TrafficPolylineData>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TrafficPolylineData> _parser = new pb::MessageParser<TrafficPolylineData>(() => new TrafficPolylineData());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TrafficPolylineData> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.FleetEngine.V1.VehiclesReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TrafficPolylineData() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TrafficPolylineData(TrafficPolylineData other) : this() {
      trafficRendering_ = other.trafficRendering_ != null ? other.trafficRendering_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TrafficPolylineData Clone() {
      return new TrafficPolylineData(this);
    }

    /// <summary>Field number for the "traffic_rendering" field.</summary>
    public const int TrafficRenderingFieldNumber = 1;
    private global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering trafficRendering_;
    /// <summary>
    /// A polyline rendering of how fast traffic is for all regions along
    /// one stretch of a customer ride.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering TrafficRendering {
      get { return trafficRendering_; }
      set {
        trafficRendering_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TrafficPolylineData);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TrafficPolylineData other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TrafficRendering, other.TrafficRendering)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (trafficRendering_ != null) hash ^= TrafficRendering.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (trafficRendering_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TrafficRendering);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (trafficRendering_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TrafficRendering);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (trafficRendering_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TrafficRendering);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TrafficPolylineData other) {
      if (other == null) {
        return;
      }
      if (other.trafficRendering_ != null) {
        if (trafficRendering_ == null) {
          TrafficRendering = new global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering();
        }
        TrafficRendering.MergeFrom(other.TrafficRendering);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (trafficRendering_ == null) {
              TrafficRendering = new global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering();
            }
            input.ReadMessage(TrafficRendering);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (trafficRendering_ == null) {
              TrafficRendering = new global::Google.Maps.FleetEngine.V1.VisualTrafficReportPolylineRendering();
            }
            input.ReadMessage(TrafficRendering);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
