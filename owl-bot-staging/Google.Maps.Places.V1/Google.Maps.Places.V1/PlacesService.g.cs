// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/maps/places/v1/places_service.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Maps.Places.V1 {

  /// <summary>Holder for reflection information generated from google/maps/places/v1/places_service.proto</summary>
  public static partial class PlacesServiceReflection {

    #region Descriptor
    /// <summary>File descriptor for google/maps/places/v1/places_service.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static PlacesServiceReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cipnb29nbGUvbWFwcy9wbGFjZXMvdjEvcGxhY2VzX3NlcnZpY2UucHJvdG8S",
            "FWdvb2dsZS5tYXBzLnBsYWNlcy52MRocZ29vZ2xlL2FwaS9hbm5vdGF0aW9u",
            "cy5wcm90bxoXZ29vZ2xlL2FwaS9jbGllbnQucHJvdG8aH2dvb2dsZS9hcGkv",
            "ZmllbGRfYmVoYXZpb3IucHJvdG8aGWdvb2dsZS9hcGkvcmVzb3VyY2UucHJv",
            "dG8aHmdvb2dsZS9nZW8vdHlwZS92aWV3cG9ydC5wcm90bxouZ29vZ2xlL21h",
            "cHMvcGxhY2VzL3YxL2NvbnRleHR1YWxfY29udGVudC5wcm90bxonZ29vZ2xl",
            "L21hcHMvcGxhY2VzL3YxL2V2X2NoYXJnaW5nLnByb3RvGiRnb29nbGUvbWFw",
            "cy9wbGFjZXMvdjEvZ2VvbWV0cnkucHJvdG8aIWdvb2dsZS9tYXBzL3BsYWNl",
            "cy92MS9wbGFjZS5wcm90bxokZ29vZ2xlL21hcHMvcGxhY2VzL3YxL3BvbHls",
            "aW5lLnByb3RvGitnb29nbGUvbWFwcy9wbGFjZXMvdjEvcm91dGVfbW9kaWZp",
            "ZXJzLnByb3RvGi5nb29nbGUvbWFwcy9wbGFjZXMvdjEvcm91dGluZ19wcmVm",
            "ZXJlbmNlLnByb3RvGitnb29nbGUvbWFwcy9wbGFjZXMvdjEvcm91dGluZ19z",
            "dW1tYXJ5LnByb3RvGidnb29nbGUvbWFwcy9wbGFjZXMvdjEvdHJhdmVsX21v",
            "ZGUucHJvdG8aGGdvb2dsZS90eXBlL2xhdGxuZy5wcm90byKKAgoRUm91dGlu",
            "Z1BhcmFtZXRlcnMSKAoGb3JpZ2luGAEgASgLMhMuZ29vZ2xlLnR5cGUuTGF0",
            "TG5nQgPgQQESOwoLdHJhdmVsX21vZGUYAiABKA4yIS5nb29nbGUubWFwcy5w",
            "bGFjZXMudjEuVHJhdmVsTW9kZUID4EEBEkMKD3JvdXRlX21vZGlmaWVycxgD",
            "IAEoCzIlLmdvb2dsZS5tYXBzLnBsYWNlcy52MS5Sb3V0ZU1vZGlmaWVyc0ID",
            "4EEBEkkKEnJvdXRpbmdfcHJlZmVyZW5jZRgEIAEoDjIoLmdvb2dsZS5tYXBz",
            "LnBsYWNlcy52MS5Sb3V0aW5nUHJlZmVyZW5jZUID4EEBIu4EChNTZWFyY2hO",
            "ZWFyYnlSZXF1ZXN0EhUKDWxhbmd1YWdlX2NvZGUYASABKAkSEwoLcmVnaW9u",
            "X2NvZGUYAiABKAkSFgoOaW5jbHVkZWRfdHlwZXMYAyADKAkSFgoOZXhjbHVk",
            "ZWRfdHlwZXMYBCADKAkSHgoWaW5jbHVkZWRfcHJpbWFyeV90eXBlcxgFIAMo",
            "CRIeChZleGNsdWRlZF9wcmltYXJ5X3R5cGVzGAYgAygJEhgKEG1heF9yZXN1",
            "bHRfY291bnQYByABKAUSYQoUbG9jYXRpb25fcmVzdHJpY3Rpb24YCCABKAsy",
            "Pi5nb29nbGUubWFwcy5wbGFjZXMudjEuU2VhcmNoTmVhcmJ5UmVxdWVzdC5M",
            "b2NhdGlvblJlc3RyaWN0aW9uQgPgQQISUgoPcmFua19wcmVmZXJlbmNlGAkg",
            "ASgOMjkuZ29vZ2xlLm1hcHMucGxhY2VzLnYxLlNlYXJjaE5lYXJieVJlcXVl",
            "c3QuUmFua1ByZWZlcmVuY2USSQoScm91dGluZ19wYXJhbWV0ZXJzGAogASgL",
            "MiguZ29vZ2xlLm1hcHMucGxhY2VzLnYxLlJvdXRpbmdQYXJhbWV0ZXJzQgPg",
            "QQEaTgoTTG9jYXRpb25SZXN0cmljdGlvbhIvCgZjaXJjbGUYAiABKAsyHS5n",
            "b29nbGUubWFwcy5wbGFjZXMudjEuQ2lyY2xlSABCBgoEdHlwZSJPCg5SYW5r",
            "UHJlZmVyZW5jZRIfChtSQU5LX1BSRUZFUkVOQ0VfVU5TUEVDSUZJRUQQABIM",
            "CghESVNUQU5DRRABEg4KClBPUFVMQVJJVFkQAiKGAQoUU2VhcmNoTmVhcmJ5",
            "UmVzcG9uc2USLAoGcGxhY2VzGAEgAygLMhwuZ29vZ2xlLm1hcHMucGxhY2Vz",
            "LnYxLlBsYWNlEkAKEXJvdXRpbmdfc3VtbWFyaWVzGAIgAygLMiUuZ29vZ2xl",
            "Lm1hcHMucGxhY2VzLnYxLlJvdXRpbmdTdW1tYXJ5IqcKChFTZWFyY2hUZXh0",
            "UmVxdWVzdBIXCgp0ZXh0X3F1ZXJ5GAEgASgJQgPgQQISFQoNbGFuZ3VhZ2Vf",
            "Y29kZRgCIAEoCRITCgtyZWdpb25fY29kZRgDIAEoCRJQCg9yYW5rX3ByZWZl",
            "cmVuY2UYBCABKA4yNy5nb29nbGUubWFwcy5wbGFjZXMudjEuU2VhcmNoVGV4",
            "dFJlcXVlc3QuUmFua1ByZWZlcmVuY2USFQoNaW5jbHVkZWRfdHlwZRgGIAEo",
            "CRIQCghvcGVuX25vdxgHIAEoCBISCgptaW5fcmF0aW5nGAkgASgBEhgKEG1h",
            "eF9yZXN1bHRfY291bnQYCiABKAUSNwoMcHJpY2VfbGV2ZWxzGAsgAygOMiEu",
            "Z29vZ2xlLm1hcHMucGxhY2VzLnYxLlByaWNlTGV2ZWwSHQoVc3RyaWN0X3R5",
            "cGVfZmlsdGVyaW5nGAwgASgIEkwKDWxvY2F0aW9uX2JpYXMYDSABKAsyNS5n",
            "b29nbGUubWFwcy5wbGFjZXMudjEuU2VhcmNoVGV4dFJlcXVlc3QuTG9jYXRp",
            "b25CaWFzEloKFGxvY2F0aW9uX3Jlc3RyaWN0aW9uGA4gASgLMjwuZ29vZ2xl",
            "Lm1hcHMucGxhY2VzLnYxLlNlYXJjaFRleHRSZXF1ZXN0LkxvY2F0aW9uUmVz",
            "dHJpY3Rpb24SSwoKZXZfb3B0aW9ucxgPIAEoCzIyLmdvb2dsZS5tYXBzLnBs",
            "YWNlcy52MS5TZWFyY2hUZXh0UmVxdWVzdC5FVk9wdGlvbnNCA+BBARJJChJy",
            "b3V0aW5nX3BhcmFtZXRlcnMYECABKAsyKC5nb29nbGUubWFwcy5wbGFjZXMu",
            "djEuUm91dGluZ1BhcmFtZXRlcnNCA+BBARJvCh1zZWFyY2hfYWxvbmdfcm91",
            "dGVfcGFyYW1ldGVycxgRIAEoCzJDLmdvb2dsZS5tYXBzLnBsYWNlcy52MS5T",
            "ZWFyY2hUZXh0UmVxdWVzdC5TZWFyY2hBbG9uZ1JvdXRlUGFyYW1ldGVyc0ID",
            "4EEBEjEKJGluY2x1ZGVfcHVyZV9zZXJ2aWNlX2FyZWFfYnVzaW5lc3NlcxgU",
            "IAEoCEID4EEBGncKDExvY2F0aW9uQmlhcxIuCglyZWN0YW5nbGUYASABKAsy",
            "GS5nb29nbGUuZ2VvLnR5cGUuVmlld3BvcnRIABIvCgZjaXJjbGUYAiABKAsy",
            "HS5nb29nbGUubWFwcy5wbGFjZXMudjEuQ2lyY2xlSABCBgoEdHlwZRpNChNM",
            "b2NhdGlvblJlc3RyaWN0aW9uEi4KCXJlY3RhbmdsZRgBIAEoCzIZLmdvb2ds",
            "ZS5nZW8udHlwZS5WaWV3cG9ydEgAQgYKBHR5cGUaeAoJRVZPcHRpb25zEiUK",
            "GG1pbmltdW1fY2hhcmdpbmdfcmF0ZV9rdxgBIAEoAUID4EEBEkQKD2Nvbm5l",
            "Y3Rvcl90eXBlcxgCIAMoDjImLmdvb2dsZS5tYXBzLnBsYWNlcy52MS5FVkNv",
            "bm5lY3RvclR5cGVCA+BBARpUChpTZWFyY2hBbG9uZ1JvdXRlUGFyYW1ldGVy",
            "cxI2Cghwb2x5bGluZRgBIAEoCzIfLmdvb2dsZS5tYXBzLnBsYWNlcy52MS5Q",
            "b2x5bGluZUID4EECIk4KDlJhbmtQcmVmZXJlbmNlEh8KG1JBTktfUFJFRkVS",
            "RU5DRV9VTlNQRUNJRklFRBAAEgwKCERJU1RBTkNFEAESDQoJUkVMRVZBTkNF",
            "EAIiywEKElNlYXJjaFRleHRSZXNwb25zZRIsCgZwbGFjZXMYASADKAsyHC5n",
            "b29nbGUubWFwcy5wbGFjZXMudjEuUGxhY2USQAoRcm91dGluZ19zdW1tYXJp",
            "ZXMYAiADKAsyJS5nb29nbGUubWFwcy5wbGFjZXMudjEuUm91dGluZ1N1bW1h",
            "cnkSRQoTY29udGV4dHVhbF9jb250ZW50cxgDIAMoCzIoLmdvb2dsZS5tYXBz",
            "LnBsYWNlcy52MS5Db250ZXh0dWFsQ29udGVudCKmAQoUR2V0UGhvdG9NZWRp",
            "YVJlcXVlc3QSNgoEbmFtZRgBIAEoCUIo4EEC+kEiCiBwbGFjZXMuZ29vZ2xl",
            "YXBpcy5jb20vUGhvdG9NZWRpYRIZCgxtYXhfd2lkdGhfcHgYAiABKAVCA+BB",
            "ARIaCg1tYXhfaGVpZ2h0X3B4GAMgASgFQgPgQQESHwoSc2tpcF9odHRwX3Jl",
            "ZGlyZWN0GAQgASgIQgPgQQEinwEKClBob3RvTWVkaWESDAoEbmFtZRgBIAEo",
            "CRIRCglwaG90b191cmkYAiABKAk6cOpBbQogcGxhY2VzLmdvb2dsZWFwaXMu",
            "Y29tL1Bob3RvTWVkaWESMHBsYWNlcy97cGxhY2VfaWR9L3Bob3Rvcy97cGhv",
            "dG9fcmVmZXJlbmNlfS9tZWRpYSoLcGhvdG9NZWRpYXMyCnBob3RvTWVkaWEi",
            "lgEKD0dldFBsYWNlUmVxdWVzdBIxCgRuYW1lGAEgASgJQiPgQQL6QR0KG3Bs",
            "YWNlcy5nb29nbGVhcGlzLmNvbS9QbGFjZRIaCg1sYW5ndWFnZV9jb2RlGAIg",
            "ASgJQgPgQQESGAoLcmVnaW9uX2NvZGUYAyABKAlCA+BBARIaCg1zZXNzaW9u",
            "X3Rva2VuGAQgASgJQgPgQQEipwYKGUF1dG9jb21wbGV0ZVBsYWNlc1JlcXVl",
            "c3QSEgoFaW5wdXQYASABKAlCA+BBAhJZCg1sb2NhdGlvbl9iaWFzGAIgASgL",
            "Mj0uZ29vZ2xlLm1hcHMucGxhY2VzLnYxLkF1dG9jb21wbGV0ZVBsYWNlc1Jl",
            "cXVlc3QuTG9jYXRpb25CaWFzQgPgQQESZwoUbG9jYXRpb25fcmVzdHJpY3Rp",
            "b24YAyABKAsyRC5nb29nbGUubWFwcy5wbGFjZXMudjEuQXV0b2NvbXBsZXRl",
            "UGxhY2VzUmVxdWVzdC5Mb2NhdGlvblJlc3RyaWN0aW9uQgPgQQESIwoWaW5j",
            "bHVkZWRfcHJpbWFyeV90eXBlcxgEIAMoCUID4EEBEiIKFWluY2x1ZGVkX3Jl",
            "Z2lvbl9jb2RlcxgFIAMoCUID4EEBEhoKDWxhbmd1YWdlX2NvZGUYBiABKAlC",
            "A+BBARIYCgtyZWdpb25fY29kZRgHIAEoCUID4EEBEigKBm9yaWdpbhgIIAEo",
            "CzITLmdvb2dsZS50eXBlLkxhdExuZ0ID4EEBEhkKDGlucHV0X29mZnNldBgJ",
            "IAEoBUID4EEBEiYKGWluY2x1ZGVfcXVlcnlfcHJlZGljdGlvbnMYCiABKAhC",
            "A+BBARIaCg1zZXNzaW9uX3Rva2VuGAsgASgJQgPgQQESMQokaW5jbHVkZV9w",
            "dXJlX3NlcnZpY2VfYXJlYV9idXNpbmVzc2VzGAwgASgIQgPgQQEadwoMTG9j",
            "YXRpb25CaWFzEi4KCXJlY3RhbmdsZRgBIAEoCzIZLmdvb2dsZS5nZW8udHlw",
            "ZS5WaWV3cG9ydEgAEi8KBmNpcmNsZRgCIAEoCzIdLmdvb2dsZS5tYXBzLnBs",
            "YWNlcy52MS5DaXJjbGVIAEIGCgR0eXBlGn4KE0xvY2F0aW9uUmVzdHJpY3Rp",
            "b24SLgoJcmVjdGFuZ2xlGAEgASgLMhkuZ29vZ2xlLmdlby50eXBlLlZpZXdw",
            "b3J0SAASLwoGY2lyY2xlGAIgASgLMh0uZ29vZ2xlLm1hcHMucGxhY2VzLnYx",
            "LkNpcmNsZUgAQgYKBHR5cGUiigoKGkF1dG9jb21wbGV0ZVBsYWNlc1Jlc3Bv",
            "bnNlElEKC3N1Z2dlc3Rpb25zGAEgAygLMjwuZ29vZ2xlLm1hcHMucGxhY2Vz",
            "LnYxLkF1dG9jb21wbGV0ZVBsYWNlc1Jlc3BvbnNlLlN1Z2dlc3Rpb24amAkK",
            "ClN1Z2dlc3Rpb24SaAoQcGxhY2VfcHJlZGljdGlvbhgBIAEoCzJMLmdvb2ds",
            "ZS5tYXBzLnBsYWNlcy52MS5BdXRvY29tcGxldGVQbGFjZXNSZXNwb25zZS5T",
            "dWdnZXN0aW9uLlBsYWNlUHJlZGljdGlvbkgAEmgKEHF1ZXJ5X3ByZWRpY3Rp",
            "b24YAiABKAsyTC5nb29nbGUubWFwcy5wbGFjZXMudjEuQXV0b2NvbXBsZXRl",
            "UGxhY2VzUmVzcG9uc2UuU3VnZ2VzdGlvbi5RdWVyeVByZWRpY3Rpb25IABo3",
            "CgtTdHJpbmdSYW5nZRIUCgxzdGFydF9vZmZzZXQYASABKAUSEgoKZW5kX29m",
            "ZnNldBgCIAEoBRp6Cg9Gb3JtYXR0YWJsZVRleHQSDAoEdGV4dBgBIAEoCRJZ",
            "CgdtYXRjaGVzGAIgAygLMkguZ29vZ2xlLm1hcHMucGxhY2VzLnYxLkF1dG9j",
            "b21wbGV0ZVBsYWNlc1Jlc3BvbnNlLlN1Z2dlc3Rpb24uU3RyaW5nUmFuZ2Ua",
            "2QEKEFN0cnVjdHVyZWRGb3JtYXQSXwoJbWFpbl90ZXh0GAEgASgLMkwuZ29v",
            "Z2xlLm1hcHMucGxhY2VzLnYxLkF1dG9jb21wbGV0ZVBsYWNlc1Jlc3BvbnNl",
            "LlN1Z2dlc3Rpb24uRm9ybWF0dGFibGVUZXh0EmQKDnNlY29uZGFyeV90ZXh0",
            "GAIgASgLMkwuZ29vZ2xlLm1hcHMucGxhY2VzLnYxLkF1dG9jb21wbGV0ZVBs",
            "YWNlc1Jlc3BvbnNlLlN1Z2dlc3Rpb24uRm9ybWF0dGFibGVUZXh0GsICCg9Q",
            "bGFjZVByZWRpY3Rpb24SLwoFcGxhY2UYASABKAlCIPpBHQobcGxhY2VzLmdv",
            "b2dsZWFwaXMuY29tL1BsYWNlEhAKCHBsYWNlX2lkGAIgASgJEloKBHRleHQY",
            "AyABKAsyTC5nb29nbGUubWFwcy5wbGFjZXMudjEuQXV0b2NvbXBsZXRlUGxh",
            "Y2VzUmVzcG9uc2UuU3VnZ2VzdGlvbi5Gb3JtYXR0YWJsZVRleHQSaAoRc3Ry",
            "dWN0dXJlZF9mb3JtYXQYBCABKAsyTS5nb29nbGUubWFwcy5wbGFjZXMudjEu",
            "QXV0b2NvbXBsZXRlUGxhY2VzUmVzcG9uc2UuU3VnZ2VzdGlvbi5TdHJ1Y3R1",
            "cmVkRm9ybWF0Eg0KBXR5cGVzGAUgAygJEhcKD2Rpc3RhbmNlX21ldGVycxgG",
            "IAEoBRrXAQoPUXVlcnlQcmVkaWN0aW9uEloKBHRleHQYASABKAsyTC5nb29n",
            "bGUubWFwcy5wbGFjZXMudjEuQXV0b2NvbXBsZXRlUGxhY2VzUmVzcG9uc2Uu",
            "U3VnZ2VzdGlvbi5Gb3JtYXR0YWJsZVRleHQSaAoRc3RydWN0dXJlZF9mb3Jt",
            "YXQYAiABKAsyTS5nb29nbGUubWFwcy5wbGFjZXMudjEuQXV0b2NvbXBsZXRl",
            "UGxhY2VzUmVzcG9uc2UuU3VnZ2VzdGlvbi5TdHJ1Y3R1cmVkRm9ybWF0QgYK",
            "BGtpbmQy4QUKBlBsYWNlcxKLAQoMU2VhcmNoTmVhcmJ5EiouZ29vZ2xlLm1h",
            "cHMucGxhY2VzLnYxLlNlYXJjaE5lYXJieVJlcXVlc3QaKy5nb29nbGUubWFw",
            "cy5wbGFjZXMudjEuU2VhcmNoTmVhcmJ5UmVzcG9uc2UiIoLT5JMCHCIXL3Yx",
            "L3BsYWNlczpzZWFyY2hOZWFyYnk6ASoSgwEKClNlYXJjaFRleHQSKC5nb29n",
            "bGUubWFwcy5wbGFjZXMudjEuU2VhcmNoVGV4dFJlcXVlc3QaKS5nb29nbGUu",
            "bWFwcy5wbGFjZXMudjEuU2VhcmNoVGV4dFJlc3BvbnNlIiCC0+STAhoiFS92",
            "MS9wbGFjZXM6c2VhcmNoVGV4dDoBKhKSAQoNR2V0UGhvdG9NZWRpYRIrLmdv",
            "b2dsZS5tYXBzLnBsYWNlcy52MS5HZXRQaG90b01lZGlhUmVxdWVzdBohLmdv",
            "b2dsZS5tYXBzLnBsYWNlcy52MS5QaG90b01lZGlhIjHaQQRuYW1lgtPkkwIk",
            "EiIvdjEve25hbWU9cGxhY2VzLyovcGhvdG9zLyovbWVkaWF9EnQKCEdldFBs",
            "YWNlEiYuZ29vZ2xlLm1hcHMucGxhY2VzLnYxLkdldFBsYWNlUmVxdWVzdBoc",
            "Lmdvb2dsZS5tYXBzLnBsYWNlcy52MS5QbGFjZSIi2kEEbmFtZYLT5JMCFRIT",
            "L3YxL3tuYW1lPXBsYWNlcy8qfRKdAQoSQXV0b2NvbXBsZXRlUGxhY2VzEjAu",
            "Z29vZ2xlLm1hcHMucGxhY2VzLnYxLkF1dG9jb21wbGV0ZVBsYWNlc1JlcXVl",
            "c3QaMS5nb29nbGUubWFwcy5wbGFjZXMudjEuQXV0b2NvbXBsZXRlUGxhY2Vz",
            "UmVzcG9uc2UiIoLT5JMCHCIXL3YxL3BsYWNlczphdXRvY29tcGxldGU6ASoa",
            "GMpBFXBsYWNlcy5nb29nbGVhcGlzLmNvbUKjAQoZY29tLmdvb2dsZS5tYXBz",
            "LnBsYWNlcy52MUISUGxhY2VzU2VydmljZVByb3RvUAFaN2Nsb3VkLmdvb2ds",
            "ZS5jb20vZ28vbWFwcy9wbGFjZXMvYXBpdjEvcGxhY2VzcGI7cGxhY2VzcGKi",
            "AgZHTVBTVjGqAhVHb29nbGUuTWFwcy5QbGFjZXMuVjHKAhVHb29nbGVcTWFw",
            "c1xQbGFjZXNcVjFiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.AnnotationsReflection.Descriptor, global::Google.Api.ClientReflection.Descriptor, global::Google.Api.FieldBehaviorReflection.Descriptor, global::Google.Api.ResourceReflection.Descriptor, global::Google.Geo.Type.ViewportReflection.Descriptor, global::Google.Maps.Places.V1.ContextualContentReflection.Descriptor, global::Google.Maps.Places.V1.EvChargingReflection.Descriptor, global::Google.Maps.Places.V1.GeometryReflection.Descriptor, global::Google.Maps.Places.V1.PlaceReflection.Descriptor, global::Google.Maps.Places.V1.PolylineReflection.Descriptor, global::Google.Maps.Places.V1.RouteModifiersReflection.Descriptor, global::Google.Maps.Places.V1.RoutingPreferenceReflection.Descriptor, global::Google.Maps.Places.V1.RoutingSummaryReflection.Descriptor, global::Google.Maps.Places.V1.TravelModeReflection.Descriptor, global::Google.Type.LatlngReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.RoutingParameters), global::Google.Maps.Places.V1.RoutingParameters.Parser, new[]{ "Origin", "TravelMode", "RouteModifiers", "RoutingPreference" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.SearchNearbyRequest), global::Google.Maps.Places.V1.SearchNearbyRequest.Parser, new[]{ "LanguageCode", "RegionCode", "IncludedTypes", "ExcludedTypes", "IncludedPrimaryTypes", "ExcludedPrimaryTypes", "MaxResultCount", "LocationRestriction", "RankPreference", "RoutingParameters" }, null, new[]{ typeof(global::Google.Maps.Places.V1.SearchNearbyRequest.Types.RankPreference) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.SearchNearbyRequest.Types.LocationRestriction), global::Google.Maps.Places.V1.SearchNearbyRequest.Types.LocationRestriction.Parser, new[]{ "Circle" }, new[]{ "Type" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.SearchNearbyResponse), global::Google.Maps.Places.V1.SearchNearbyResponse.Parser, new[]{ "Places", "RoutingSummaries" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.SearchTextRequest), global::Google.Maps.Places.V1.SearchTextRequest.Parser, new[]{ "TextQuery", "LanguageCode", "RegionCode", "RankPreference", "IncludedType", "OpenNow", "MinRating", "MaxResultCount", "PriceLevels", "StrictTypeFiltering", "LocationBias", "LocationRestriction", "EvOptions", "RoutingParameters", "SearchAlongRouteParameters", "IncludePureServiceAreaBusinesses" }, null, new[]{ typeof(global::Google.Maps.Places.V1.SearchTextRequest.Types.RankPreference) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationBias), global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationBias.Parser, new[]{ "Rectangle", "Circle" }, new[]{ "Type" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationRestriction), global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationRestriction.Parser, new[]{ "Rectangle" }, new[]{ "Type" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.SearchTextRequest.Types.EVOptions), global::Google.Maps.Places.V1.SearchTextRequest.Types.EVOptions.Parser, new[]{ "MinimumChargingRateKw", "ConnectorTypes" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.SearchTextRequest.Types.SearchAlongRouteParameters), global::Google.Maps.Places.V1.SearchTextRequest.Types.SearchAlongRouteParameters.Parser, new[]{ "Polyline" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.SearchTextResponse), global::Google.Maps.Places.V1.SearchTextResponse.Parser, new[]{ "Places", "RoutingSummaries", "ContextualContents" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.GetPhotoMediaRequest), global::Google.Maps.Places.V1.GetPhotoMediaRequest.Parser, new[]{ "Name", "MaxWidthPx", "MaxHeightPx", "SkipHttpRedirect" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.PhotoMedia), global::Google.Maps.Places.V1.PhotoMedia.Parser, new[]{ "Name", "PhotoUri" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.GetPlaceRequest), global::Google.Maps.Places.V1.GetPlaceRequest.Parser, new[]{ "Name", "LanguageCode", "RegionCode", "SessionToken" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.AutocompletePlacesRequest), global::Google.Maps.Places.V1.AutocompletePlacesRequest.Parser, new[]{ "Input", "LocationBias", "LocationRestriction", "IncludedPrimaryTypes", "IncludedRegionCodes", "LanguageCode", "RegionCode", "Origin", "InputOffset", "IncludeQueryPredictions", "SessionToken", "IncludePureServiceAreaBusinesses" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.AutocompletePlacesRequest.Types.LocationBias), global::Google.Maps.Places.V1.AutocompletePlacesRequest.Types.LocationBias.Parser, new[]{ "Rectangle", "Circle" }, new[]{ "Type" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.AutocompletePlacesRequest.Types.LocationRestriction), global::Google.Maps.Places.V1.AutocompletePlacesRequest.Types.LocationRestriction.Parser, new[]{ "Rectangle", "Circle" }, new[]{ "Type" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.AutocompletePlacesResponse), global::Google.Maps.Places.V1.AutocompletePlacesResponse.Parser, new[]{ "Suggestions" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion), global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Parser, new[]{ "PlacePrediction", "QueryPrediction" }, new[]{ "Kind" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.StringRange), global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.StringRange.Parser, new[]{ "StartOffset", "EndOffset" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.FormattableText), global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.FormattableText.Parser, new[]{ "Text", "Matches" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.StructuredFormat), global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.StructuredFormat.Parser, new[]{ "MainText", "SecondaryText" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.PlacePrediction), global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.PlacePrediction.Parser, new[]{ "Place", "PlaceId", "Text", "StructuredFormat", "Types_", "DistanceMeters" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.QueryPrediction), global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.QueryPrediction.Parser, new[]{ "Text", "StructuredFormat" }, null, null, null, null)})})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Parameters to configure the routing calculations to the places in the
  /// response, both along a route (where result ranking will be influenced) and
  /// for calculating travel times on results.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class RoutingParameters : pb::IMessage<RoutingParameters>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RoutingParameters> _parser = new pb::MessageParser<RoutingParameters>(() => new RoutingParameters());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RoutingParameters> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.Places.V1.PlacesServiceReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RoutingParameters() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RoutingParameters(RoutingParameters other) : this() {
      origin_ = other.origin_ != null ? other.origin_.Clone() : null;
      travelMode_ = other.travelMode_;
      routeModifiers_ = other.routeModifiers_ != null ? other.routeModifiers_.Clone() : null;
      routingPreference_ = other.routingPreference_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RoutingParameters Clone() {
      return new RoutingParameters(this);
    }

    /// <summary>Field number for the "origin" field.</summary>
    public const int OriginFieldNumber = 1;
    private global::Google.Type.LatLng origin_;
    /// <summary>
    /// Optional. An explicit routing origin that overrides the origin defined in
    /// the polyline. By default, the polyline origin is used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Type.LatLng Origin {
      get { return origin_; }
      set {
        origin_ = value;
      }
    }

    /// <summary>Field number for the "travel_mode" field.</summary>
    public const int TravelModeFieldNumber = 2;
    private global::Google.Maps.Places.V1.TravelMode travelMode_ = global::Google.Maps.Places.V1.TravelMode.Unspecified;
    /// <summary>
    /// Optional. The travel mode.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.Places.V1.TravelMode TravelMode {
      get { return travelMode_; }
      set {
        travelMode_ = value;
      }
    }

    /// <summary>Field number for the "route_modifiers" field.</summary>
    public const int RouteModifiersFieldNumber = 3;
    private global::Google.Maps.Places.V1.RouteModifiers routeModifiers_;
    /// <summary>
    /// Optional. The route modifiers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.Places.V1.RouteModifiers RouteModifiers {
      get { return routeModifiers_; }
      set {
        routeModifiers_ = value;
      }
    }

    /// <summary>Field number for the "routing_preference" field.</summary>
    public const int RoutingPreferenceFieldNumber = 4;
    private global::Google.Maps.Places.V1.RoutingPreference routingPreference_ = global::Google.Maps.Places.V1.RoutingPreference.Unspecified;
    /// <summary>
    /// Optional. Specifies how to compute the routing summaries. The server
    /// attempts to use the selected routing preference to compute the route. The
    /// traffic aware routing preference is only available for the `DRIVE` or
    /// `TWO_WHEELER` `travelMode`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.Places.V1.RoutingPreference RoutingPreference {
      get { return routingPreference_; }
      set {
        routingPreference_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RoutingParameters);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RoutingParameters other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Origin, other.Origin)) return false;
      if (TravelMode != other.TravelMode) return false;
      if (!object.Equals(RouteModifiers, other.RouteModifiers)) return false;
      if (RoutingPreference != other.RoutingPreference) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (origin_ != null) hash ^= Origin.GetHashCode();
      if (TravelMode != global::Google.Maps.Places.V1.TravelMode.Unspecified) hash ^= TravelMode.GetHashCode();
      if (routeModifiers_ != null) hash ^= RouteModifiers.GetHashCode();
      if (RoutingPreference != global::Google.Maps.Places.V1.RoutingPreference.Unspecified) hash ^= RoutingPreference.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (origin_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Origin);
      }
      if (TravelMode != global::Google.Maps.Places.V1.TravelMode.Unspecified) {
        output.WriteRawTag(16);
        output.WriteEnum((int) TravelMode);
      }
      if (routeModifiers_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(RouteModifiers);
      }
      if (RoutingPreference != global::Google.Maps.Places.V1.RoutingPreference.Unspecified) {
        output.WriteRawTag(32);
        output.WriteEnum((int) RoutingPreference);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (origin_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Origin);
      }
      if (TravelMode != global::Google.Maps.Places.V1.TravelMode.Unspecified) {
        output.WriteRawTag(16);
        output.WriteEnum((int) TravelMode);
      }
      if (routeModifiers_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(RouteModifiers);
      }
      if (RoutingPreference != global::Google.Maps.Places.V1.RoutingPreference.Unspecified) {
        output.WriteRawTag(32);
        output.WriteEnum((int) RoutingPreference);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (origin_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Origin);
      }
      if (TravelMode != global::Google.Maps.Places.V1.TravelMode.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TravelMode);
      }
      if (routeModifiers_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RouteModifiers);
      }
      if (RoutingPreference != global::Google.Maps.Places.V1.RoutingPreference.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RoutingPreference);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RoutingParameters other) {
      if (other == null) {
        return;
      }
      if (other.origin_ != null) {
        if (origin_ == null) {
          Origin = new global::Google.Type.LatLng();
        }
        Origin.MergeFrom(other.Origin);
      }
      if (other.TravelMode != global::Google.Maps.Places.V1.TravelMode.Unspecified) {
        TravelMode = other.TravelMode;
      }
      if (other.routeModifiers_ != null) {
        if (routeModifiers_ == null) {
          RouteModifiers = new global::Google.Maps.Places.V1.RouteModifiers();
        }
        RouteModifiers.MergeFrom(other.RouteModifiers);
      }
      if (other.RoutingPreference != global::Google.Maps.Places.V1.RoutingPreference.Unspecified) {
        RoutingPreference = other.RoutingPreference;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (origin_ == null) {
              Origin = new global::Google.Type.LatLng();
            }
            input.ReadMessage(Origin);
            break;
          }
          case 16: {
            TravelMode = (global::Google.Maps.Places.V1.TravelMode) input.ReadEnum();
            break;
          }
          case 26: {
            if (routeModifiers_ == null) {
              RouteModifiers = new global::Google.Maps.Places.V1.RouteModifiers();
            }
            input.ReadMessage(RouteModifiers);
            break;
          }
          case 32: {
            RoutingPreference = (global::Google.Maps.Places.V1.RoutingPreference) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (origin_ == null) {
              Origin = new global::Google.Type.LatLng();
            }
            input.ReadMessage(Origin);
            break;
          }
          case 16: {
            TravelMode = (global::Google.Maps.Places.V1.TravelMode) input.ReadEnum();
            break;
          }
          case 26: {
            if (routeModifiers_ == null) {
              RouteModifiers = new global::Google.Maps.Places.V1.RouteModifiers();
            }
            input.ReadMessage(RouteModifiers);
            break;
          }
          case 32: {
            RoutingPreference = (global::Google.Maps.Places.V1.RoutingPreference) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Request proto for Search Nearby.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SearchNearbyRequest : pb::IMessage<SearchNearbyRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SearchNearbyRequest> _parser = new pb::MessageParser<SearchNearbyRequest>(() => new SearchNearbyRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SearchNearbyRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.Places.V1.PlacesServiceReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchNearbyRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchNearbyRequest(SearchNearbyRequest other) : this() {
      languageCode_ = other.languageCode_;
      regionCode_ = other.regionCode_;
      includedTypes_ = other.includedTypes_.Clone();
      excludedTypes_ = other.excludedTypes_.Clone();
      includedPrimaryTypes_ = other.includedPrimaryTypes_.Clone();
      excludedPrimaryTypes_ = other.excludedPrimaryTypes_.Clone();
      maxResultCount_ = other.maxResultCount_;
      locationRestriction_ = other.locationRestriction_ != null ? other.locationRestriction_.Clone() : null;
      rankPreference_ = other.rankPreference_;
      routingParameters_ = other.routingParameters_ != null ? other.routingParameters_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchNearbyRequest Clone() {
      return new SearchNearbyRequest(this);
    }

    /// <summary>Field number for the "language_code" field.</summary>
    public const int LanguageCodeFieldNumber = 1;
    private string languageCode_ = "";
    /// <summary>
    /// Place details will be displayed with the preferred language if available.
    /// If the language code is unspecified or unrecognized, place details of any
    /// language may be returned, with a preference for English if such details
    /// exist.
    ///
    /// Current list of supported languages:
    /// https://developers.google.com/maps/faq#languagesupport.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string LanguageCode {
      get { return languageCode_; }
      set {
        languageCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "region_code" field.</summary>
    public const int RegionCodeFieldNumber = 2;
    private string regionCode_ = "";
    /// <summary>
    /// The Unicode country/region code (CLDR) of the location where the
    /// request is coming from. This parameter is used to display the place
    /// details, like region-specific place name, if available. The parameter can
    /// affect results based on applicable law.
    ///
    /// For more information, see
    /// https://www.unicode.org/cldr/charts/latest/supplemental/territory_language_information.html.
    ///
    /// Note that 3-digit region codes are not currently supported.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RegionCode {
      get { return regionCode_; }
      set {
        regionCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "included_types" field.</summary>
    public const int IncludedTypesFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_includedTypes_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> includedTypes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Included Place type (eg, "restaurant" or "gas_station") from
    /// https://developers.google.com/maps/documentation/places/web-service/place-types.
    ///
    /// Up to 50 types from [Table
    /// A](https://developers.google.com/maps/documentation/places/web-service/place-types#table-a)
    /// may be specified.
    ///
    /// If there are any conflicting types, i.e. a type appears in both
    /// included_types and excluded_types, an INVALID_ARGUMENT error is
    /// returned.
    ///
    /// If a Place type is specified with multiple type restrictions, only places
    /// that satisfy all of the restrictions are returned. For example, if we
    /// have {included_types = ["restaurant"], excluded_primary_types =
    /// ["restaurant"]}, the returned places provide "restaurant"
    /// related services but do not operate primarily as "restaurants".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> IncludedTypes {
      get { return includedTypes_; }
    }

    /// <summary>Field number for the "excluded_types" field.</summary>
    public const int ExcludedTypesFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_excludedTypes_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> excludedTypes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Excluded Place type (eg, "restaurant" or "gas_station") from
    /// https://developers.google.com/maps/documentation/places/web-service/place-types.
    ///
    /// Up to 50 types from [Table
    /// A](https://developers.google.com/maps/documentation/places/web-service/place-types#table-a)
    /// may be specified.
    ///
    /// If the client provides both included_types (e.g. restaurant) and
    /// excluded_types (e.g. cafe), then the response should include places that
    /// are restaurant but not cafe. The response includes places that match at
    /// least one of the included_types and none of the excluded_types.
    ///
    /// If there are any conflicting types, i.e. a type appears in both
    /// included_types and excluded_types, an INVALID_ARGUMENT error is returned.
    ///
    /// If a Place type is specified with multiple type restrictions, only places
    /// that satisfy all of the restrictions are returned. For example, if we
    /// have {included_types = ["restaurant"], excluded_primary_types =
    /// ["restaurant"]}, the returned places provide "restaurant"
    /// related services but do not operate primarily as "restaurants".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> ExcludedTypes {
      get { return excludedTypes_; }
    }

    /// <summary>Field number for the "included_primary_types" field.</summary>
    public const int IncludedPrimaryTypesFieldNumber = 5;
    private static readonly pb::FieldCodec<string> _repeated_includedPrimaryTypes_codec
        = pb::FieldCodec.ForString(42);
    private readonly pbc::RepeatedField<string> includedPrimaryTypes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Included primary Place type (e.g. "restaurant" or "gas_station") from
    /// https://developers.google.com/maps/documentation/places/web-service/place-types.
    /// A place can only have a single primary type from the supported types table
    /// associated with it.
    ///
    /// Up to 50 types from [Table
    /// A](https://developers.google.com/maps/documentation/places/web-service/place-types#table-a)
    /// may be specified.
    ///
    /// If there are any conflicting primary types, i.e. a type appears in both
    /// included_primary_types and excluded_primary_types, an INVALID_ARGUMENT
    /// error is returned.
    ///
    /// If a Place type is specified with multiple type restrictions, only places
    /// that satisfy all of the restrictions are returned. For example, if we
    /// have {included_types = ["restaurant"], excluded_primary_types =
    /// ["restaurant"]}, the returned places provide "restaurant"
    /// related services but do not operate primarily as "restaurants".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> IncludedPrimaryTypes {
      get { return includedPrimaryTypes_; }
    }

    /// <summary>Field number for the "excluded_primary_types" field.</summary>
    public const int ExcludedPrimaryTypesFieldNumber = 6;
    private static readonly pb::FieldCodec<string> _repeated_excludedPrimaryTypes_codec
        = pb::FieldCodec.ForString(50);
    private readonly pbc::RepeatedField<string> excludedPrimaryTypes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Excluded primary Place type (e.g. "restaurant" or "gas_station") from
    /// https://developers.google.com/maps/documentation/places/web-service/place-types.
    ///
    /// Up to 50 types from [Table
    /// A](https://developers.google.com/maps/documentation/places/web-service/place-types#table-a)
    /// may be specified.
    ///
    /// If there are any conflicting primary types, i.e. a type appears in both
    /// included_primary_types and excluded_primary_types, an INVALID_ARGUMENT
    /// error is returned.
    ///
    /// If a Place type is specified with multiple type restrictions, only places
    /// that satisfy all of the restrictions are returned. For example, if we
    /// have {included_types = ["restaurant"], excluded_primary_types =
    /// ["restaurant"]}, the returned places provide "restaurant"
    /// related services but do not operate primarily as "restaurants".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> ExcludedPrimaryTypes {
      get { return excludedPrimaryTypes_; }
    }

    /// <summary>Field number for the "max_result_count" field.</summary>
    public const int MaxResultCountFieldNumber = 7;
    private int maxResultCount_;
    /// <summary>
    /// Maximum number of results to return. It must be between 1 and 20 (default),
    /// inclusively. If the number is unset, it falls back to the upper limit. If
    /// the number is set to negative or exceeds the upper limit, an
    /// INVALID_ARGUMENT error is returned.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MaxResultCount {
      get { return maxResultCount_; }
      set {
        maxResultCount_ = value;
      }
    }

    /// <summary>Field number for the "location_restriction" field.</summary>
    public const int LocationRestrictionFieldNumber = 8;
    private global::Google.Maps.Places.V1.SearchNearbyRequest.Types.LocationRestriction locationRestriction_;
    /// <summary>
    /// Required. The region to search.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.Places.V1.SearchNearbyRequest.Types.LocationRestriction LocationRestriction {
      get { return locationRestriction_; }
      set {
        locationRestriction_ = value;
      }
    }

    /// <summary>Field number for the "rank_preference" field.</summary>
    public const int RankPreferenceFieldNumber = 9;
    private global::Google.Maps.Places.V1.SearchNearbyRequest.Types.RankPreference rankPreference_ = global::Google.Maps.Places.V1.SearchNearbyRequest.Types.RankPreference.Unspecified;
    /// <summary>
    /// How results will be ranked in the response.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.Places.V1.SearchNearbyRequest.Types.RankPreference RankPreference {
      get { return rankPreference_; }
      set {
        rankPreference_ = value;
      }
    }

    /// <summary>Field number for the "routing_parameters" field.</summary>
    public const int RoutingParametersFieldNumber = 10;
    private global::Google.Maps.Places.V1.RoutingParameters routingParameters_;
    /// <summary>
    /// Optional. Parameters that affect the routing to the search results.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.Places.V1.RoutingParameters RoutingParameters {
      get { return routingParameters_; }
      set {
        routingParameters_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SearchNearbyRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SearchNearbyRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (LanguageCode != other.LanguageCode) return false;
      if (RegionCode != other.RegionCode) return false;
      if(!includedTypes_.Equals(other.includedTypes_)) return false;
      if(!excludedTypes_.Equals(other.excludedTypes_)) return false;
      if(!includedPrimaryTypes_.Equals(other.includedPrimaryTypes_)) return false;
      if(!excludedPrimaryTypes_.Equals(other.excludedPrimaryTypes_)) return false;
      if (MaxResultCount != other.MaxResultCount) return false;
      if (!object.Equals(LocationRestriction, other.LocationRestriction)) return false;
      if (RankPreference != other.RankPreference) return false;
      if (!object.Equals(RoutingParameters, other.RoutingParameters)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (LanguageCode.Length != 0) hash ^= LanguageCode.GetHashCode();
      if (RegionCode.Length != 0) hash ^= RegionCode.GetHashCode();
      hash ^= includedTypes_.GetHashCode();
      hash ^= excludedTypes_.GetHashCode();
      hash ^= includedPrimaryTypes_.GetHashCode();
      hash ^= excludedPrimaryTypes_.GetHashCode();
      if (MaxResultCount != 0) hash ^= MaxResultCount.GetHashCode();
      if (locationRestriction_ != null) hash ^= LocationRestriction.GetHashCode();
      if (RankPreference != global::Google.Maps.Places.V1.SearchNearbyRequest.Types.RankPreference.Unspecified) hash ^= RankPreference.GetHashCode();
      if (routingParameters_ != null) hash ^= RoutingParameters.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (LanguageCode.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(LanguageCode);
      }
      if (RegionCode.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(RegionCode);
      }
      includedTypes_.WriteTo(output, _repeated_includedTypes_codec);
      excludedTypes_.WriteTo(output, _repeated_excludedTypes_codec);
      includedPrimaryTypes_.WriteTo(output, _repeated_includedPrimaryTypes_codec);
      excludedPrimaryTypes_.WriteTo(output, _repeated_excludedPrimaryTypes_codec);
      if (MaxResultCount != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(MaxResultCount);
      }
      if (locationRestriction_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(LocationRestriction);
      }
      if (RankPreference != global::Google.Maps.Places.V1.SearchNearbyRequest.Types.RankPreference.Unspecified) {
        output.WriteRawTag(72);
        output.WriteEnum((int) RankPreference);
      }
      if (routingParameters_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(RoutingParameters);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (LanguageCode.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(LanguageCode);
      }
      if (RegionCode.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(RegionCode);
      }
      includedTypes_.WriteTo(ref output, _repeated_includedTypes_codec);
      excludedTypes_.WriteTo(ref output, _repeated_excludedTypes_codec);
      includedPrimaryTypes_.WriteTo(ref output, _repeated_includedPrimaryTypes_codec);
      excludedPrimaryTypes_.WriteTo(ref output, _repeated_excludedPrimaryTypes_codec);
      if (MaxResultCount != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(MaxResultCount);
      }
      if (locationRestriction_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(LocationRestriction);
      }
      if (RankPreference != global::Google.Maps.Places.V1.SearchNearbyRequest.Types.RankPreference.Unspecified) {
        output.WriteRawTag(72);
        output.WriteEnum((int) RankPreference);
      }
      if (routingParameters_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(RoutingParameters);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (LanguageCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LanguageCode);
      }
      if (RegionCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RegionCode);
      }
      size += includedTypes_.CalculateSize(_repeated_includedTypes_codec);
      size += excludedTypes_.CalculateSize(_repeated_excludedTypes_codec);
      size += includedPrimaryTypes_.CalculateSize(_repeated_includedPrimaryTypes_codec);
      size += excludedPrimaryTypes_.CalculateSize(_repeated_excludedPrimaryTypes_codec);
      if (MaxResultCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxResultCount);
      }
      if (locationRestriction_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocationRestriction);
      }
      if (RankPreference != global::Google.Maps.Places.V1.SearchNearbyRequest.Types.RankPreference.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RankPreference);
      }
      if (routingParameters_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RoutingParameters);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SearchNearbyRequest other) {
      if (other == null) {
        return;
      }
      if (other.LanguageCode.Length != 0) {
        LanguageCode = other.LanguageCode;
      }
      if (other.RegionCode.Length != 0) {
        RegionCode = other.RegionCode;
      }
      includedTypes_.Add(other.includedTypes_);
      excludedTypes_.Add(other.excludedTypes_);
      includedPrimaryTypes_.Add(other.includedPrimaryTypes_);
      excludedPrimaryTypes_.Add(other.excludedPrimaryTypes_);
      if (other.MaxResultCount != 0) {
        MaxResultCount = other.MaxResultCount;
      }
      if (other.locationRestriction_ != null) {
        if (locationRestriction_ == null) {
          LocationRestriction = new global::Google.Maps.Places.V1.SearchNearbyRequest.Types.LocationRestriction();
        }
        LocationRestriction.MergeFrom(other.LocationRestriction);
      }
      if (other.RankPreference != global::Google.Maps.Places.V1.SearchNearbyRequest.Types.RankPreference.Unspecified) {
        RankPreference = other.RankPreference;
      }
      if (other.routingParameters_ != null) {
        if (routingParameters_ == null) {
          RoutingParameters = new global::Google.Maps.Places.V1.RoutingParameters();
        }
        RoutingParameters.MergeFrom(other.RoutingParameters);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            LanguageCode = input.ReadString();
            break;
          }
          case 18: {
            RegionCode = input.ReadString();
            break;
          }
          case 26: {
            includedTypes_.AddEntriesFrom(input, _repeated_includedTypes_codec);
            break;
          }
          case 34: {
            excludedTypes_.AddEntriesFrom(input, _repeated_excludedTypes_codec);
            break;
          }
          case 42: {
            includedPrimaryTypes_.AddEntriesFrom(input, _repeated_includedPrimaryTypes_codec);
            break;
          }
          case 50: {
            excludedPrimaryTypes_.AddEntriesFrom(input, _repeated_excludedPrimaryTypes_codec);
            break;
          }
          case 56: {
            MaxResultCount = input.ReadInt32();
            break;
          }
          case 66: {
            if (locationRestriction_ == null) {
              LocationRestriction = new global::Google.Maps.Places.V1.SearchNearbyRequest.Types.LocationRestriction();
            }
            input.ReadMessage(LocationRestriction);
            break;
          }
          case 72: {
            RankPreference = (global::Google.Maps.Places.V1.SearchNearbyRequest.Types.RankPreference) input.ReadEnum();
            break;
          }
          case 82: {
            if (routingParameters_ == null) {
              RoutingParameters = new global::Google.Maps.Places.V1.RoutingParameters();
            }
            input.ReadMessage(RoutingParameters);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            LanguageCode = input.ReadString();
            break;
          }
          case 18: {
            RegionCode = input.ReadString();
            break;
          }
          case 26: {
            includedTypes_.AddEntriesFrom(ref input, _repeated_includedTypes_codec);
            break;
          }
          case 34: {
            excludedTypes_.AddEntriesFrom(ref input, _repeated_excludedTypes_codec);
            break;
          }
          case 42: {
            includedPrimaryTypes_.AddEntriesFrom(ref input, _repeated_includedPrimaryTypes_codec);
            break;
          }
          case 50: {
            excludedPrimaryTypes_.AddEntriesFrom(ref input, _repeated_excludedPrimaryTypes_codec);
            break;
          }
          case 56: {
            MaxResultCount = input.ReadInt32();
            break;
          }
          case 66: {
            if (locationRestriction_ == null) {
              LocationRestriction = new global::Google.Maps.Places.V1.SearchNearbyRequest.Types.LocationRestriction();
            }
            input.ReadMessage(LocationRestriction);
            break;
          }
          case 72: {
            RankPreference = (global::Google.Maps.Places.V1.SearchNearbyRequest.Types.RankPreference) input.ReadEnum();
            break;
          }
          case 82: {
            if (routingParameters_ == null) {
              RoutingParameters = new global::Google.Maps.Places.V1.RoutingParameters();
            }
            input.ReadMessage(RoutingParameters);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the SearchNearbyRequest message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// How results will be ranked in the response.
      /// </summary>
      public enum RankPreference {
        /// <summary>
        /// RankPreference value not set. Will use rank by POPULARITY by default.
        /// </summary>
        [pbr::OriginalName("RANK_PREFERENCE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Ranks results by distance.
        /// </summary>
        [pbr::OriginalName("DISTANCE")] Distance = 1,
        /// <summary>
        /// Ranks results by popularity.
        /// </summary>
        [pbr::OriginalName("POPULARITY")] Popularity = 2,
      }

      /// <summary>
      /// The region to search.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class LocationRestriction : pb::IMessage<LocationRestriction>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<LocationRestriction> _parser = new pb::MessageParser<LocationRestriction>(() => new LocationRestriction());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<LocationRestriction> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.Places.V1.SearchNearbyRequest.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocationRestriction() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocationRestriction(LocationRestriction other) : this() {
          switch (other.TypeCase) {
            case TypeOneofCase.Circle:
              Circle = other.Circle.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocationRestriction Clone() {
          return new LocationRestriction(this);
        }

        /// <summary>Field number for the "circle" field.</summary>
        public const int CircleFieldNumber = 2;
        /// <summary>
        /// A circle defined by center point and radius.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Maps.Places.V1.Circle Circle {
          get { return typeCase_ == TypeOneofCase.Circle ? (global::Google.Maps.Places.V1.Circle) type_ : null; }
          set {
            type_ = value;
            typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Circle;
          }
        }

        private object type_;
        /// <summary>Enum of possible cases for the "type" oneof.</summary>
        public enum TypeOneofCase {
          None = 0,
          Circle = 2,
        }
        private TypeOneofCase typeCase_ = TypeOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TypeOneofCase TypeCase {
          get { return typeCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearType() {
          typeCase_ = TypeOneofCase.None;
          type_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as LocationRestriction);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(LocationRestriction other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Circle, other.Circle)) return false;
          if (TypeCase != other.TypeCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (typeCase_ == TypeOneofCase.Circle) hash ^= Circle.GetHashCode();
          hash ^= (int) typeCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (typeCase_ == TypeOneofCase.Circle) {
            output.WriteRawTag(18);
            output.WriteMessage(Circle);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (typeCase_ == TypeOneofCase.Circle) {
            output.WriteRawTag(18);
            output.WriteMessage(Circle);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (typeCase_ == TypeOneofCase.Circle) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Circle);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(LocationRestriction other) {
          if (other == null) {
            return;
          }
          switch (other.TypeCase) {
            case TypeOneofCase.Circle:
              if (Circle == null) {
                Circle = new global::Google.Maps.Places.V1.Circle();
              }
              Circle.MergeFrom(other.Circle);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 18: {
                global::Google.Maps.Places.V1.Circle subBuilder = new global::Google.Maps.Places.V1.Circle();
                if (typeCase_ == TypeOneofCase.Circle) {
                  subBuilder.MergeFrom(Circle);
                }
                input.ReadMessage(subBuilder);
                Circle = subBuilder;
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 18: {
                global::Google.Maps.Places.V1.Circle subBuilder = new global::Google.Maps.Places.V1.Circle();
                if (typeCase_ == TypeOneofCase.Circle) {
                  subBuilder.MergeFrom(Circle);
                }
                input.ReadMessage(subBuilder);
                Circle = subBuilder;
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Response proto for Search Nearby.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SearchNearbyResponse : pb::IMessage<SearchNearbyResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SearchNearbyResponse> _parser = new pb::MessageParser<SearchNearbyResponse>(() => new SearchNearbyResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SearchNearbyResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.Places.V1.PlacesServiceReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchNearbyResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchNearbyResponse(SearchNearbyResponse other) : this() {
      places_ = other.places_.Clone();
      routingSummaries_ = other.routingSummaries_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchNearbyResponse Clone() {
      return new SearchNearbyResponse(this);
    }

    /// <summary>Field number for the "places" field.</summary>
    public const int PlacesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Maps.Places.V1.Place> _repeated_places_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Maps.Places.V1.Place.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.Places.V1.Place> places_ = new pbc::RepeatedField<global::Google.Maps.Places.V1.Place>();
    /// <summary>
    /// A list of places that meets user's requirements like places
    /// types, number of places and specific location restriction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.Places.V1.Place> Places {
      get { return places_; }
    }

    /// <summary>Field number for the "routing_summaries" field.</summary>
    public const int RoutingSummariesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Google.Maps.Places.V1.RoutingSummary> _repeated_routingSummaries_codec
        = pb::FieldCodec.ForMessage(18, global::Google.Maps.Places.V1.RoutingSummary.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.Places.V1.RoutingSummary> routingSummaries_ = new pbc::RepeatedField<global::Google.Maps.Places.V1.RoutingSummary>();
    /// <summary>
    /// A list of routing summaries where each entry associates to the
    /// corresponding place in the same index in the `places` field. If the routing
    /// summary is not available for one of the places, it will contain an empty
    /// entry. This list should have as many entries as the list of places if
    /// requested.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.Places.V1.RoutingSummary> RoutingSummaries {
      get { return routingSummaries_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SearchNearbyResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SearchNearbyResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!places_.Equals(other.places_)) return false;
      if(!routingSummaries_.Equals(other.routingSummaries_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= places_.GetHashCode();
      hash ^= routingSummaries_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      places_.WriteTo(output, _repeated_places_codec);
      routingSummaries_.WriteTo(output, _repeated_routingSummaries_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      places_.WriteTo(ref output, _repeated_places_codec);
      routingSummaries_.WriteTo(ref output, _repeated_routingSummaries_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += places_.CalculateSize(_repeated_places_codec);
      size += routingSummaries_.CalculateSize(_repeated_routingSummaries_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SearchNearbyResponse other) {
      if (other == null) {
        return;
      }
      places_.Add(other.places_);
      routingSummaries_.Add(other.routingSummaries_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            places_.AddEntriesFrom(input, _repeated_places_codec);
            break;
          }
          case 18: {
            routingSummaries_.AddEntriesFrom(input, _repeated_routingSummaries_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            places_.AddEntriesFrom(ref input, _repeated_places_codec);
            break;
          }
          case 18: {
            routingSummaries_.AddEntriesFrom(ref input, _repeated_routingSummaries_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Request proto for SearchText.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SearchTextRequest : pb::IMessage<SearchTextRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SearchTextRequest> _parser = new pb::MessageParser<SearchTextRequest>(() => new SearchTextRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SearchTextRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.Places.V1.PlacesServiceReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchTextRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchTextRequest(SearchTextRequest other) : this() {
      textQuery_ = other.textQuery_;
      languageCode_ = other.languageCode_;
      regionCode_ = other.regionCode_;
      rankPreference_ = other.rankPreference_;
      includedType_ = other.includedType_;
      openNow_ = other.openNow_;
      minRating_ = other.minRating_;
      maxResultCount_ = other.maxResultCount_;
      priceLevels_ = other.priceLevels_.Clone();
      strictTypeFiltering_ = other.strictTypeFiltering_;
      locationBias_ = other.locationBias_ != null ? other.locationBias_.Clone() : null;
      locationRestriction_ = other.locationRestriction_ != null ? other.locationRestriction_.Clone() : null;
      evOptions_ = other.evOptions_ != null ? other.evOptions_.Clone() : null;
      routingParameters_ = other.routingParameters_ != null ? other.routingParameters_.Clone() : null;
      searchAlongRouteParameters_ = other.searchAlongRouteParameters_ != null ? other.searchAlongRouteParameters_.Clone() : null;
      includePureServiceAreaBusinesses_ = other.includePureServiceAreaBusinesses_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchTextRequest Clone() {
      return new SearchTextRequest(this);
    }

    /// <summary>Field number for the "text_query" field.</summary>
    public const int TextQueryFieldNumber = 1;
    private string textQuery_ = "";
    /// <summary>
    /// Required. The text query for textual search.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string TextQuery {
      get { return textQuery_; }
      set {
        textQuery_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "language_code" field.</summary>
    public const int LanguageCodeFieldNumber = 2;
    private string languageCode_ = "";
    /// <summary>
    /// Place details will be displayed with the preferred language if available.
    /// If the language code is unspecified or unrecognized, place details of any
    /// language may be returned, with a preference for English if such details
    /// exist.
    ///
    /// Current list of supported languages:
    /// https://developers.google.com/maps/faq#languagesupport.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string LanguageCode {
      get { return languageCode_; }
      set {
        languageCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "region_code" field.</summary>
    public const int RegionCodeFieldNumber = 3;
    private string regionCode_ = "";
    /// <summary>
    /// The Unicode country/region code (CLDR) of the location where the
    /// request is coming from. This parameter is used to display the place
    /// details, like region-specific place name, if available. The parameter can
    /// affect results based on applicable law.
    ///
    /// For more information, see
    /// https://www.unicode.org/cldr/charts/latest/supplemental/territory_language_information.html.
    ///
    /// Note that 3-digit region codes are not currently supported.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RegionCode {
      get { return regionCode_; }
      set {
        regionCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "rank_preference" field.</summary>
    public const int RankPreferenceFieldNumber = 4;
    private global::Google.Maps.Places.V1.SearchTextRequest.Types.RankPreference rankPreference_ = global::Google.Maps.Places.V1.SearchTextRequest.Types.RankPreference.Unspecified;
    /// <summary>
    /// How results will be ranked in the response.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.Places.V1.SearchTextRequest.Types.RankPreference RankPreference {
      get { return rankPreference_; }
      set {
        rankPreference_ = value;
      }
    }

    /// <summary>Field number for the "included_type" field.</summary>
    public const int IncludedTypeFieldNumber = 6;
    private string includedType_ = "";
    /// <summary>
    /// The requested place type. Full list of types supported:
    /// https://developers.google.com/maps/documentation/places/web-service/place-types.
    /// Only support one included type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string IncludedType {
      get { return includedType_; }
      set {
        includedType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "open_now" field.</summary>
    public const int OpenNowFieldNumber = 7;
    private bool openNow_;
    /// <summary>
    /// Used to restrict the search to places that are currently open.  The default
    /// is false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool OpenNow {
      get { return openNow_; }
      set {
        openNow_ = value;
      }
    }

    /// <summary>Field number for the "min_rating" field.</summary>
    public const int MinRatingFieldNumber = 9;
    private double minRating_;
    /// <summary>
    /// Filter out results whose average user rating is strictly less than this
    /// limit. A valid value must be a float between 0 and 5 (inclusively) at a
    /// 0.5 cadence i.e. [0, 0.5, 1.0, ... , 5.0] inclusively. The input rating
    /// will round up to the nearest 0.5(ceiling). For instance, a rating of 0.6
    /// will eliminate all results with a less than 1.0 rating.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double MinRating {
      get { return minRating_; }
      set {
        minRating_ = value;
      }
    }

    /// <summary>Field number for the "max_result_count" field.</summary>
    public const int MaxResultCountFieldNumber = 10;
    private int maxResultCount_;
    /// <summary>
    /// Maximum number of results to return. It must be between 1 and 20,
    /// inclusively. The default is 20.  If the number is unset, it falls back to
    /// the upper limit. If the number is set to negative or exceeds the upper
    /// limit, an INVALID_ARGUMENT error is returned.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MaxResultCount {
      get { return maxResultCount_; }
      set {
        maxResultCount_ = value;
      }
    }

    /// <summary>Field number for the "price_levels" field.</summary>
    public const int PriceLevelsFieldNumber = 11;
    private static readonly pb::FieldCodec<global::Google.Maps.Places.V1.PriceLevel> _repeated_priceLevels_codec
        = pb::FieldCodec.ForEnum(90, x => (int) x, x => (global::Google.Maps.Places.V1.PriceLevel) x);
    private readonly pbc::RepeatedField<global::Google.Maps.Places.V1.PriceLevel> priceLevels_ = new pbc::RepeatedField<global::Google.Maps.Places.V1.PriceLevel>();
    /// <summary>
    /// Used to restrict the search to places that are marked as certain price
    /// levels. Users can choose any combinations of price levels. Default to
    /// select all price levels.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.Places.V1.PriceLevel> PriceLevels {
      get { return priceLevels_; }
    }

    /// <summary>Field number for the "strict_type_filtering" field.</summary>
    public const int StrictTypeFilteringFieldNumber = 12;
    private bool strictTypeFiltering_;
    /// <summary>
    /// Used to set strict type filtering for included_type. If set to true, only
    /// results of the same type will be returned. Default to false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool StrictTypeFiltering {
      get { return strictTypeFiltering_; }
      set {
        strictTypeFiltering_ = value;
      }
    }

    /// <summary>Field number for the "location_bias" field.</summary>
    public const int LocationBiasFieldNumber = 13;
    private global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationBias locationBias_;
    /// <summary>
    /// The region to search. This location serves as a bias which means results
    /// around given location might be returned. Cannot be set along with
    /// location_restriction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationBias LocationBias {
      get { return locationBias_; }
      set {
        locationBias_ = value;
      }
    }

    /// <summary>Field number for the "location_restriction" field.</summary>
    public const int LocationRestrictionFieldNumber = 14;
    private global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationRestriction locationRestriction_;
    /// <summary>
    /// The region to search. This location serves as a restriction which means
    /// results outside given location will not be returned. Cannot be set along
    /// with location_bias.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationRestriction LocationRestriction {
      get { return locationRestriction_; }
      set {
        locationRestriction_ = value;
      }
    }

    /// <summary>Field number for the "ev_options" field.</summary>
    public const int EvOptionsFieldNumber = 15;
    private global::Google.Maps.Places.V1.SearchTextRequest.Types.EVOptions evOptions_;
    /// <summary>
    /// Optional. Set the searchable EV options of a place search request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.Places.V1.SearchTextRequest.Types.EVOptions EvOptions {
      get { return evOptions_; }
      set {
        evOptions_ = value;
      }
    }

    /// <summary>Field number for the "routing_parameters" field.</summary>
    public const int RoutingParametersFieldNumber = 16;
    private global::Google.Maps.Places.V1.RoutingParameters routingParameters_;
    /// <summary>
    /// Optional. Additional parameters for routing to results.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.Places.V1.RoutingParameters RoutingParameters {
      get { return routingParameters_; }
      set {
        routingParameters_ = value;
      }
    }

    /// <summary>Field number for the "search_along_route_parameters" field.</summary>
    public const int SearchAlongRouteParametersFieldNumber = 17;
    private global::Google.Maps.Places.V1.SearchTextRequest.Types.SearchAlongRouteParameters searchAlongRouteParameters_;
    /// <summary>
    /// Optional. Additional parameters proto for searching along a route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.Places.V1.SearchTextRequest.Types.SearchAlongRouteParameters SearchAlongRouteParameters {
      get { return searchAlongRouteParameters_; }
      set {
        searchAlongRouteParameters_ = value;
      }
    }

    /// <summary>Field number for the "include_pure_service_area_businesses" field.</summary>
    public const int IncludePureServiceAreaBusinessesFieldNumber = 20;
    private bool includePureServiceAreaBusinesses_;
    /// <summary>
    /// Optional. Include pure service area businesses if the field is set to true.
    /// Pure service area business is a business that visits or delivers to
    /// customers directly but does not serve customers at their business address.
    /// For example, businesses like cleaning services or plumbers. Those
    /// businesses do not have a physical address or location on Google Maps.
    /// Places will not return fields including `location`, `plus_code`, and other
    /// location related fields for these businesses.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IncludePureServiceAreaBusinesses {
      get { return includePureServiceAreaBusinesses_; }
      set {
        includePureServiceAreaBusinesses_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SearchTextRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SearchTextRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TextQuery != other.TextQuery) return false;
      if (LanguageCode != other.LanguageCode) return false;
      if (RegionCode != other.RegionCode) return false;
      if (RankPreference != other.RankPreference) return false;
      if (IncludedType != other.IncludedType) return false;
      if (OpenNow != other.OpenNow) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(MinRating, other.MinRating)) return false;
      if (MaxResultCount != other.MaxResultCount) return false;
      if(!priceLevels_.Equals(other.priceLevels_)) return false;
      if (StrictTypeFiltering != other.StrictTypeFiltering) return false;
      if (!object.Equals(LocationBias, other.LocationBias)) return false;
      if (!object.Equals(LocationRestriction, other.LocationRestriction)) return false;
      if (!object.Equals(EvOptions, other.EvOptions)) return false;
      if (!object.Equals(RoutingParameters, other.RoutingParameters)) return false;
      if (!object.Equals(SearchAlongRouteParameters, other.SearchAlongRouteParameters)) return false;
      if (IncludePureServiceAreaBusinesses != other.IncludePureServiceAreaBusinesses) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (TextQuery.Length != 0) hash ^= TextQuery.GetHashCode();
      if (LanguageCode.Length != 0) hash ^= LanguageCode.GetHashCode();
      if (RegionCode.Length != 0) hash ^= RegionCode.GetHashCode();
      if (RankPreference != global::Google.Maps.Places.V1.SearchTextRequest.Types.RankPreference.Unspecified) hash ^= RankPreference.GetHashCode();
      if (IncludedType.Length != 0) hash ^= IncludedType.GetHashCode();
      if (OpenNow != false) hash ^= OpenNow.GetHashCode();
      if (MinRating != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(MinRating);
      if (MaxResultCount != 0) hash ^= MaxResultCount.GetHashCode();
      hash ^= priceLevels_.GetHashCode();
      if (StrictTypeFiltering != false) hash ^= StrictTypeFiltering.GetHashCode();
      if (locationBias_ != null) hash ^= LocationBias.GetHashCode();
      if (locationRestriction_ != null) hash ^= LocationRestriction.GetHashCode();
      if (evOptions_ != null) hash ^= EvOptions.GetHashCode();
      if (routingParameters_ != null) hash ^= RoutingParameters.GetHashCode();
      if (searchAlongRouteParameters_ != null) hash ^= SearchAlongRouteParameters.GetHashCode();
      if (IncludePureServiceAreaBusinesses != false) hash ^= IncludePureServiceAreaBusinesses.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (TextQuery.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(TextQuery);
      }
      if (LanguageCode.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(LanguageCode);
      }
      if (RegionCode.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(RegionCode);
      }
      if (RankPreference != global::Google.Maps.Places.V1.SearchTextRequest.Types.RankPreference.Unspecified) {
        output.WriteRawTag(32);
        output.WriteEnum((int) RankPreference);
      }
      if (IncludedType.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(IncludedType);
      }
      if (OpenNow != false) {
        output.WriteRawTag(56);
        output.WriteBool(OpenNow);
      }
      if (MinRating != 0D) {
        output.WriteRawTag(73);
        output.WriteDouble(MinRating);
      }
      if (MaxResultCount != 0) {
        output.WriteRawTag(80);
        output.WriteInt32(MaxResultCount);
      }
      priceLevels_.WriteTo(output, _repeated_priceLevels_codec);
      if (StrictTypeFiltering != false) {
        output.WriteRawTag(96);
        output.WriteBool(StrictTypeFiltering);
      }
      if (locationBias_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(LocationBias);
      }
      if (locationRestriction_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(LocationRestriction);
      }
      if (evOptions_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(EvOptions);
      }
      if (routingParameters_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(RoutingParameters);
      }
      if (searchAlongRouteParameters_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(SearchAlongRouteParameters);
      }
      if (IncludePureServiceAreaBusinesses != false) {
        output.WriteRawTag(160, 1);
        output.WriteBool(IncludePureServiceAreaBusinesses);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (TextQuery.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(TextQuery);
      }
      if (LanguageCode.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(LanguageCode);
      }
      if (RegionCode.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(RegionCode);
      }
      if (RankPreference != global::Google.Maps.Places.V1.SearchTextRequest.Types.RankPreference.Unspecified) {
        output.WriteRawTag(32);
        output.WriteEnum((int) RankPreference);
      }
      if (IncludedType.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(IncludedType);
      }
      if (OpenNow != false) {
        output.WriteRawTag(56);
        output.WriteBool(OpenNow);
      }
      if (MinRating != 0D) {
        output.WriteRawTag(73);
        output.WriteDouble(MinRating);
      }
      if (MaxResultCount != 0) {
        output.WriteRawTag(80);
        output.WriteInt32(MaxResultCount);
      }
      priceLevels_.WriteTo(ref output, _repeated_priceLevels_codec);
      if (StrictTypeFiltering != false) {
        output.WriteRawTag(96);
        output.WriteBool(StrictTypeFiltering);
      }
      if (locationBias_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(LocationBias);
      }
      if (locationRestriction_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(LocationRestriction);
      }
      if (evOptions_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(EvOptions);
      }
      if (routingParameters_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(RoutingParameters);
      }
      if (searchAlongRouteParameters_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(SearchAlongRouteParameters);
      }
      if (IncludePureServiceAreaBusinesses != false) {
        output.WriteRawTag(160, 1);
        output.WriteBool(IncludePureServiceAreaBusinesses);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (TextQuery.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TextQuery);
      }
      if (LanguageCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LanguageCode);
      }
      if (RegionCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RegionCode);
      }
      if (RankPreference != global::Google.Maps.Places.V1.SearchTextRequest.Types.RankPreference.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RankPreference);
      }
      if (IncludedType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(IncludedType);
      }
      if (OpenNow != false) {
        size += 1 + 1;
      }
      if (MinRating != 0D) {
        size += 1 + 8;
      }
      if (MaxResultCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxResultCount);
      }
      size += priceLevels_.CalculateSize(_repeated_priceLevels_codec);
      if (StrictTypeFiltering != false) {
        size += 1 + 1;
      }
      if (locationBias_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocationBias);
      }
      if (locationRestriction_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocationRestriction);
      }
      if (evOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EvOptions);
      }
      if (routingParameters_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RoutingParameters);
      }
      if (searchAlongRouteParameters_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(SearchAlongRouteParameters);
      }
      if (IncludePureServiceAreaBusinesses != false) {
        size += 2 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SearchTextRequest other) {
      if (other == null) {
        return;
      }
      if (other.TextQuery.Length != 0) {
        TextQuery = other.TextQuery;
      }
      if (other.LanguageCode.Length != 0) {
        LanguageCode = other.LanguageCode;
      }
      if (other.RegionCode.Length != 0) {
        RegionCode = other.RegionCode;
      }
      if (other.RankPreference != global::Google.Maps.Places.V1.SearchTextRequest.Types.RankPreference.Unspecified) {
        RankPreference = other.RankPreference;
      }
      if (other.IncludedType.Length != 0) {
        IncludedType = other.IncludedType;
      }
      if (other.OpenNow != false) {
        OpenNow = other.OpenNow;
      }
      if (other.MinRating != 0D) {
        MinRating = other.MinRating;
      }
      if (other.MaxResultCount != 0) {
        MaxResultCount = other.MaxResultCount;
      }
      priceLevels_.Add(other.priceLevels_);
      if (other.StrictTypeFiltering != false) {
        StrictTypeFiltering = other.StrictTypeFiltering;
      }
      if (other.locationBias_ != null) {
        if (locationBias_ == null) {
          LocationBias = new global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationBias();
        }
        LocationBias.MergeFrom(other.LocationBias);
      }
      if (other.locationRestriction_ != null) {
        if (locationRestriction_ == null) {
          LocationRestriction = new global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationRestriction();
        }
        LocationRestriction.MergeFrom(other.LocationRestriction);
      }
      if (other.evOptions_ != null) {
        if (evOptions_ == null) {
          EvOptions = new global::Google.Maps.Places.V1.SearchTextRequest.Types.EVOptions();
        }
        EvOptions.MergeFrom(other.EvOptions);
      }
      if (other.routingParameters_ != null) {
        if (routingParameters_ == null) {
          RoutingParameters = new global::Google.Maps.Places.V1.RoutingParameters();
        }
        RoutingParameters.MergeFrom(other.RoutingParameters);
      }
      if (other.searchAlongRouteParameters_ != null) {
        if (searchAlongRouteParameters_ == null) {
          SearchAlongRouteParameters = new global::Google.Maps.Places.V1.SearchTextRequest.Types.SearchAlongRouteParameters();
        }
        SearchAlongRouteParameters.MergeFrom(other.SearchAlongRouteParameters);
      }
      if (other.IncludePureServiceAreaBusinesses != false) {
        IncludePureServiceAreaBusinesses = other.IncludePureServiceAreaBusinesses;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            TextQuery = input.ReadString();
            break;
          }
          case 18: {
            LanguageCode = input.ReadString();
            break;
          }
          case 26: {
            RegionCode = input.ReadString();
            break;
          }
          case 32: {
            RankPreference = (global::Google.Maps.Places.V1.SearchTextRequest.Types.RankPreference) input.ReadEnum();
            break;
          }
          case 50: {
            IncludedType = input.ReadString();
            break;
          }
          case 56: {
            OpenNow = input.ReadBool();
            break;
          }
          case 73: {
            MinRating = input.ReadDouble();
            break;
          }
          case 80: {
            MaxResultCount = input.ReadInt32();
            break;
          }
          case 90:
          case 88: {
            priceLevels_.AddEntriesFrom(input, _repeated_priceLevels_codec);
            break;
          }
          case 96: {
            StrictTypeFiltering = input.ReadBool();
            break;
          }
          case 106: {
            if (locationBias_ == null) {
              LocationBias = new global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationBias();
            }
            input.ReadMessage(LocationBias);
            break;
          }
          case 114: {
            if (locationRestriction_ == null) {
              LocationRestriction = new global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationRestriction();
            }
            input.ReadMessage(LocationRestriction);
            break;
          }
          case 122: {
            if (evOptions_ == null) {
              EvOptions = new global::Google.Maps.Places.V1.SearchTextRequest.Types.EVOptions();
            }
            input.ReadMessage(EvOptions);
            break;
          }
          case 130: {
            if (routingParameters_ == null) {
              RoutingParameters = new global::Google.Maps.Places.V1.RoutingParameters();
            }
            input.ReadMessage(RoutingParameters);
            break;
          }
          case 138: {
            if (searchAlongRouteParameters_ == null) {
              SearchAlongRouteParameters = new global::Google.Maps.Places.V1.SearchTextRequest.Types.SearchAlongRouteParameters();
            }
            input.ReadMessage(SearchAlongRouteParameters);
            break;
          }
          case 160: {
            IncludePureServiceAreaBusinesses = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            TextQuery = input.ReadString();
            break;
          }
          case 18: {
            LanguageCode = input.ReadString();
            break;
          }
          case 26: {
            RegionCode = input.ReadString();
            break;
          }
          case 32: {
            RankPreference = (global::Google.Maps.Places.V1.SearchTextRequest.Types.RankPreference) input.ReadEnum();
            break;
          }
          case 50: {
            IncludedType = input.ReadString();
            break;
          }
          case 56: {
            OpenNow = input.ReadBool();
            break;
          }
          case 73: {
            MinRating = input.ReadDouble();
            break;
          }
          case 80: {
            MaxResultCount = input.ReadInt32();
            break;
          }
          case 90:
          case 88: {
            priceLevels_.AddEntriesFrom(ref input, _repeated_priceLevels_codec);
            break;
          }
          case 96: {
            StrictTypeFiltering = input.ReadBool();
            break;
          }
          case 106: {
            if (locationBias_ == null) {
              LocationBias = new global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationBias();
            }
            input.ReadMessage(LocationBias);
            break;
          }
          case 114: {
            if (locationRestriction_ == null) {
              LocationRestriction = new global::Google.Maps.Places.V1.SearchTextRequest.Types.LocationRestriction();
            }
            input.ReadMessage(LocationRestriction);
            break;
          }
          case 122: {
            if (evOptions_ == null) {
              EvOptions = new global::Google.Maps.Places.V1.SearchTextRequest.Types.EVOptions();
            }
            input.ReadMessage(EvOptions);
            break;
          }
          case 130: {
            if (routingParameters_ == null) {
              RoutingParameters = new global::Google.Maps.Places.V1.RoutingParameters();
            }
            input.ReadMessage(RoutingParameters);
            break;
          }
          case 138: {
            if (searchAlongRouteParameters_ == null) {
              SearchAlongRouteParameters = new global::Google.Maps.Places.V1.SearchTextRequest.Types.SearchAlongRouteParameters();
            }
            input.ReadMessage(SearchAlongRouteParameters);
            break;
          }
          case 160: {
            IncludePureServiceAreaBusinesses = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the SearchTextRequest message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// How results will be ranked in the response.
      /// </summary>
      public enum RankPreference {
        /// <summary>
        /// For a categorical query such as "Restaurants in New York City", RELEVANCE
        /// is the default. For non-categorical queries such as "Mountain View, CA"
        /// we recommend that you leave rankPreference unset.
        /// </summary>
        [pbr::OriginalName("RANK_PREFERENCE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Ranks results by distance.
        /// </summary>
        [pbr::OriginalName("DISTANCE")] Distance = 1,
        /// <summary>
        /// Ranks results by relevance. Sort order determined by normal ranking
        /// stack.
        /// </summary>
        [pbr::OriginalName("RELEVANCE")] Relevance = 2,
      }

      /// <summary>
      /// The region to search. This location serves as a bias which means results
      /// around given location might be returned.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class LocationBias : pb::IMessage<LocationBias>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<LocationBias> _parser = new pb::MessageParser<LocationBias>(() => new LocationBias());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<LocationBias> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.Places.V1.SearchTextRequest.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocationBias() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocationBias(LocationBias other) : this() {
          switch (other.TypeCase) {
            case TypeOneofCase.Rectangle:
              Rectangle = other.Rectangle.Clone();
              break;
            case TypeOneofCase.Circle:
              Circle = other.Circle.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocationBias Clone() {
          return new LocationBias(this);
        }

        /// <summary>Field number for the "rectangle" field.</summary>
        public const int RectangleFieldNumber = 1;
        /// <summary>
        /// A rectangle box defined by northeast and southwest corner.
        /// `rectangle.high()` must be the northeast point of the rectangle
        /// viewport. `rectangle.low()` must be the southwest point of the
        /// rectangle viewport. `rectangle.low().latitude()` cannot be greater than
        /// `rectangle.high().latitude()`. This will result in an empty latitude
        /// range. A rectangle viewport cannot be wider than 180 degrees.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Geo.Type.Viewport Rectangle {
          get { return typeCase_ == TypeOneofCase.Rectangle ? (global::Google.Geo.Type.Viewport) type_ : null; }
          set {
            type_ = value;
            typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Rectangle;
          }
        }

        /// <summary>Field number for the "circle" field.</summary>
        public const int CircleFieldNumber = 2;
        /// <summary>
        /// A circle defined by center point and radius.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Maps.Places.V1.Circle Circle {
          get { return typeCase_ == TypeOneofCase.Circle ? (global::Google.Maps.Places.V1.Circle) type_ : null; }
          set {
            type_ = value;
            typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Circle;
          }
        }

        private object type_;
        /// <summary>Enum of possible cases for the "type" oneof.</summary>
        public enum TypeOneofCase {
          None = 0,
          Rectangle = 1,
          Circle = 2,
        }
        private TypeOneofCase typeCase_ = TypeOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TypeOneofCase TypeCase {
          get { return typeCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearType() {
          typeCase_ = TypeOneofCase.None;
          type_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as LocationBias);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(LocationBias other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Rectangle, other.Rectangle)) return false;
          if (!object.Equals(Circle, other.Circle)) return false;
          if (TypeCase != other.TypeCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (typeCase_ == TypeOneofCase.Rectangle) hash ^= Rectangle.GetHashCode();
          if (typeCase_ == TypeOneofCase.Circle) hash ^= Circle.GetHashCode();
          hash ^= (int) typeCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (typeCase_ == TypeOneofCase.Rectangle) {
            output.WriteRawTag(10);
            output.WriteMessage(Rectangle);
          }
          if (typeCase_ == TypeOneofCase.Circle) {
            output.WriteRawTag(18);
            output.WriteMessage(Circle);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (typeCase_ == TypeOneofCase.Rectangle) {
            output.WriteRawTag(10);
            output.WriteMessage(Rectangle);
          }
          if (typeCase_ == TypeOneofCase.Circle) {
            output.WriteRawTag(18);
            output.WriteMessage(Circle);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (typeCase_ == TypeOneofCase.Rectangle) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Rectangle);
          }
          if (typeCase_ == TypeOneofCase.Circle) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Circle);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(LocationBias other) {
          if (other == null) {
            return;
          }
          switch (other.TypeCase) {
            case TypeOneofCase.Rectangle:
              if (Rectangle == null) {
                Rectangle = new global::Google.Geo.Type.Viewport();
              }
              Rectangle.MergeFrom(other.Rectangle);
              break;
            case TypeOneofCase.Circle:
              if (Circle == null) {
                Circle = new global::Google.Maps.Places.V1.Circle();
              }
              Circle.MergeFrom(other.Circle);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Google.Geo.Type.Viewport subBuilder = new global::Google.Geo.Type.Viewport();
                if (typeCase_ == TypeOneofCase.Rectangle) {
                  subBuilder.MergeFrom(Rectangle);
                }
                input.ReadMessage(subBuilder);
                Rectangle = subBuilder;
                break;
              }
              case 18: {
                global::Google.Maps.Places.V1.Circle subBuilder = new global::Google.Maps.Places.V1.Circle();
                if (typeCase_ == TypeOneofCase.Circle) {
                  subBuilder.MergeFrom(Circle);
                }
                input.ReadMessage(subBuilder);
                Circle = subBuilder;
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                global::Google.Geo.Type.Viewport subBuilder = new global::Google.Geo.Type.Viewport();
                if (typeCase_ == TypeOneofCase.Rectangle) {
                  subBuilder.MergeFrom(Rectangle);
                }
                input.ReadMessage(subBuilder);
                Rectangle = subBuilder;
                break;
              }
              case 18: {
                global::Google.Maps.Places.V1.Circle subBuilder = new global::Google.Maps.Places.V1.Circle();
                if (typeCase_ == TypeOneofCase.Circle) {
                  subBuilder.MergeFrom(Circle);
                }
                input.ReadMessage(subBuilder);
                Circle = subBuilder;
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// The region to search. This location serves as a restriction which means
      /// results outside given location will not be returned.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class LocationRestriction : pb::IMessage<LocationRestriction>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<LocationRestriction> _parser = new pb::MessageParser<LocationRestriction>(() => new LocationRestriction());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<LocationRestriction> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.Places.V1.SearchTextRequest.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocationRestriction() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocationRestriction(LocationRestriction other) : this() {
          switch (other.TypeCase) {
            case TypeOneofCase.Rectangle:
              Rectangle = other.Rectangle.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocationRestriction Clone() {
          return new LocationRestriction(this);
        }

        /// <summary>Field number for the "rectangle" field.</summary>
        public const int RectangleFieldNumber = 1;
        /// <summary>
        /// A rectangle box defined by northeast and southwest corner.
        /// `rectangle.high()` must be the northeast point of the rectangle
        /// viewport. `rectangle.low()` must be the southwest point of the
        /// rectangle viewport. `rectangle.low().latitude()` cannot be greater than
        /// `rectangle.high().latitude()`. This will result in an empty latitude
        /// range. A rectangle viewport cannot be wider than 180 degrees.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Geo.Type.Viewport Rectangle {
          get { return typeCase_ == TypeOneofCase.Rectangle ? (global::Google.Geo.Type.Viewport) type_ : null; }
          set {
            type_ = value;
            typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Rectangle;
          }
        }

        private object type_;
        /// <summary>Enum of possible cases for the "type" oneof.</summary>
        public enum TypeOneofCase {
          None = 0,
          Rectangle = 1,
        }
        private TypeOneofCase typeCase_ = TypeOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TypeOneofCase TypeCase {
          get { return typeCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearType() {
          typeCase_ = TypeOneofCase.None;
          type_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as LocationRestriction);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(LocationRestriction other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Rectangle, other.Rectangle)) return false;
          if (TypeCase != other.TypeCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (typeCase_ == TypeOneofCase.Rectangle) hash ^= Rectangle.GetHashCode();
          hash ^= (int) typeCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (typeCase_ == TypeOneofCase.Rectangle) {
            output.WriteRawTag(10);
            output.WriteMessage(Rectangle);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (typeCase_ == TypeOneofCase.Rectangle) {
            output.WriteRawTag(10);
            output.WriteMessage(Rectangle);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (typeCase_ == TypeOneofCase.Rectangle) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Rectangle);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(LocationRestriction other) {
          if (other == null) {
            return;
          }
          switch (other.TypeCase) {
            case TypeOneofCase.Rectangle:
              if (Rectangle == null) {
                Rectangle = new global::Google.Geo.Type.Viewport();
              }
              Rectangle.MergeFrom(other.Rectangle);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Google.Geo.Type.Viewport subBuilder = new global::Google.Geo.Type.Viewport();
                if (typeCase_ == TypeOneofCase.Rectangle) {
                  subBuilder.MergeFrom(Rectangle);
                }
                input.ReadMessage(subBuilder);
                Rectangle = subBuilder;
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                global::Google.Geo.Type.Viewport subBuilder = new global::Google.Geo.Type.Viewport();
                if (typeCase_ == TypeOneofCase.Rectangle) {
                  subBuilder.MergeFrom(Rectangle);
                }
                input.ReadMessage(subBuilder);
                Rectangle = subBuilder;
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Searchable EV options of a place search request.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class EVOptions : pb::IMessage<EVOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<EVOptions> _parser = new pb::MessageParser<EVOptions>(() => new EVOptions());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<EVOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.Places.V1.SearchTextRequest.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public EVOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public EVOptions(EVOptions other) : this() {
          minimumChargingRateKw_ = other.minimumChargingRateKw_;
          connectorTypes_ = other.connectorTypes_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public EVOptions Clone() {
          return new EVOptions(this);
        }

        /// <summary>Field number for the "minimum_charging_rate_kw" field.</summary>
        public const int MinimumChargingRateKwFieldNumber = 1;
        private double minimumChargingRateKw_;
        /// <summary>
        /// Optional. Minimum required charging rate in kilowatts. A place with a
        /// charging rate less than the specified rate is filtered out.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public double MinimumChargingRateKw {
          get { return minimumChargingRateKw_; }
          set {
            minimumChargingRateKw_ = value;
          }
        }

        /// <summary>Field number for the "connector_types" field.</summary>
        public const int ConnectorTypesFieldNumber = 2;
        private static readonly pb::FieldCodec<global::Google.Maps.Places.V1.EVConnectorType> _repeated_connectorTypes_codec
            = pb::FieldCodec.ForEnum(18, x => (int) x, x => (global::Google.Maps.Places.V1.EVConnectorType) x);
        private readonly pbc::RepeatedField<global::Google.Maps.Places.V1.EVConnectorType> connectorTypes_ = new pbc::RepeatedField<global::Google.Maps.Places.V1.EVConnectorType>();
        /// <summary>
        /// Optional. The list of preferred EV connector types. A place that does not
        /// support any of the listed connector types is filtered out.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Google.Maps.Places.V1.EVConnectorType> ConnectorTypes {
          get { return connectorTypes_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as EVOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(EVOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(MinimumChargingRateKw, other.MinimumChargingRateKw)) return false;
          if(!connectorTypes_.Equals(other.connectorTypes_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (MinimumChargingRateKw != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(MinimumChargingRateKw);
          hash ^= connectorTypes_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (MinimumChargingRateKw != 0D) {
            output.WriteRawTag(9);
            output.WriteDouble(MinimumChargingRateKw);
          }
          connectorTypes_.WriteTo(output, _repeated_connectorTypes_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (MinimumChargingRateKw != 0D) {
            output.WriteRawTag(9);
            output.WriteDouble(MinimumChargingRateKw);
          }
          connectorTypes_.WriteTo(ref output, _repeated_connectorTypes_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (MinimumChargingRateKw != 0D) {
            size += 1 + 8;
          }
          size += connectorTypes_.CalculateSize(_repeated_connectorTypes_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(EVOptions other) {
          if (other == null) {
            return;
          }
          if (other.MinimumChargingRateKw != 0D) {
            MinimumChargingRateKw = other.MinimumChargingRateKw;
          }
          connectorTypes_.Add(other.connectorTypes_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 9: {
                MinimumChargingRateKw = input.ReadDouble();
                break;
              }
              case 18:
              case 16: {
                connectorTypes_.AddEntriesFrom(input, _repeated_connectorTypes_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 9: {
                MinimumChargingRateKw = input.ReadDouble();
                break;
              }
              case 18:
              case 16: {
                connectorTypes_.AddEntriesFrom(ref input, _repeated_connectorTypes_codec);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Specifies a precalculated polyline from the [Routes
      /// API](https://developers.google.com/maps/documentation/routes) defining the
      /// route to search. Searching along a route is similar to using the
      /// `locationBias` or `locationRestriction` request option to bias the search
      /// results. However, while the `locationBias` and `locationRestriction`
      /// options let you specify a region to bias the search results, this option
      /// lets you bias the results along a trip route.
      ///
      /// Results are not guaranteed to be along the route provided, but rather are
      /// ranked within the search area defined by the polyline and, optionally, by
      /// the `locationBias` or `locationRestriction` based on minimal detour times
      /// from origin to destination. The results might be along an alternate route,
      /// especially if the provided polyline does not define an optimal route from
      /// origin to destination.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class SearchAlongRouteParameters : pb::IMessage<SearchAlongRouteParameters>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<SearchAlongRouteParameters> _parser = new pb::MessageParser<SearchAlongRouteParameters>(() => new SearchAlongRouteParameters());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<SearchAlongRouteParameters> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.Places.V1.SearchTextRequest.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SearchAlongRouteParameters() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SearchAlongRouteParameters(SearchAlongRouteParameters other) : this() {
          polyline_ = other.polyline_ != null ? other.polyline_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SearchAlongRouteParameters Clone() {
          return new SearchAlongRouteParameters(this);
        }

        /// <summary>Field number for the "polyline" field.</summary>
        public const int PolylineFieldNumber = 1;
        private global::Google.Maps.Places.V1.Polyline polyline_;
        /// <summary>
        /// Required. The route polyline.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Maps.Places.V1.Polyline Polyline {
          get { return polyline_; }
          set {
            polyline_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as SearchAlongRouteParameters);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(SearchAlongRouteParameters other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Polyline, other.Polyline)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (polyline_ != null) hash ^= Polyline.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (polyline_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(Polyline);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (polyline_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(Polyline);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (polyline_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Polyline);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(SearchAlongRouteParameters other) {
          if (other == null) {
            return;
          }
          if (other.polyline_ != null) {
            if (polyline_ == null) {
              Polyline = new global::Google.Maps.Places.V1.Polyline();
            }
            Polyline.MergeFrom(other.Polyline);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (polyline_ == null) {
                  Polyline = new global::Google.Maps.Places.V1.Polyline();
                }
                input.ReadMessage(Polyline);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (polyline_ == null) {
                  Polyline = new global::Google.Maps.Places.V1.Polyline();
                }
                input.ReadMessage(Polyline);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Response proto for SearchText.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SearchTextResponse : pb::IMessage<SearchTextResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SearchTextResponse> _parser = new pb::MessageParser<SearchTextResponse>(() => new SearchTextResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SearchTextResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.Places.V1.PlacesServiceReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchTextResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchTextResponse(SearchTextResponse other) : this() {
      places_ = other.places_.Clone();
      routingSummaries_ = other.routingSummaries_.Clone();
      contextualContents_ = other.contextualContents_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchTextResponse Clone() {
      return new SearchTextResponse(this);
    }

    /// <summary>Field number for the "places" field.</summary>
    public const int PlacesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Maps.Places.V1.Place> _repeated_places_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Maps.Places.V1.Place.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.Places.V1.Place> places_ = new pbc::RepeatedField<global::Google.Maps.Places.V1.Place>();
    /// <summary>
    /// A list of places that meet the user's text search criteria.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.Places.V1.Place> Places {
      get { return places_; }
    }

    /// <summary>Field number for the "routing_summaries" field.</summary>
    public const int RoutingSummariesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Google.Maps.Places.V1.RoutingSummary> _repeated_routingSummaries_codec
        = pb::FieldCodec.ForMessage(18, global::Google.Maps.Places.V1.RoutingSummary.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.Places.V1.RoutingSummary> routingSummaries_ = new pbc::RepeatedField<global::Google.Maps.Places.V1.RoutingSummary>();
    /// <summary>
    /// A list of routing summaries where each entry associates to the
    /// corresponding place in the same index in the `places` field. If the routing
    /// summary is not available for one of the places, it will contain an empty
    /// entry. This list will have as many entries as the list of places if
    /// requested.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.Places.V1.RoutingSummary> RoutingSummaries {
      get { return routingSummaries_; }
    }

    /// <summary>Field number for the "contextual_contents" field.</summary>
    public const int ContextualContentsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Google.Maps.Places.V1.ContextualContent> _repeated_contextualContents_codec
        = pb::FieldCodec.ForMessage(26, global::Google.Maps.Places.V1.ContextualContent.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.Places.V1.ContextualContent> contextualContents_ = new pbc::RepeatedField<global::Google.Maps.Places.V1.ContextualContent>();
    /// <summary>
    /// Experimental: See
    /// https://developers.google.com/maps/documentation/places/web-service/experimental/places-generative
    /// for more details.
    ///
    /// A list of contextual contents where each entry associates to the
    /// corresponding place in the same index in the places field. The contents
    /// that are relevant to the `text_query` in the request are preferred. If the
    /// contextual content is not available for one of the places, it will return
    /// non-contextual content. It will be empty only when the content is
    /// unavailable for this place. This list will have as many entries as the
    /// list of places if requested.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.Places.V1.ContextualContent> ContextualContents {
      get { return contextualContents_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SearchTextResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SearchTextResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!places_.Equals(other.places_)) return false;
      if(!routingSummaries_.Equals(other.routingSummaries_)) return false;
      if(!contextualContents_.Equals(other.contextualContents_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= places_.GetHashCode();
      hash ^= routingSummaries_.GetHashCode();
      hash ^= contextualContents_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      places_.WriteTo(output, _repeated_places_codec);
      routingSummaries_.WriteTo(output, _repeated_routingSummaries_codec);
      contextualContents_.WriteTo(output, _repeated_contextualContents_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      places_.WriteTo(ref output, _repeated_places_codec);
      routingSummaries_.WriteTo(ref output, _repeated_routingSummaries_codec);
      contextualContents_.WriteTo(ref output, _repeated_contextualContents_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += places_.CalculateSize(_repeated_places_codec);
      size += routingSummaries_.CalculateSize(_repeated_routingSummaries_codec);
      size += contextualContents_.CalculateSize(_repeated_contextualContents_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SearchTextResponse other) {
      if (other == null) {
        return;
      }
      places_.Add(other.places_);
      routingSummaries_.Add(other.routingSummaries_);
      contextualContents_.Add(other.contextualContents_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            places_.AddEntriesFrom(input, _repeated_places_codec);
            break;
          }
          case 18: {
            routingSummaries_.AddEntriesFrom(input, _repeated_routingSummaries_codec);
            break;
          }
          case 26: {
            contextualContents_.AddEntriesFrom(input, _repeated_contextualContents_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            places_.AddEntriesFrom(ref input, _repeated_places_codec);
            break;
          }
          case 18: {
            routingSummaries_.AddEntriesFrom(ref input, _repeated_routingSummaries_codec);
            break;
          }
          case 26: {
            contextualContents_.AddEntriesFrom(ref input, _repeated_contextualContents_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Request for fetching a photo of a place using a photo resource name.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class GetPhotoMediaRequest : pb::IMessage<GetPhotoMediaRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GetPhotoMediaRequest> _parser = new pb::MessageParser<GetPhotoMediaRequest>(() => new GetPhotoMediaRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<GetPhotoMediaRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.Places.V1.PlacesServiceReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GetPhotoMediaRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GetPhotoMediaRequest(GetPhotoMediaRequest other) : this() {
      name_ = other.name_;
      maxWidthPx_ = other.maxWidthPx_;
      maxHeightPx_ = other.maxHeightPx_;
      skipHttpRedirect_ = other.skipHttpRedirect_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GetPhotoMediaRequest Clone() {
      return new GetPhotoMediaRequest(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Required. The resource name of a photo media in the format:
    /// `places/{place_id}/photos/{photo_reference}/media`.
    ///
    /// The resource name of a photo as returned in a Place object's `photos.name`
    /// field comes with the format
    /// `places/{place_id}/photos/{photo_reference}`. You need to append `/media`
    /// at the end of the photo resource to get the photo media resource name.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "max_width_px" field.</summary>
    public const int MaxWidthPxFieldNumber = 2;
    private int maxWidthPx_;
    /// <summary>
    /// Optional. Specifies the maximum desired width, in pixels, of the image. If
    /// the image is smaller than the values specified, the original image will be
    /// returned. If the image is larger in either dimension, it will be scaled to
    /// match the smaller of the two dimensions, restricted to its original aspect
    /// ratio. Both the max_height_px and max_width_px properties accept an integer
    /// between 1 and 4800, inclusively. If the value is not within the allowed
    /// range, an INVALID_ARGUMENT error will be returned.
    ///
    /// At least one of max_height_px or max_width_px needs to be specified. If
    /// neither max_height_px nor max_width_px is specified, an INVALID_ARGUMENT
    /// error will be returned.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MaxWidthPx {
      get { return maxWidthPx_; }
      set {
        maxWidthPx_ = value;
      }
    }

    /// <summary>Field number for the "max_height_px" field.</summary>
    public const int MaxHeightPxFieldNumber = 3;
    private int maxHeightPx_;
    /// <summary>
    /// Optional. Specifies the maximum desired height, in pixels, of the image. If
    /// the image is smaller than the values specified, the original image will be
    /// returned. If the image is larger in either dimension, it will be scaled to
    /// match the smaller of the two dimensions, restricted to its original aspect
    /// ratio. Both the max_height_px and max_width_px properties accept an integer
    /// between 1 and 4800, inclusively. If the value is not within the allowed
    /// range, an INVALID_ARGUMENT error will be returned.
    ///
    /// At least one of max_height_px or max_width_px needs to be specified. If
    /// neither max_height_px nor max_width_px is specified, an INVALID_ARGUMENT
    /// error will be returned.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MaxHeightPx {
      get { return maxHeightPx_; }
      set {
        maxHeightPx_ = value;
      }
    }

    /// <summary>Field number for the "skip_http_redirect" field.</summary>
    public const int SkipHttpRedirectFieldNumber = 4;
    private bool skipHttpRedirect_;
    /// <summary>
    /// Optional. If set, skip the default HTTP redirect behavior and render a text
    /// format (for example, in JSON format for HTTP use case) response. If not
    /// set, an HTTP redirect will be issued to redirect the call to the image
    /// media. This option is ignored for non-HTTP requests.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool SkipHttpRedirect {
      get { return skipHttpRedirect_; }
      set {
        skipHttpRedirect_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as GetPhotoMediaRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(GetPhotoMediaRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (MaxWidthPx != other.MaxWidthPx) return false;
      if (MaxHeightPx != other.MaxHeightPx) return false;
      if (SkipHttpRedirect != other.SkipHttpRedirect) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (MaxWidthPx != 0) hash ^= MaxWidthPx.GetHashCode();
      if (MaxHeightPx != 0) hash ^= MaxHeightPx.GetHashCode();
      if (SkipHttpRedirect != false) hash ^= SkipHttpRedirect.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (MaxWidthPx != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(MaxWidthPx);
      }
      if (MaxHeightPx != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(MaxHeightPx);
      }
      if (SkipHttpRedirect != false) {
        output.WriteRawTag(32);
        output.WriteBool(SkipHttpRedirect);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (MaxWidthPx != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(MaxWidthPx);
      }
      if (MaxHeightPx != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(MaxHeightPx);
      }
      if (SkipHttpRedirect != false) {
        output.WriteRawTag(32);
        output.WriteBool(SkipHttpRedirect);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (MaxWidthPx != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxWidthPx);
      }
      if (MaxHeightPx != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxHeightPx);
      }
      if (SkipHttpRedirect != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(GetPhotoMediaRequest other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.MaxWidthPx != 0) {
        MaxWidthPx = other.MaxWidthPx;
      }
      if (other.MaxHeightPx != 0) {
        MaxHeightPx = other.MaxHeightPx;
      }
      if (other.SkipHttpRedirect != false) {
        SkipHttpRedirect = other.SkipHttpRedirect;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            MaxWidthPx = input.ReadInt32();
            break;
          }
          case 24: {
            MaxHeightPx = input.ReadInt32();
            break;
          }
          case 32: {
            SkipHttpRedirect = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            MaxWidthPx = input.ReadInt32();
            break;
          }
          case 24: {
            MaxHeightPx = input.ReadInt32();
            break;
          }
          case 32: {
            SkipHttpRedirect = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A photo media from Places API.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class PhotoMedia : pb::IMessage<PhotoMedia>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PhotoMedia> _parser = new pb::MessageParser<PhotoMedia>(() => new PhotoMedia());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PhotoMedia> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.Places.V1.PlacesServiceReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PhotoMedia() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PhotoMedia(PhotoMedia other) : this() {
      name_ = other.name_;
      photoUri_ = other.photoUri_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PhotoMedia Clone() {
      return new PhotoMedia(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The resource name of a photo media in the format:
    /// `places/{place_id}/photos/{photo_reference}/media`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "photo_uri" field.</summary>
    public const int PhotoUriFieldNumber = 2;
    private string photoUri_ = "";
    /// <summary>
    /// A short-lived uri that can be used to render the photo.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string PhotoUri {
      get { return photoUri_; }
      set {
        photoUri_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PhotoMedia);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PhotoMedia other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (PhotoUri != other.PhotoUri) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (PhotoUri.Length != 0) hash ^= PhotoUri.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (PhotoUri.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(PhotoUri);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (PhotoUri.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(PhotoUri);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (PhotoUri.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PhotoUri);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PhotoMedia other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.PhotoUri.Length != 0) {
        PhotoUri = other.PhotoUri;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            PhotoUri = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            PhotoUri = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Request for fetching a Place based on its resource name, which is a string in
  /// the `places/{place_id}` format.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class GetPlaceRequest : pb::IMessage<GetPlaceRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GetPlaceRequest> _parser = new pb::MessageParser<GetPlaceRequest>(() => new GetPlaceRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<GetPlaceRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.Places.V1.PlacesServiceReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GetPlaceRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GetPlaceRequest(GetPlaceRequest other) : this() {
      name_ = other.name_;
      languageCode_ = other.languageCode_;
      regionCode_ = other.regionCode_;
      sessionToken_ = other.sessionToken_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GetPlaceRequest Clone() {
      return new GetPlaceRequest(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Required. The resource name of a place, in the `places/{place_id}` format.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "language_code" field.</summary>
    public const int LanguageCodeFieldNumber = 2;
    private string languageCode_ = "";
    /// <summary>
    /// Optional. Place details will be displayed with the preferred language if
    /// available.
    ///
    /// Current list of supported languages:
    /// https://developers.google.com/maps/faq#languagesupport.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string LanguageCode {
      get { return languageCode_; }
      set {
        languageCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "region_code" field.</summary>
    public const int RegionCodeFieldNumber = 3;
    private string regionCode_ = "";
    /// <summary>
    /// Optional. The Unicode country/region code (CLDR) of the location where the
    /// request is coming from. This parameter is used to display the place
    /// details, like region-specific place name, if available. The parameter can
    /// affect results based on applicable law.
    /// For more information, see
    /// https://www.unicode.org/cldr/charts/latest/supplemental/territory_language_information.html.
    ///
    /// Note that 3-digit region codes are not currently supported.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RegionCode {
      get { return regionCode_; }
      set {
        regionCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "session_token" field.</summary>
    public const int SessionTokenFieldNumber = 4;
    private string sessionToken_ = "";
    /// <summary>
    /// Optional. A string which identifies an Autocomplete session for billing
    /// purposes. Must be a URL and filename safe base64 string with at most 36
    /// ASCII characters in length. Otherwise an INVALID_ARGUMENT error is
    /// returned.
    ///
    /// The session begins when the user starts typing a query, and concludes when
    /// they select a place and a call to Place Details or Address Validation is
    /// made. Each session can have multiple queries, followed by one Place Details
    /// or Address Validation request. The credentials used for each request within
    /// a session must belong to the same Google Cloud Console project. Once a
    /// session has concluded, the token is no longer valid; your app must generate
    /// a fresh token for each session. If the `session_token` parameter is
    /// omitted, or if you reuse a session token, the session is charged as if no
    /// session token was provided (each request is billed separately).
    ///
    /// We recommend the following guidelines:
    ///
    /// * Use session tokens for all Place Autocomplete calls.
    /// * Generate a fresh token for each session. Using a version 4 UUID is
    ///   recommended.
    /// * Ensure that the credentials used for all Place Autocomplete, Place
    ///   Details, and Address Validation requests within a session belong to the
    ///   same Cloud Console project.
    /// * Be sure to pass a unique session token for each new session. Using the
    ///   same token for more than one session will result in each request being
    ///   billed individually.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SessionToken {
      get { return sessionToken_; }
      set {
        sessionToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as GetPlaceRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(GetPlaceRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (LanguageCode != other.LanguageCode) return false;
      if (RegionCode != other.RegionCode) return false;
      if (SessionToken != other.SessionToken) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (LanguageCode.Length != 0) hash ^= LanguageCode.GetHashCode();
      if (RegionCode.Length != 0) hash ^= RegionCode.GetHashCode();
      if (SessionToken.Length != 0) hash ^= SessionToken.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (LanguageCode.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(LanguageCode);
      }
      if (RegionCode.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(RegionCode);
      }
      if (SessionToken.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(SessionToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (LanguageCode.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(LanguageCode);
      }
      if (RegionCode.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(RegionCode);
      }
      if (SessionToken.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(SessionToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (LanguageCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LanguageCode);
      }
      if (RegionCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RegionCode);
      }
      if (SessionToken.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SessionToken);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(GetPlaceRequest other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.LanguageCode.Length != 0) {
        LanguageCode = other.LanguageCode;
      }
      if (other.RegionCode.Length != 0) {
        RegionCode = other.RegionCode;
      }
      if (other.SessionToken.Length != 0) {
        SessionToken = other.SessionToken;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            LanguageCode = input.ReadString();
            break;
          }
          case 26: {
            RegionCode = input.ReadString();
            break;
          }
          case 34: {
            SessionToken = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            LanguageCode = input.ReadString();
            break;
          }
          case 26: {
            RegionCode = input.ReadString();
            break;
          }
          case 34: {
            SessionToken = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Request proto for AutocompletePlaces.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class AutocompletePlacesRequest : pb::IMessage<AutocompletePlacesRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AutocompletePlacesRequest> _parser = new pb::MessageParser<AutocompletePlacesRequest>(() => new AutocompletePlacesRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AutocompletePlacesRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.Places.V1.PlacesServiceReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AutocompletePlacesRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AutocompletePlacesRequest(AutocompletePlacesRequest other) : this() {
      input_ = other.input_;
      locationBias_ = other.locationBias_ != null ? other.locationBias_.Clone() : null;
      locationRestriction_ = other.locationRestriction_ != null ? other.locationRestriction_.Clone() : null;
      includedPrimaryTypes_ = other.includedPrimaryTypes_.Clone();
      includedRegionCodes_ = other.includedRegionCodes_.Clone();
      languageCode_ = other.languageCode_;
      regionCode_ = other.regionCode_;
      origin_ = other.origin_ != null ? other.origin_.Clone() : null;
      inputOffset_ = other.inputOffset_;
      includeQueryPredictions_ = other.includeQueryPredictions_;
      sessionToken_ = other.sessionToken_;
      includePureServiceAreaBusinesses_ = other.includePureServiceAreaBusinesses_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AutocompletePlacesRequest Clone() {
      return new AutocompletePlacesRequest(this);
    }

    /// <summary>Field number for the "input" field.</summary>
    public const int InputFieldNumber = 1;
    private string input_ = "";
    /// <summary>
    /// Required. The text string on which to search.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Input {
      get { return input_; }
      set {
        input_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "location_bias" field.</summary>
    public const int LocationBiasFieldNumber = 2;
    private global::Google.Maps.Places.V1.AutocompletePlacesRequest.Types.LocationBias locationBias_;
    /// <summary>
    /// Optional. Bias results to a specified location.
    ///
    /// At most one of `location_bias` or `location_restriction` should be set. If
    /// neither are set, the results will be biased by IP address, meaning the IP
    /// address will be mapped to an imprecise location and used as a biasing
    /// signal.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.Places.V1.AutocompletePlacesRequest.Types.LocationBias LocationBias {
      get { return locationBias_; }
      set {
        locationBias_ = value;
      }
    }

    /// <summary>Field number for the "location_restriction" field.</summary>
    public const int LocationRestrictionFieldNumber = 3;
    private global::Google.Maps.Places.V1.AutocompletePlacesRequest.Types.LocationRestriction locationRestriction_;
    /// <summary>
    /// Optional. Restrict results to a specified location.
    ///
    /// At most one of `location_bias` or `location_restriction` should be set. If
    /// neither are set, the results will be biased by IP address, meaning the IP
    /// address will be mapped to an imprecise location and used as a biasing
    /// signal.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.Places.V1.AutocompletePlacesRequest.Types.LocationRestriction LocationRestriction {
      get { return locationRestriction_; }
      set {
        locationRestriction_ = value;
      }
    }

    /// <summary>Field number for the "included_primary_types" field.</summary>
    public const int IncludedPrimaryTypesFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_includedPrimaryTypes_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> includedPrimaryTypes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Optional. Included primary Place type (for example, "restaurant" or
    /// "gas_station") in Place Types
    /// (https://developers.google.com/maps/documentation/places/web-service/place-types),
    /// or only `(regions)`, or only `(cities)`. A Place is only returned if its
    /// primary type is included in this list. Up to 5 values can be specified. If
    /// no types are specified, all Place types are returned.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> IncludedPrimaryTypes {
      get { return includedPrimaryTypes_; }
    }

    /// <summary>Field number for the "included_region_codes" field.</summary>
    public const int IncludedRegionCodesFieldNumber = 5;
    private static readonly pb::FieldCodec<string> _repeated_includedRegionCodes_codec
        = pb::FieldCodec.ForString(42);
    private readonly pbc::RepeatedField<string> includedRegionCodes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Optional. Only include results in the specified regions, specified as up to
    /// 15 CLDR two-character region codes. An empty set will not restrict the
    /// results. If both `location_restriction` and `included_region_codes` are
    /// set, the results will be located in the area of intersection.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> IncludedRegionCodes {
      get { return includedRegionCodes_; }
    }

    /// <summary>Field number for the "language_code" field.</summary>
    public const int LanguageCodeFieldNumber = 6;
    private string languageCode_ = "";
    /// <summary>
    /// Optional. The language in which to return results. Defaults to en-US. The
    /// results may be in mixed languages if the language used in `input` is
    /// different from `language_code` or if the returned Place does not have a
    /// translation from the local language to `language_code`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string LanguageCode {
      get { return languageCode_; }
      set {
        languageCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "region_code" field.</summary>
    public const int RegionCodeFieldNumber = 7;
    private string regionCode_ = "";
    /// <summary>
    /// Optional. The region code, specified as a CLDR two-character region code.
    /// This affects address formatting, result ranking, and may influence what
    /// results are returned. This does not restrict results to the specified
    /// region. To restrict results to a region, use `region_code_restriction`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RegionCode {
      get { return regionCode_; }
      set {
        regionCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "origin" field.</summary>
    public const int OriginFieldNumber = 8;
    private global::Google.Type.LatLng origin_;
    /// <summary>
    /// Optional. The origin point from which to calculate geodesic distance to the
    /// destination (returned as `distance_meters`). If this value is omitted,
    /// geodesic distance will not be returned.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Type.LatLng Origin {
      get { return origin_; }
      set {
        origin_ = value;
      }
    }

    /// <summary>Field number for the "input_offset" field.</summary>
    public const int InputOffsetFieldNumber = 9;
    private int inputOffset_;
    /// <summary>
    /// Optional. A zero-based Unicode character offset of `input` indicating the
    /// cursor position in `input`. The cursor position may influence what
    /// predictions are returned.
    ///
    /// If empty, defaults to the length of `input`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int InputOffset {
      get { return inputOffset_; }
      set {
        inputOffset_ = value;
      }
    }

    /// <summary>Field number for the "include_query_predictions" field.</summary>
    public const int IncludeQueryPredictionsFieldNumber = 10;
    private bool includeQueryPredictions_;
    /// <summary>
    /// Optional. If true, the response will include both Place and query
    /// predictions. Otherwise the response will only return Place predictions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IncludeQueryPredictions {
      get { return includeQueryPredictions_; }
      set {
        includeQueryPredictions_ = value;
      }
    }

    /// <summary>Field number for the "session_token" field.</summary>
    public const int SessionTokenFieldNumber = 11;
    private string sessionToken_ = "";
    /// <summary>
    /// Optional. A string which identifies an Autocomplete session for billing
    /// purposes. Must be a URL and filename safe base64 string with at most 36
    /// ASCII characters in length. Otherwise an INVALID_ARGUMENT error is
    /// returned.
    ///
    /// The session begins when the user starts typing a query, and concludes when
    /// they select a place and a call to Place Details or Address Validation is
    /// made. Each session can have multiple queries, followed by one Place Details
    /// or Address Validation request. The credentials used for each request within
    /// a session must belong to the same Google Cloud Console project. Once a
    /// session has concluded, the token is no longer valid; your app must generate
    /// a fresh token for each session. If the `session_token` parameter is
    /// omitted, or if you reuse a session token, the session is charged as if no
    /// session token was provided (each request is billed separately).
    ///
    /// We recommend the following guidelines:
    ///
    /// * Use session tokens for all Place Autocomplete calls.
    /// * Generate a fresh token for each session. Using a version 4 UUID is
    ///   recommended.
    /// * Ensure that the credentials used for all Place Autocomplete, Place
    ///   Details, and Address Validation requests within a session belong to the
    ///   same Cloud Console project.
    /// * Be sure to pass a unique session token for each new session. Using the
    ///   same token for more than one session will result in each request being
    ///   billed individually.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SessionToken {
      get { return sessionToken_; }
      set {
        sessionToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "include_pure_service_area_businesses" field.</summary>
    public const int IncludePureServiceAreaBusinessesFieldNumber = 12;
    private bool includePureServiceAreaBusinesses_;
    /// <summary>
    /// Optional. Include pure service area businesses if the field is set to true.
    /// Pure service area business is a business that visits or delivers to
    /// customers directly but does not serve customers at their business address.
    /// For example, businesses like cleaning services or plumbers. Those
    /// businesses do not have a physical address or location on Google Maps.
    /// Places will not return fields including `location`, `plus_code`, and other
    /// location related fields for these businesses.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IncludePureServiceAreaBusinesses {
      get { return includePureServiceAreaBusinesses_; }
      set {
        includePureServiceAreaBusinesses_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AutocompletePlacesRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AutocompletePlacesRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Input != other.Input) return false;
      if (!object.Equals(LocationBias, other.LocationBias)) return false;
      if (!object.Equals(LocationRestriction, other.LocationRestriction)) return false;
      if(!includedPrimaryTypes_.Equals(other.includedPrimaryTypes_)) return false;
      if(!includedRegionCodes_.Equals(other.includedRegionCodes_)) return false;
      if (LanguageCode != other.LanguageCode) return false;
      if (RegionCode != other.RegionCode) return false;
      if (!object.Equals(Origin, other.Origin)) return false;
      if (InputOffset != other.InputOffset) return false;
      if (IncludeQueryPredictions != other.IncludeQueryPredictions) return false;
      if (SessionToken != other.SessionToken) return false;
      if (IncludePureServiceAreaBusinesses != other.IncludePureServiceAreaBusinesses) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Input.Length != 0) hash ^= Input.GetHashCode();
      if (locationBias_ != null) hash ^= LocationBias.GetHashCode();
      if (locationRestriction_ != null) hash ^= LocationRestriction.GetHashCode();
      hash ^= includedPrimaryTypes_.GetHashCode();
      hash ^= includedRegionCodes_.GetHashCode();
      if (LanguageCode.Length != 0) hash ^= LanguageCode.GetHashCode();
      if (RegionCode.Length != 0) hash ^= RegionCode.GetHashCode();
      if (origin_ != null) hash ^= Origin.GetHashCode();
      if (InputOffset != 0) hash ^= InputOffset.GetHashCode();
      if (IncludeQueryPredictions != false) hash ^= IncludeQueryPredictions.GetHashCode();
      if (SessionToken.Length != 0) hash ^= SessionToken.GetHashCode();
      if (IncludePureServiceAreaBusinesses != false) hash ^= IncludePureServiceAreaBusinesses.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Input.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Input);
      }
      if (locationBias_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(LocationBias);
      }
      if (locationRestriction_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(LocationRestriction);
      }
      includedPrimaryTypes_.WriteTo(output, _repeated_includedPrimaryTypes_codec);
      includedRegionCodes_.WriteTo(output, _repeated_includedRegionCodes_codec);
      if (LanguageCode.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(LanguageCode);
      }
      if (RegionCode.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(RegionCode);
      }
      if (origin_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Origin);
      }
      if (InputOffset != 0) {
        output.WriteRawTag(72);
        output.WriteInt32(InputOffset);
      }
      if (IncludeQueryPredictions != false) {
        output.WriteRawTag(80);
        output.WriteBool(IncludeQueryPredictions);
      }
      if (SessionToken.Length != 0) {
        output.WriteRawTag(90);
        output.WriteString(SessionToken);
      }
      if (IncludePureServiceAreaBusinesses != false) {
        output.WriteRawTag(96);
        output.WriteBool(IncludePureServiceAreaBusinesses);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Input.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Input);
      }
      if (locationBias_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(LocationBias);
      }
      if (locationRestriction_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(LocationRestriction);
      }
      includedPrimaryTypes_.WriteTo(ref output, _repeated_includedPrimaryTypes_codec);
      includedRegionCodes_.WriteTo(ref output, _repeated_includedRegionCodes_codec);
      if (LanguageCode.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(LanguageCode);
      }
      if (RegionCode.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(RegionCode);
      }
      if (origin_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Origin);
      }
      if (InputOffset != 0) {
        output.WriteRawTag(72);
        output.WriteInt32(InputOffset);
      }
      if (IncludeQueryPredictions != false) {
        output.WriteRawTag(80);
        output.WriteBool(IncludeQueryPredictions);
      }
      if (SessionToken.Length != 0) {
        output.WriteRawTag(90);
        output.WriteString(SessionToken);
      }
      if (IncludePureServiceAreaBusinesses != false) {
        output.WriteRawTag(96);
        output.WriteBool(IncludePureServiceAreaBusinesses);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Input.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Input);
      }
      if (locationBias_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocationBias);
      }
      if (locationRestriction_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocationRestriction);
      }
      size += includedPrimaryTypes_.CalculateSize(_repeated_includedPrimaryTypes_codec);
      size += includedRegionCodes_.CalculateSize(_repeated_includedRegionCodes_codec);
      if (LanguageCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LanguageCode);
      }
      if (RegionCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RegionCode);
      }
      if (origin_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Origin);
      }
      if (InputOffset != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(InputOffset);
      }
      if (IncludeQueryPredictions != false) {
        size += 1 + 1;
      }
      if (SessionToken.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SessionToken);
      }
      if (IncludePureServiceAreaBusinesses != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AutocompletePlacesRequest other) {
      if (other == null) {
        return;
      }
      if (other.Input.Length != 0) {
        Input = other.Input;
      }
      if (other.locationBias_ != null) {
        if (locationBias_ == null) {
          LocationBias = new global::Google.Maps.Places.V1.AutocompletePlacesRequest.Types.LocationBias();
        }
        LocationBias.MergeFrom(other.LocationBias);
      }
      if (other.locationRestriction_ != null) {
        if (locationRestriction_ == null) {
          LocationRestriction = new global::Google.Maps.Places.V1.AutocompletePlacesRequest.Types.LocationRestriction();
        }
        LocationRestriction.MergeFrom(other.LocationRestriction);
      }
      includedPrimaryTypes_.Add(other.includedPrimaryTypes_);
      includedRegionCodes_.Add(other.includedRegionCodes_);
      if (other.LanguageCode.Length != 0) {
        LanguageCode = other.LanguageCode;
      }
      if (other.RegionCode.Length != 0) {
        RegionCode = other.RegionCode;
      }
      if (other.origin_ != null) {
        if (origin_ == null) {
          Origin = new global::Google.Type.LatLng();
        }
        Origin.MergeFrom(other.Origin);
      }
      if (other.InputOffset != 0) {
        InputOffset = other.InputOffset;
      }
      if (other.IncludeQueryPredictions != false) {
        IncludeQueryPredictions = other.IncludeQueryPredictions;
      }
      if (other.SessionToken.Length != 0) {
        SessionToken = other.SessionToken;
      }
      if (other.IncludePureServiceAreaBusinesses != false) {
        IncludePureServiceAreaBusinesses = other.IncludePureServiceAreaBusinesses;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Input = input.ReadString();
            break;
          }
          case 18: {
            if (locationBias_ == null) {
              LocationBias = new global::Google.Maps.Places.V1.AutocompletePlacesRequest.Types.LocationBias();
            }
            input.ReadMessage(LocationBias);
            break;
          }
          case 26: {
            if (locationRestriction_ == null) {
              LocationRestriction = new global::Google.Maps.Places.V1.AutocompletePlacesRequest.Types.LocationRestriction();
            }
            input.ReadMessage(LocationRestriction);
            break;
          }
          case 34: {
            includedPrimaryTypes_.AddEntriesFrom(input, _repeated_includedPrimaryTypes_codec);
            break;
          }
          case 42: {
            includedRegionCodes_.AddEntriesFrom(input, _repeated_includedRegionCodes_codec);
            break;
          }
          case 50: {
            LanguageCode = input.ReadString();
            break;
          }
          case 58: {
            RegionCode = input.ReadString();
            break;
          }
          case 66: {
            if (origin_ == null) {
              Origin = new global::Google.Type.LatLng();
            }
            input.ReadMessage(Origin);
            break;
          }
          case 72: {
            InputOffset = input.ReadInt32();
            break;
          }
          case 80: {
            IncludeQueryPredictions = input.ReadBool();
            break;
          }
          case 90: {
            SessionToken = input.ReadString();
            break;
          }
          case 96: {
            IncludePureServiceAreaBusinesses = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Input = input.ReadString();
            break;
          }
          case 18: {
            if (locationBias_ == null) {
              LocationBias = new global::Google.Maps.Places.V1.AutocompletePlacesRequest.Types.LocationBias();
            }
            input.ReadMessage(LocationBias);
            break;
          }
          case 26: {
            if (locationRestriction_ == null) {
              LocationRestriction = new global::Google.Maps.Places.V1.AutocompletePlacesRequest.Types.LocationRestriction();
            }
            input.ReadMessage(LocationRestriction);
            break;
          }
          case 34: {
            includedPrimaryTypes_.AddEntriesFrom(ref input, _repeated_includedPrimaryTypes_codec);
            break;
          }
          case 42: {
            includedRegionCodes_.AddEntriesFrom(ref input, _repeated_includedRegionCodes_codec);
            break;
          }
          case 50: {
            LanguageCode = input.ReadString();
            break;
          }
          case 58: {
            RegionCode = input.ReadString();
            break;
          }
          case 66: {
            if (origin_ == null) {
              Origin = new global::Google.Type.LatLng();
            }
            input.ReadMessage(Origin);
            break;
          }
          case 72: {
            InputOffset = input.ReadInt32();
            break;
          }
          case 80: {
            IncludeQueryPredictions = input.ReadBool();
            break;
          }
          case 90: {
            SessionToken = input.ReadString();
            break;
          }
          case 96: {
            IncludePureServiceAreaBusinesses = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the AutocompletePlacesRequest message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// The region to search. The results may be biased around the specified
      /// region.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class LocationBias : pb::IMessage<LocationBias>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<LocationBias> _parser = new pb::MessageParser<LocationBias>(() => new LocationBias());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<LocationBias> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.Places.V1.AutocompletePlacesRequest.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocationBias() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocationBias(LocationBias other) : this() {
          switch (other.TypeCase) {
            case TypeOneofCase.Rectangle:
              Rectangle = other.Rectangle.Clone();
              break;
            case TypeOneofCase.Circle:
              Circle = other.Circle.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocationBias Clone() {
          return new LocationBias(this);
        }

        /// <summary>Field number for the "rectangle" field.</summary>
        public const int RectangleFieldNumber = 1;
        /// <summary>
        /// A viewport defined by a northeast and a southwest corner.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Geo.Type.Viewport Rectangle {
          get { return typeCase_ == TypeOneofCase.Rectangle ? (global::Google.Geo.Type.Viewport) type_ : null; }
          set {
            type_ = value;
            typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Rectangle;
          }
        }

        /// <summary>Field number for the "circle" field.</summary>
        public const int CircleFieldNumber = 2;
        /// <summary>
        /// A circle defined by a center point and radius.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Maps.Places.V1.Circle Circle {
          get { return typeCase_ == TypeOneofCase.Circle ? (global::Google.Maps.Places.V1.Circle) type_ : null; }
          set {
            type_ = value;
            typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Circle;
          }
        }

        private object type_;
        /// <summary>Enum of possible cases for the "type" oneof.</summary>
        public enum TypeOneofCase {
          None = 0,
          Rectangle = 1,
          Circle = 2,
        }
        private TypeOneofCase typeCase_ = TypeOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TypeOneofCase TypeCase {
          get { return typeCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearType() {
          typeCase_ = TypeOneofCase.None;
          type_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as LocationBias);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(LocationBias other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Rectangle, other.Rectangle)) return false;
          if (!object.Equals(Circle, other.Circle)) return false;
          if (TypeCase != other.TypeCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (typeCase_ == TypeOneofCase.Rectangle) hash ^= Rectangle.GetHashCode();
          if (typeCase_ == TypeOneofCase.Circle) hash ^= Circle.GetHashCode();
          hash ^= (int) typeCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (typeCase_ == TypeOneofCase.Rectangle) {
            output.WriteRawTag(10);
            output.WriteMessage(Rectangle);
          }
          if (typeCase_ == TypeOneofCase.Circle) {
            output.WriteRawTag(18);
            output.WriteMessage(Circle);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (typeCase_ == TypeOneofCase.Rectangle) {
            output.WriteRawTag(10);
            output.WriteMessage(Rectangle);
          }
          if (typeCase_ == TypeOneofCase.Circle) {
            output.WriteRawTag(18);
            output.WriteMessage(Circle);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (typeCase_ == TypeOneofCase.Rectangle) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Rectangle);
          }
          if (typeCase_ == TypeOneofCase.Circle) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Circle);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(LocationBias other) {
          if (other == null) {
            return;
          }
          switch (other.TypeCase) {
            case TypeOneofCase.Rectangle:
              if (Rectangle == null) {
                Rectangle = new global::Google.Geo.Type.Viewport();
              }
              Rectangle.MergeFrom(other.Rectangle);
              break;
            case TypeOneofCase.Circle:
              if (Circle == null) {
                Circle = new global::Google.Maps.Places.V1.Circle();
              }
              Circle.MergeFrom(other.Circle);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Google.Geo.Type.Viewport subBuilder = new global::Google.Geo.Type.Viewport();
                if (typeCase_ == TypeOneofCase.Rectangle) {
                  subBuilder.MergeFrom(Rectangle);
                }
                input.ReadMessage(subBuilder);
                Rectangle = subBuilder;
                break;
              }
              case 18: {
                global::Google.Maps.Places.V1.Circle subBuilder = new global::Google.Maps.Places.V1.Circle();
                if (typeCase_ == TypeOneofCase.Circle) {
                  subBuilder.MergeFrom(Circle);
                }
                input.ReadMessage(subBuilder);
                Circle = subBuilder;
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                global::Google.Geo.Type.Viewport subBuilder = new global::Google.Geo.Type.Viewport();
                if (typeCase_ == TypeOneofCase.Rectangle) {
                  subBuilder.MergeFrom(Rectangle);
                }
                input.ReadMessage(subBuilder);
                Rectangle = subBuilder;
                break;
              }
              case 18: {
                global::Google.Maps.Places.V1.Circle subBuilder = new global::Google.Maps.Places.V1.Circle();
                if (typeCase_ == TypeOneofCase.Circle) {
                  subBuilder.MergeFrom(Circle);
                }
                input.ReadMessage(subBuilder);
                Circle = subBuilder;
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// The region to search. The results will be restricted to the specified
      /// region.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class LocationRestriction : pb::IMessage<LocationRestriction>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<LocationRestriction> _parser = new pb::MessageParser<LocationRestriction>(() => new LocationRestriction());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<LocationRestriction> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.Places.V1.AutocompletePlacesRequest.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocationRestriction() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocationRestriction(LocationRestriction other) : this() {
          switch (other.TypeCase) {
            case TypeOneofCase.Rectangle:
              Rectangle = other.Rectangle.Clone();
              break;
            case TypeOneofCase.Circle:
              Circle = other.Circle.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public LocationRestriction Clone() {
          return new LocationRestriction(this);
        }

        /// <summary>Field number for the "rectangle" field.</summary>
        public const int RectangleFieldNumber = 1;
        /// <summary>
        /// A viewport defined by a northeast and a southwest corner.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Geo.Type.Viewport Rectangle {
          get { return typeCase_ == TypeOneofCase.Rectangle ? (global::Google.Geo.Type.Viewport) type_ : null; }
          set {
            type_ = value;
            typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Rectangle;
          }
        }

        /// <summary>Field number for the "circle" field.</summary>
        public const int CircleFieldNumber = 2;
        /// <summary>
        /// A circle defined by a center point and radius.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Maps.Places.V1.Circle Circle {
          get { return typeCase_ == TypeOneofCase.Circle ? (global::Google.Maps.Places.V1.Circle) type_ : null; }
          set {
            type_ = value;
            typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Circle;
          }
        }

        private object type_;
        /// <summary>Enum of possible cases for the "type" oneof.</summary>
        public enum TypeOneofCase {
          None = 0,
          Rectangle = 1,
          Circle = 2,
        }
        private TypeOneofCase typeCase_ = TypeOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public TypeOneofCase TypeCase {
          get { return typeCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearType() {
          typeCase_ = TypeOneofCase.None;
          type_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as LocationRestriction);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(LocationRestriction other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Rectangle, other.Rectangle)) return false;
          if (!object.Equals(Circle, other.Circle)) return false;
          if (TypeCase != other.TypeCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (typeCase_ == TypeOneofCase.Rectangle) hash ^= Rectangle.GetHashCode();
          if (typeCase_ == TypeOneofCase.Circle) hash ^= Circle.GetHashCode();
          hash ^= (int) typeCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (typeCase_ == TypeOneofCase.Rectangle) {
            output.WriteRawTag(10);
            output.WriteMessage(Rectangle);
          }
          if (typeCase_ == TypeOneofCase.Circle) {
            output.WriteRawTag(18);
            output.WriteMessage(Circle);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (typeCase_ == TypeOneofCase.Rectangle) {
            output.WriteRawTag(10);
            output.WriteMessage(Rectangle);
          }
          if (typeCase_ == TypeOneofCase.Circle) {
            output.WriteRawTag(18);
            output.WriteMessage(Circle);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (typeCase_ == TypeOneofCase.Rectangle) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Rectangle);
          }
          if (typeCase_ == TypeOneofCase.Circle) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Circle);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(LocationRestriction other) {
          if (other == null) {
            return;
          }
          switch (other.TypeCase) {
            case TypeOneofCase.Rectangle:
              if (Rectangle == null) {
                Rectangle = new global::Google.Geo.Type.Viewport();
              }
              Rectangle.MergeFrom(other.Rectangle);
              break;
            case TypeOneofCase.Circle:
              if (Circle == null) {
                Circle = new global::Google.Maps.Places.V1.Circle();
              }
              Circle.MergeFrom(other.Circle);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Google.Geo.Type.Viewport subBuilder = new global::Google.Geo.Type.Viewport();
                if (typeCase_ == TypeOneofCase.Rectangle) {
                  subBuilder.MergeFrom(Rectangle);
                }
                input.ReadMessage(subBuilder);
                Rectangle = subBuilder;
                break;
              }
              case 18: {
                global::Google.Maps.Places.V1.Circle subBuilder = new global::Google.Maps.Places.V1.Circle();
                if (typeCase_ == TypeOneofCase.Circle) {
                  subBuilder.MergeFrom(Circle);
                }
                input.ReadMessage(subBuilder);
                Circle = subBuilder;
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                global::Google.Geo.Type.Viewport subBuilder = new global::Google.Geo.Type.Viewport();
                if (typeCase_ == TypeOneofCase.Rectangle) {
                  subBuilder.MergeFrom(Rectangle);
                }
                input.ReadMessage(subBuilder);
                Rectangle = subBuilder;
                break;
              }
              case 18: {
                global::Google.Maps.Places.V1.Circle subBuilder = new global::Google.Maps.Places.V1.Circle();
                if (typeCase_ == TypeOneofCase.Circle) {
                  subBuilder.MergeFrom(Circle);
                }
                input.ReadMessage(subBuilder);
                Circle = subBuilder;
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Response proto for AutocompletePlaces.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class AutocompletePlacesResponse : pb::IMessage<AutocompletePlacesResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AutocompletePlacesResponse> _parser = new pb::MessageParser<AutocompletePlacesResponse>(() => new AutocompletePlacesResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AutocompletePlacesResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.Places.V1.PlacesServiceReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AutocompletePlacesResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AutocompletePlacesResponse(AutocompletePlacesResponse other) : this() {
      suggestions_ = other.suggestions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AutocompletePlacesResponse Clone() {
      return new AutocompletePlacesResponse(this);
    }

    /// <summary>Field number for the "suggestions" field.</summary>
    public const int SuggestionsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion> _repeated_suggestions_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion> suggestions_ = new pbc::RepeatedField<global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion>();
    /// <summary>
    /// Contains a list of suggestions, ordered in descending order of relevance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion> Suggestions {
      get { return suggestions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AutocompletePlacesResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AutocompletePlacesResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!suggestions_.Equals(other.suggestions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= suggestions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      suggestions_.WriteTo(output, _repeated_suggestions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      suggestions_.WriteTo(ref output, _repeated_suggestions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += suggestions_.CalculateSize(_repeated_suggestions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AutocompletePlacesResponse other) {
      if (other == null) {
        return;
      }
      suggestions_.Add(other.suggestions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            suggestions_.AddEntriesFrom(input, _repeated_suggestions_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            suggestions_.AddEntriesFrom(ref input, _repeated_suggestions_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the AutocompletePlacesResponse message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// An Autocomplete suggestion result.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class Suggestion : pb::IMessage<Suggestion>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Suggestion> _parser = new pb::MessageParser<Suggestion>(() => new Suggestion());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Suggestion> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.Places.V1.AutocompletePlacesResponse.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Suggestion() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Suggestion(Suggestion other) : this() {
          switch (other.KindCase) {
            case KindOneofCase.PlacePrediction:
              PlacePrediction = other.PlacePrediction.Clone();
              break;
            case KindOneofCase.QueryPrediction:
              QueryPrediction = other.QueryPrediction.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Suggestion Clone() {
          return new Suggestion(this);
        }

        /// <summary>Field number for the "place_prediction" field.</summary>
        public const int PlacePredictionFieldNumber = 1;
        /// <summary>
        /// A prediction for a Place.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.PlacePrediction PlacePrediction {
          get { return kindCase_ == KindOneofCase.PlacePrediction ? (global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.PlacePrediction) kind_ : null; }
          set {
            kind_ = value;
            kindCase_ = value == null ? KindOneofCase.None : KindOneofCase.PlacePrediction;
          }
        }

        /// <summary>Field number for the "query_prediction" field.</summary>
        public const int QueryPredictionFieldNumber = 2;
        /// <summary>
        /// A prediction for a query.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.QueryPrediction QueryPrediction {
          get { return kindCase_ == KindOneofCase.QueryPrediction ? (global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.QueryPrediction) kind_ : null; }
          set {
            kind_ = value;
            kindCase_ = value == null ? KindOneofCase.None : KindOneofCase.QueryPrediction;
          }
        }

        private object kind_;
        /// <summary>Enum of possible cases for the "kind" oneof.</summary>
        public enum KindOneofCase {
          None = 0,
          PlacePrediction = 1,
          QueryPrediction = 2,
        }
        private KindOneofCase kindCase_ = KindOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public KindOneofCase KindCase {
          get { return kindCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearKind() {
          kindCase_ = KindOneofCase.None;
          kind_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Suggestion);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Suggestion other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(PlacePrediction, other.PlacePrediction)) return false;
          if (!object.Equals(QueryPrediction, other.QueryPrediction)) return false;
          if (KindCase != other.KindCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (kindCase_ == KindOneofCase.PlacePrediction) hash ^= PlacePrediction.GetHashCode();
          if (kindCase_ == KindOneofCase.QueryPrediction) hash ^= QueryPrediction.GetHashCode();
          hash ^= (int) kindCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (kindCase_ == KindOneofCase.PlacePrediction) {
            output.WriteRawTag(10);
            output.WriteMessage(PlacePrediction);
          }
          if (kindCase_ == KindOneofCase.QueryPrediction) {
            output.WriteRawTag(18);
            output.WriteMessage(QueryPrediction);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (kindCase_ == KindOneofCase.PlacePrediction) {
            output.WriteRawTag(10);
            output.WriteMessage(PlacePrediction);
          }
          if (kindCase_ == KindOneofCase.QueryPrediction) {
            output.WriteRawTag(18);
            output.WriteMessage(QueryPrediction);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (kindCase_ == KindOneofCase.PlacePrediction) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(PlacePrediction);
          }
          if (kindCase_ == KindOneofCase.QueryPrediction) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(QueryPrediction);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Suggestion other) {
          if (other == null) {
            return;
          }
          switch (other.KindCase) {
            case KindOneofCase.PlacePrediction:
              if (PlacePrediction == null) {
                PlacePrediction = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.PlacePrediction();
              }
              PlacePrediction.MergeFrom(other.PlacePrediction);
              break;
            case KindOneofCase.QueryPrediction:
              if (QueryPrediction == null) {
                QueryPrediction = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.QueryPrediction();
              }
              QueryPrediction.MergeFrom(other.QueryPrediction);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.PlacePrediction subBuilder = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.PlacePrediction();
                if (kindCase_ == KindOneofCase.PlacePrediction) {
                  subBuilder.MergeFrom(PlacePrediction);
                }
                input.ReadMessage(subBuilder);
                PlacePrediction = subBuilder;
                break;
              }
              case 18: {
                global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.QueryPrediction subBuilder = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.QueryPrediction();
                if (kindCase_ == KindOneofCase.QueryPrediction) {
                  subBuilder.MergeFrom(QueryPrediction);
                }
                input.ReadMessage(subBuilder);
                QueryPrediction = subBuilder;
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.PlacePrediction subBuilder = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.PlacePrediction();
                if (kindCase_ == KindOneofCase.PlacePrediction) {
                  subBuilder.MergeFrom(PlacePrediction);
                }
                input.ReadMessage(subBuilder);
                PlacePrediction = subBuilder;
                break;
              }
              case 18: {
                global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.QueryPrediction subBuilder = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.QueryPrediction();
                if (kindCase_ == KindOneofCase.QueryPrediction) {
                  subBuilder.MergeFrom(QueryPrediction);
                }
                input.ReadMessage(subBuilder);
                QueryPrediction = subBuilder;
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the Suggestion message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// Identifies a substring within a given text.
          /// </summary>
          [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
          public sealed partial class StringRange : pb::IMessage<StringRange>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<StringRange> _parser = new pb::MessageParser<StringRange>(() => new StringRange());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<StringRange> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public StringRange() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public StringRange(StringRange other) : this() {
              startOffset_ = other.startOffset_;
              endOffset_ = other.endOffset_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public StringRange Clone() {
              return new StringRange(this);
            }

            /// <summary>Field number for the "start_offset" field.</summary>
            public const int StartOffsetFieldNumber = 1;
            private int startOffset_;
            /// <summary>
            /// Zero-based offset of the first Unicode character of the string
            /// (inclusive).
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int StartOffset {
              get { return startOffset_; }
              set {
                startOffset_ = value;
              }
            }

            /// <summary>Field number for the "end_offset" field.</summary>
            public const int EndOffsetFieldNumber = 2;
            private int endOffset_;
            /// <summary>
            /// Zero-based offset of the last Unicode character (exclusive).
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int EndOffset {
              get { return endOffset_; }
              set {
                endOffset_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as StringRange);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(StringRange other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (StartOffset != other.StartOffset) return false;
              if (EndOffset != other.EndOffset) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (StartOffset != 0) hash ^= StartOffset.GetHashCode();
              if (EndOffset != 0) hash ^= EndOffset.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (StartOffset != 0) {
                output.WriteRawTag(8);
                output.WriteInt32(StartOffset);
              }
              if (EndOffset != 0) {
                output.WriteRawTag(16);
                output.WriteInt32(EndOffset);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (StartOffset != 0) {
                output.WriteRawTag(8);
                output.WriteInt32(StartOffset);
              }
              if (EndOffset != 0) {
                output.WriteRawTag(16);
                output.WriteInt32(EndOffset);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (StartOffset != 0) {
                size += 1 + pb::CodedOutputStream.ComputeInt32Size(StartOffset);
              }
              if (EndOffset != 0) {
                size += 1 + pb::CodedOutputStream.ComputeInt32Size(EndOffset);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(StringRange other) {
              if (other == null) {
                return;
              }
              if (other.StartOffset != 0) {
                StartOffset = other.StartOffset;
              }
              if (other.EndOffset != 0) {
                EndOffset = other.EndOffset;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 8: {
                    StartOffset = input.ReadInt32();
                    break;
                  }
                  case 16: {
                    EndOffset = input.ReadInt32();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 8: {
                    StartOffset = input.ReadInt32();
                    break;
                  }
                  case 16: {
                    EndOffset = input.ReadInt32();
                    break;
                  }
                }
              }
            }
            #endif

          }

          /// <summary>
          /// Text representing a Place or query prediction. The text may be used as is
          /// or formatted.
          /// </summary>
          [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
          public sealed partial class FormattableText : pb::IMessage<FormattableText>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<FormattableText> _parser = new pb::MessageParser<FormattableText>(() => new FormattableText());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<FormattableText> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Descriptor.NestedTypes[1]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public FormattableText() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public FormattableText(FormattableText other) : this() {
              text_ = other.text_;
              matches_ = other.matches_.Clone();
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public FormattableText Clone() {
              return new FormattableText(this);
            }

            /// <summary>Field number for the "text" field.</summary>
            public const int TextFieldNumber = 1;
            private string text_ = "";
            /// <summary>
            /// Text that may be used as is or formatted with `matches`.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string Text {
              get { return text_; }
              set {
                text_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "matches" field.</summary>
            public const int MatchesFieldNumber = 2;
            private static readonly pb::FieldCodec<global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.StringRange> _repeated_matches_codec
                = pb::FieldCodec.ForMessage(18, global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.StringRange.Parser);
            private readonly pbc::RepeatedField<global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.StringRange> matches_ = new pbc::RepeatedField<global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.StringRange>();
            /// <summary>
            /// A list of string ranges identifying where the input request matched in
            /// `text`. The ranges can be used to format specific parts of `text`. The
            /// substrings may not be exact matches of `input` if the matching was
            /// determined by criteria other than string matching (for example, spell
            /// corrections or transliterations).
            ///
            /// These values are Unicode character offsets of `text`. The ranges are
            /// guaranteed to be ordered in increasing offset values.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public pbc::RepeatedField<global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.StringRange> Matches {
              get { return matches_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as FormattableText);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(FormattableText other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Text != other.Text) return false;
              if(!matches_.Equals(other.matches_)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (Text.Length != 0) hash ^= Text.GetHashCode();
              hash ^= matches_.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (Text.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(Text);
              }
              matches_.WriteTo(output, _repeated_matches_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (Text.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(Text);
              }
              matches_.WriteTo(ref output, _repeated_matches_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (Text.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Text);
              }
              size += matches_.CalculateSize(_repeated_matches_codec);
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(FormattableText other) {
              if (other == null) {
                return;
              }
              if (other.Text.Length != 0) {
                Text = other.Text;
              }
              matches_.Add(other.matches_);
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    Text = input.ReadString();
                    break;
                  }
                  case 18: {
                    matches_.AddEntriesFrom(input, _repeated_matches_codec);
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    Text = input.ReadString();
                    break;
                  }
                  case 18: {
                    matches_.AddEntriesFrom(ref input, _repeated_matches_codec);
                    break;
                  }
                }
              }
            }
            #endif

          }

          /// <summary>
          /// Contains a breakdown of a Place or query prediction into main text
          /// and secondary text.
          ///
          /// For Place predictions, the main text contains the specific name of the
          /// Place. For query predictions, the main text contains the query.
          ///
          /// The secondary text contains additional disambiguating features (such as a
          /// city or region) to further identify the Place or refine the query.
          /// </summary>
          [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
          public sealed partial class StructuredFormat : pb::IMessage<StructuredFormat>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<StructuredFormat> _parser = new pb::MessageParser<StructuredFormat>(() => new StructuredFormat());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<StructuredFormat> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Descriptor.NestedTypes[2]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public StructuredFormat() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public StructuredFormat(StructuredFormat other) : this() {
              mainText_ = other.mainText_ != null ? other.mainText_.Clone() : null;
              secondaryText_ = other.secondaryText_ != null ? other.secondaryText_.Clone() : null;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public StructuredFormat Clone() {
              return new StructuredFormat(this);
            }

            /// <summary>Field number for the "main_text" field.</summary>
            public const int MainTextFieldNumber = 1;
            private global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.FormattableText mainText_;
            /// <summary>
            /// Represents the name of the Place or query.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.FormattableText MainText {
              get { return mainText_; }
              set {
                mainText_ = value;
              }
            }

            /// <summary>Field number for the "secondary_text" field.</summary>
            public const int SecondaryTextFieldNumber = 2;
            private global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.FormattableText secondaryText_;
            /// <summary>
            /// Represents additional disambiguating features (such as a city or
            /// region) to further identify the Place or refine the query.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.FormattableText SecondaryText {
              get { return secondaryText_; }
              set {
                secondaryText_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as StructuredFormat);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(StructuredFormat other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (!object.Equals(MainText, other.MainText)) return false;
              if (!object.Equals(SecondaryText, other.SecondaryText)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (mainText_ != null) hash ^= MainText.GetHashCode();
              if (secondaryText_ != null) hash ^= SecondaryText.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (mainText_ != null) {
                output.WriteRawTag(10);
                output.WriteMessage(MainText);
              }
              if (secondaryText_ != null) {
                output.WriteRawTag(18);
                output.WriteMessage(SecondaryText);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (mainText_ != null) {
                output.WriteRawTag(10);
                output.WriteMessage(MainText);
              }
              if (secondaryText_ != null) {
                output.WriteRawTag(18);
                output.WriteMessage(SecondaryText);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (mainText_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(MainText);
              }
              if (secondaryText_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecondaryText);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(StructuredFormat other) {
              if (other == null) {
                return;
              }
              if (other.mainText_ != null) {
                if (mainText_ == null) {
                  MainText = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.FormattableText();
                }
                MainText.MergeFrom(other.MainText);
              }
              if (other.secondaryText_ != null) {
                if (secondaryText_ == null) {
                  SecondaryText = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.FormattableText();
                }
                SecondaryText.MergeFrom(other.SecondaryText);
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    if (mainText_ == null) {
                      MainText = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.FormattableText();
                    }
                    input.ReadMessage(MainText);
                    break;
                  }
                  case 18: {
                    if (secondaryText_ == null) {
                      SecondaryText = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.FormattableText();
                    }
                    input.ReadMessage(SecondaryText);
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    if (mainText_ == null) {
                      MainText = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.FormattableText();
                    }
                    input.ReadMessage(MainText);
                    break;
                  }
                  case 18: {
                    if (secondaryText_ == null) {
                      SecondaryText = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.FormattableText();
                    }
                    input.ReadMessage(SecondaryText);
                    break;
                  }
                }
              }
            }
            #endif

          }

          /// <summary>
          /// Prediction results for a Place Autocomplete prediction.
          /// </summary>
          [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
          public sealed partial class PlacePrediction : pb::IMessage<PlacePrediction>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<PlacePrediction> _parser = new pb::MessageParser<PlacePrediction>(() => new PlacePrediction());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<PlacePrediction> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Descriptor.NestedTypes[3]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public PlacePrediction() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public PlacePrediction(PlacePrediction other) : this() {
              place_ = other.place_;
              placeId_ = other.placeId_;
              text_ = other.text_ != null ? other.text_.Clone() : null;
              structuredFormat_ = other.structuredFormat_ != null ? other.structuredFormat_.Clone() : null;
              types_ = other.types_.Clone();
              distanceMeters_ = other.distanceMeters_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public PlacePrediction Clone() {
              return new PlacePrediction(this);
            }

            /// <summary>Field number for the "place" field.</summary>
            public const int PlaceFieldNumber = 1;
            private string place_ = "";
            /// <summary>
            /// The resource name of the suggested Place. This name can be used in
            /// other APIs that accept Place names.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string Place {
              get { return place_; }
              set {
                place_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "place_id" field.</summary>
            public const int PlaceIdFieldNumber = 2;
            private string placeId_ = "";
            /// <summary>
            /// The unique identifier of the suggested Place. This identifier can be
            /// used in other APIs that accept Place IDs.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string PlaceId {
              get { return placeId_; }
              set {
                placeId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "text" field.</summary>
            public const int TextFieldNumber = 3;
            private global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.FormattableText text_;
            /// <summary>
            /// Contains the human-readable name for the returned result. For
            /// establishment results, this is usually the business name and address.
            ///
            /// `text` is recommended for developers who wish to show a single UI
            /// element. Developers who wish to show two separate, but related, UI
            /// elements may want to use `structured_format` instead. They are two
            /// different ways to represent a Place prediction. Users should not try to
            /// parse `structured_format` into `text` or vice versa.
            ///
            /// This text may be different from the `display_name` returned by
            /// GetPlace.
            ///
            /// May be in mixed languages if the request `input` and `language_code`
            /// are in different languages or if the Place does not have a translation
            /// from the local language to `language_code`.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.FormattableText Text {
              get { return text_; }
              set {
                text_ = value;
              }
            }

            /// <summary>Field number for the "structured_format" field.</summary>
            public const int StructuredFormatFieldNumber = 4;
            private global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.StructuredFormat structuredFormat_;
            /// <summary>
            /// A breakdown of the Place prediction into main text containing the name
            /// of the Place and secondary text containing additional disambiguating
            /// features (such as a city or region).
            ///
            /// `structured_format` is recommended for developers who wish to show two
            /// separate, but related, UI elements. Developers who wish to show a
            /// single UI element may want to use `text` instead. They are two
            /// different ways to represent a Place prediction. Users should not try to
            /// parse `structured_format` into `text` or vice versa.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.StructuredFormat StructuredFormat {
              get { return structuredFormat_; }
              set {
                structuredFormat_ = value;
              }
            }

            /// <summary>Field number for the "types" field.</summary>
            public const int Types_FieldNumber = 5;
            private static readonly pb::FieldCodec<string> _repeated_types_codec
                = pb::FieldCodec.ForString(42);
            private readonly pbc::RepeatedField<string> types_ = new pbc::RepeatedField<string>();
            /// <summary>
            /// List of types that apply to this Place from Table A or Table B in
            /// https://developers.google.com/maps/documentation/places/web-service/place-types.
            ///
            /// A type is a categorization of a Place. Places with shared types will
            /// share similar characteristics.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public pbc::RepeatedField<string> Types_ {
              get { return types_; }
            }

            /// <summary>Field number for the "distance_meters" field.</summary>
            public const int DistanceMetersFieldNumber = 6;
            private int distanceMeters_;
            /// <summary>
            /// The length of the geodesic in meters from `origin` if `origin` is
            /// specified. Certain predictions such as routes may not populate this
            /// field.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int DistanceMeters {
              get { return distanceMeters_; }
              set {
                distanceMeters_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as PlacePrediction);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(PlacePrediction other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Place != other.Place) return false;
              if (PlaceId != other.PlaceId) return false;
              if (!object.Equals(Text, other.Text)) return false;
              if (!object.Equals(StructuredFormat, other.StructuredFormat)) return false;
              if(!types_.Equals(other.types_)) return false;
              if (DistanceMeters != other.DistanceMeters) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (Place.Length != 0) hash ^= Place.GetHashCode();
              if (PlaceId.Length != 0) hash ^= PlaceId.GetHashCode();
              if (text_ != null) hash ^= Text.GetHashCode();
              if (structuredFormat_ != null) hash ^= StructuredFormat.GetHashCode();
              hash ^= types_.GetHashCode();
              if (DistanceMeters != 0) hash ^= DistanceMeters.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (Place.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(Place);
              }
              if (PlaceId.Length != 0) {
                output.WriteRawTag(18);
                output.WriteString(PlaceId);
              }
              if (text_ != null) {
                output.WriteRawTag(26);
                output.WriteMessage(Text);
              }
              if (structuredFormat_ != null) {
                output.WriteRawTag(34);
                output.WriteMessage(StructuredFormat);
              }
              types_.WriteTo(output, _repeated_types_codec);
              if (DistanceMeters != 0) {
                output.WriteRawTag(48);
                output.WriteInt32(DistanceMeters);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (Place.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(Place);
              }
              if (PlaceId.Length != 0) {
                output.WriteRawTag(18);
                output.WriteString(PlaceId);
              }
              if (text_ != null) {
                output.WriteRawTag(26);
                output.WriteMessage(Text);
              }
              if (structuredFormat_ != null) {
                output.WriteRawTag(34);
                output.WriteMessage(StructuredFormat);
              }
              types_.WriteTo(ref output, _repeated_types_codec);
              if (DistanceMeters != 0) {
                output.WriteRawTag(48);
                output.WriteInt32(DistanceMeters);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (Place.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Place);
              }
              if (PlaceId.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(PlaceId);
              }
              if (text_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Text);
              }
              if (structuredFormat_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(StructuredFormat);
              }
              size += types_.CalculateSize(_repeated_types_codec);
              if (DistanceMeters != 0) {
                size += 1 + pb::CodedOutputStream.ComputeInt32Size(DistanceMeters);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(PlacePrediction other) {
              if (other == null) {
                return;
              }
              if (other.Place.Length != 0) {
                Place = other.Place;
              }
              if (other.PlaceId.Length != 0) {
                PlaceId = other.PlaceId;
              }
              if (other.text_ != null) {
                if (text_ == null) {
                  Text = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.FormattableText();
                }
                Text.MergeFrom(other.Text);
              }
              if (other.structuredFormat_ != null) {
                if (structuredFormat_ == null) {
                  StructuredFormat = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.StructuredFormat();
                }
                StructuredFormat.MergeFrom(other.StructuredFormat);
              }
              types_.Add(other.types_);
              if (other.DistanceMeters != 0) {
                DistanceMeters = other.DistanceMeters;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    Place = input.ReadString();
                    break;
                  }
                  case 18: {
                    PlaceId = input.ReadString();
                    break;
                  }
                  case 26: {
                    if (text_ == null) {
                      Text = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.FormattableText();
                    }
                    input.ReadMessage(Text);
                    break;
                  }
                  case 34: {
                    if (structuredFormat_ == null) {
                      StructuredFormat = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.StructuredFormat();
                    }
                    input.ReadMessage(StructuredFormat);
                    break;
                  }
                  case 42: {
                    types_.AddEntriesFrom(input, _repeated_types_codec);
                    break;
                  }
                  case 48: {
                    DistanceMeters = input.ReadInt32();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    Place = input.ReadString();
                    break;
                  }
                  case 18: {
                    PlaceId = input.ReadString();
                    break;
                  }
                  case 26: {
                    if (text_ == null) {
                      Text = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.FormattableText();
                    }
                    input.ReadMessage(Text);
                    break;
                  }
                  case 34: {
                    if (structuredFormat_ == null) {
                      StructuredFormat = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.StructuredFormat();
                    }
                    input.ReadMessage(StructuredFormat);
                    break;
                  }
                  case 42: {
                    types_.AddEntriesFrom(ref input, _repeated_types_codec);
                    break;
                  }
                  case 48: {
                    DistanceMeters = input.ReadInt32();
                    break;
                  }
                }
              }
            }
            #endif

          }

          /// <summary>
          /// Prediction results for a Query Autocomplete prediction.
          /// </summary>
          [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
          public sealed partial class QueryPrediction : pb::IMessage<QueryPrediction>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<QueryPrediction> _parser = new pb::MessageParser<QueryPrediction>(() => new QueryPrediction());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<QueryPrediction> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Descriptor.NestedTypes[4]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public QueryPrediction() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public QueryPrediction(QueryPrediction other) : this() {
              text_ = other.text_ != null ? other.text_.Clone() : null;
              structuredFormat_ = other.structuredFormat_ != null ? other.structuredFormat_.Clone() : null;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public QueryPrediction Clone() {
              return new QueryPrediction(this);
            }

            /// <summary>Field number for the "text" field.</summary>
            public const int TextFieldNumber = 1;
            private global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.FormattableText text_;
            /// <summary>
            /// The predicted text. This text does not represent a Place, but rather a
            /// text query that could be used in a search endpoint (for example,
            /// Text Search).
            ///
            /// `text` is recommended for developers who wish to show a single UI
            /// element. Developers who wish to show two separate, but related, UI
            /// elements may want to use `structured_format` instead. They are two
            /// different ways to represent a query prediction. Users should not try to
            /// parse `structured_format` into `text` or vice versa.
            ///
            /// May be in mixed languages if the request `input` and `language_code`
            /// are in different languages or if part of the query does not have a
            /// translation from the local language to `language_code`.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.FormattableText Text {
              get { return text_; }
              set {
                text_ = value;
              }
            }

            /// <summary>Field number for the "structured_format" field.</summary>
            public const int StructuredFormatFieldNumber = 2;
            private global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.StructuredFormat structuredFormat_;
            /// <summary>
            /// A breakdown of the query prediction into main text containing the query
            /// and secondary text containing additional disambiguating features (such
            /// as a city or region).
            ///
            /// `structured_format` is recommended for developers who wish to show two
            /// separate, but related, UI elements. Developers who wish to show a
            /// single UI element may want to use `text` instead. They are two
            /// different ways to represent a query prediction. Users should not try to
            /// parse `structured_format` into `text` or vice versa.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.StructuredFormat StructuredFormat {
              get { return structuredFormat_; }
              set {
                structuredFormat_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as QueryPrediction);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(QueryPrediction other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (!object.Equals(Text, other.Text)) return false;
              if (!object.Equals(StructuredFormat, other.StructuredFormat)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (text_ != null) hash ^= Text.GetHashCode();
              if (structuredFormat_ != null) hash ^= StructuredFormat.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (text_ != null) {
                output.WriteRawTag(10);
                output.WriteMessage(Text);
              }
              if (structuredFormat_ != null) {
                output.WriteRawTag(18);
                output.WriteMessage(StructuredFormat);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (text_ != null) {
                output.WriteRawTag(10);
                output.WriteMessage(Text);
              }
              if (structuredFormat_ != null) {
                output.WriteRawTag(18);
                output.WriteMessage(StructuredFormat);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (text_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Text);
              }
              if (structuredFormat_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(StructuredFormat);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(QueryPrediction other) {
              if (other == null) {
                return;
              }
              if (other.text_ != null) {
                if (text_ == null) {
                  Text = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.FormattableText();
                }
                Text.MergeFrom(other.Text);
              }
              if (other.structuredFormat_ != null) {
                if (structuredFormat_ == null) {
                  StructuredFormat = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.StructuredFormat();
                }
                StructuredFormat.MergeFrom(other.StructuredFormat);
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    if (text_ == null) {
                      Text = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.FormattableText();
                    }
                    input.ReadMessage(Text);
                    break;
                  }
                  case 18: {
                    if (structuredFormat_ == null) {
                      StructuredFormat = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.StructuredFormat();
                    }
                    input.ReadMessage(StructuredFormat);
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    if (text_ == null) {
                      Text = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.FormattableText();
                    }
                    input.ReadMessage(Text);
                    break;
                  }
                  case 18: {
                    if (structuredFormat_ == null) {
                      StructuredFormat = new global::Google.Maps.Places.V1.AutocompletePlacesResponse.Types.Suggestion.Types.StructuredFormat();
                    }
                    input.ReadMessage(StructuredFormat);
                    break;
                  }
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
