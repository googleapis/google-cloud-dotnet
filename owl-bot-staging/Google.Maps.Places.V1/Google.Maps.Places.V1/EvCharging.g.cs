// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/maps/places/v1/ev_charging.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Maps.Places.V1 {

  /// <summary>Holder for reflection information generated from google/maps/places/v1/ev_charging.proto</summary>
  public static partial class EvChargingReflection {

    #region Descriptor
    /// <summary>File descriptor for google/maps/places/v1/ev_charging.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static EvChargingReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cidnb29nbGUvbWFwcy9wbGFjZXMvdjEvZXZfY2hhcmdpbmcucHJvdG8SFWdv",
            "b2dsZS5tYXBzLnBsYWNlcy52MRofZ29vZ2xlL3Byb3RvYnVmL3RpbWVzdGFt",
            "cC5wcm90byKxAwoPRVZDaGFyZ2VPcHRpb25zEhcKD2Nvbm5lY3Rvcl9jb3Vu",
            "dBgBIAEoBRJaChVjb25uZWN0b3JfYWdncmVnYXRpb24YAiADKAsyOy5nb29n",
            "bGUubWFwcy5wbGFjZXMudjEuRVZDaGFyZ2VPcHRpb25zLkNvbm5lY3RvckFn",
            "Z3JlZ2F0aW9uGqgCChRDb25uZWN0b3JBZ2dyZWdhdGlvbhI0CgR0eXBlGAEg",
            "ASgOMiYuZ29vZ2xlLm1hcHMucGxhY2VzLnYxLkVWQ29ubmVjdG9yVHlwZRIa",
            "ChJtYXhfY2hhcmdlX3JhdGVfa3cYAiABKAESDQoFY291bnQYAyABKAUSHAoP",
            "YXZhaWxhYmxlX2NvdW50GAQgASgFSACIAQESIQoUb3V0X29mX3NlcnZpY2Vf",
            "Y291bnQYBSABKAVIAYgBARJBCh1hdmFpbGFiaWxpdHlfbGFzdF91cGRhdGVf",
            "dGltZRgGIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCEgoQX2F2",
            "YWlsYWJsZV9jb3VudEIXChVfb3V0X29mX3NlcnZpY2VfY291bnQq5QIKD0VW",
            "Q29ubmVjdG9yVHlwZRIhCh1FVl9DT05ORUNUT1JfVFlQRV9VTlNQRUNJRklF",
            "RBAAEhsKF0VWX0NPTk5FQ1RPUl9UWVBFX09USEVSEAESGwoXRVZfQ09OTkVD",
            "VE9SX1RZUEVfSjE3NzIQAhIcChhFVl9DT05ORUNUT1JfVFlQRV9UWVBFXzIQ",
            "AxIdChlFVl9DT05ORUNUT1JfVFlQRV9DSEFERU1PEAQSIQodRVZfQ09OTkVD",
            "VE9SX1RZUEVfQ0NTX0NPTUJPXzEQBRIhCh1FVl9DT05ORUNUT1JfVFlQRV9D",
            "Q1NfQ09NQk9fMhAGEhsKF0VWX0NPTk5FQ1RPUl9UWVBFX1RFU0xBEAcSJgoi",
            "RVZfQ09OTkVDVE9SX1RZUEVfVU5TUEVDSUZJRURfR0JfVBAIEi0KKUVWX0NP",
            "Tk5FQ1RPUl9UWVBFX1VOU1BFQ0lGSUVEX1dBTExfT1VUTEVUEAlCoAEKGWNv",
            "bS5nb29nbGUubWFwcy5wbGFjZXMudjFCD0V2Q2hhcmdpbmdQcm90b1ABWjdj",
            "bG91ZC5nb29nbGUuY29tL2dvL21hcHMvcGxhY2VzL2FwaXYxL3BsYWNlc3Bi",
            "O3BsYWNlc3BiogIGR01QU1YxqgIVR29vZ2xlLk1hcHMuUGxhY2VzLlYxygIV",
            "R29vZ2xlXE1hcHNcUGxhY2VzXFYxYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Google.Maps.Places.V1.EVConnectorType), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.EVChargeOptions), global::Google.Maps.Places.V1.EVChargeOptions.Parser, new[]{ "ConnectorCount", "ConnectorAggregation" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.Places.V1.EVChargeOptions.Types.ConnectorAggregation), global::Google.Maps.Places.V1.EVChargeOptions.Types.ConnectorAggregation.Parser, new[]{ "Type", "MaxChargeRateKw", "Count", "AvailableCount", "OutOfServiceCount", "AvailabilityLastUpdateTime" }, new[]{ "AvailableCount", "OutOfServiceCount" }, null, null, null)})
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// See http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6872107 for
  /// additional information/context on EV charging connector types.
  /// </summary>
  public enum EVConnectorType {
    /// <summary>
    /// Unspecified connector.
    /// </summary>
    [pbr::OriginalName("EV_CONNECTOR_TYPE_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// Other connector types.
    /// </summary>
    [pbr::OriginalName("EV_CONNECTOR_TYPE_OTHER")] Other = 1,
    /// <summary>
    /// J1772 type 1 connector.
    /// </summary>
    [pbr::OriginalName("EV_CONNECTOR_TYPE_J1772")] J1772 = 2,
    /// <summary>
    /// IEC 62196 type 2 connector. Often referred to as MENNEKES.
    /// </summary>
    [pbr::OriginalName("EV_CONNECTOR_TYPE_TYPE_2")] Type2 = 3,
    /// <summary>
    /// CHAdeMO type connector.
    /// </summary>
    [pbr::OriginalName("EV_CONNECTOR_TYPE_CHADEMO")] Chademo = 4,
    /// <summary>
    /// Combined Charging System (AC and DC). Based on SAE.
    ///  Type-1 J-1772 connector
    /// </summary>
    [pbr::OriginalName("EV_CONNECTOR_TYPE_CCS_COMBO_1")] CcsCombo1 = 5,
    /// <summary>
    /// Combined Charging System (AC and DC). Based on Type-2
    /// Mennekes connector
    /// </summary>
    [pbr::OriginalName("EV_CONNECTOR_TYPE_CCS_COMBO_2")] CcsCombo2 = 6,
    /// <summary>
    /// The generic TESLA connector. This is NACS in the North America but can be
    /// non-NACS in other parts of the world (e.g. CCS Combo 2 (CCS2) or GB/T).
    /// This value is less representative of an actual connector type, and more
    /// represents the ability to charge a Tesla brand vehicle at a Tesla owned
    /// charging station.
    /// </summary>
    [pbr::OriginalName("EV_CONNECTOR_TYPE_TESLA")] Tesla = 7,
    /// <summary>
    /// GB/T type corresponds to the GB/T standard in China. This type covers all
    /// GB_T types.
    /// </summary>
    [pbr::OriginalName("EV_CONNECTOR_TYPE_UNSPECIFIED_GB_T")] UnspecifiedGbT = 8,
    /// <summary>
    /// Unspecified wall outlet.
    /// </summary>
    [pbr::OriginalName("EV_CONNECTOR_TYPE_UNSPECIFIED_WALL_OUTLET")] UnspecifiedWallOutlet = 9,
  }

  #endregion

  #region Messages
  /// <summary>
  /// Information about the EV Charge Station hosted in Place.
  /// Terminology follows
  /// https://afdc.energy.gov/fuels/electricity_infrastructure.html One port
  /// could charge one car at a time. One port has one or more connectors. One
  /// station has one or more ports.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class EVChargeOptions : pb::IMessage<EVChargeOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EVChargeOptions> _parser = new pb::MessageParser<EVChargeOptions>(() => new EVChargeOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EVChargeOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.Places.V1.EvChargingReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EVChargeOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EVChargeOptions(EVChargeOptions other) : this() {
      connectorCount_ = other.connectorCount_;
      connectorAggregation_ = other.connectorAggregation_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EVChargeOptions Clone() {
      return new EVChargeOptions(this);
    }

    /// <summary>Field number for the "connector_count" field.</summary>
    public const int ConnectorCountFieldNumber = 1;
    private int connectorCount_;
    /// <summary>
    /// Number of connectors at this station. However, because some ports can have
    /// multiple connectors but only be able to charge one car at a time (e.g.) the
    /// number of connectors may be greater than the total number of cars which can
    /// charge simultaneously.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int ConnectorCount {
      get { return connectorCount_; }
      set {
        connectorCount_ = value;
      }
    }

    /// <summary>Field number for the "connector_aggregation" field.</summary>
    public const int ConnectorAggregationFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Google.Maps.Places.V1.EVChargeOptions.Types.ConnectorAggregation> _repeated_connectorAggregation_codec
        = pb::FieldCodec.ForMessage(18, global::Google.Maps.Places.V1.EVChargeOptions.Types.ConnectorAggregation.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.Places.V1.EVChargeOptions.Types.ConnectorAggregation> connectorAggregation_ = new pbc::RepeatedField<global::Google.Maps.Places.V1.EVChargeOptions.Types.ConnectorAggregation>();
    /// <summary>
    /// A list of EV charging connector aggregations that contain connectors of the
    /// same type and same charge rate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.Places.V1.EVChargeOptions.Types.ConnectorAggregation> ConnectorAggregation {
      get { return connectorAggregation_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EVChargeOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EVChargeOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ConnectorCount != other.ConnectorCount) return false;
      if(!connectorAggregation_.Equals(other.connectorAggregation_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (ConnectorCount != 0) hash ^= ConnectorCount.GetHashCode();
      hash ^= connectorAggregation_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (ConnectorCount != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(ConnectorCount);
      }
      connectorAggregation_.WriteTo(output, _repeated_connectorAggregation_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (ConnectorCount != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(ConnectorCount);
      }
      connectorAggregation_.WriteTo(ref output, _repeated_connectorAggregation_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (ConnectorCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ConnectorCount);
      }
      size += connectorAggregation_.CalculateSize(_repeated_connectorAggregation_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EVChargeOptions other) {
      if (other == null) {
        return;
      }
      if (other.ConnectorCount != 0) {
        ConnectorCount = other.ConnectorCount;
      }
      connectorAggregation_.Add(other.connectorAggregation_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ConnectorCount = input.ReadInt32();
            break;
          }
          case 18: {
            connectorAggregation_.AddEntriesFrom(input, _repeated_connectorAggregation_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ConnectorCount = input.ReadInt32();
            break;
          }
          case 18: {
            connectorAggregation_.AddEntriesFrom(ref input, _repeated_connectorAggregation_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the EVChargeOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// EV charging information grouped by [type, max_charge_rate_kw].
      /// Shows EV charge aggregation of connectors that have the same type and max
      /// charge rate in kw.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class ConnectorAggregation : pb::IMessage<ConnectorAggregation>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<ConnectorAggregation> _parser = new pb::MessageParser<ConnectorAggregation>(() => new ConnectorAggregation());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<ConnectorAggregation> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Maps.Places.V1.EVChargeOptions.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ConnectorAggregation() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ConnectorAggregation(ConnectorAggregation other) : this() {
          _hasBits0 = other._hasBits0;
          type_ = other.type_;
          maxChargeRateKw_ = other.maxChargeRateKw_;
          count_ = other.count_;
          availableCount_ = other.availableCount_;
          outOfServiceCount_ = other.outOfServiceCount_;
          availabilityLastUpdateTime_ = other.availabilityLastUpdateTime_ != null ? other.availabilityLastUpdateTime_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ConnectorAggregation Clone() {
          return new ConnectorAggregation(this);
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 1;
        private global::Google.Maps.Places.V1.EVConnectorType type_ = global::Google.Maps.Places.V1.EVConnectorType.Unspecified;
        /// <summary>
        /// The connector type of this aggregation.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Maps.Places.V1.EVConnectorType Type {
          get { return type_; }
          set {
            type_ = value;
          }
        }

        /// <summary>Field number for the "max_charge_rate_kw" field.</summary>
        public const int MaxChargeRateKwFieldNumber = 2;
        private double maxChargeRateKw_;
        /// <summary>
        /// The static max charging rate in kw of each connector in the aggregation.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public double MaxChargeRateKw {
          get { return maxChargeRateKw_; }
          set {
            maxChargeRateKw_ = value;
          }
        }

        /// <summary>Field number for the "count" field.</summary>
        public const int CountFieldNumber = 3;
        private int count_;
        /// <summary>
        /// Number of connectors in this aggregation.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int Count {
          get { return count_; }
          set {
            count_ = value;
          }
        }

        /// <summary>Field number for the "available_count" field.</summary>
        public const int AvailableCountFieldNumber = 4;
        private readonly static int AvailableCountDefaultValue = 0;

        private int availableCount_;
        /// <summary>
        /// Number of connectors in this aggregation that are currently available.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int AvailableCount {
          get { if ((_hasBits0 & 1) != 0) { return availableCount_; } else { return AvailableCountDefaultValue; } }
          set {
            _hasBits0 |= 1;
            availableCount_ = value;
          }
        }
        /// <summary>Gets whether the "available_count" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasAvailableCount {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "available_count" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearAvailableCount() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "out_of_service_count" field.</summary>
        public const int OutOfServiceCountFieldNumber = 5;
        private readonly static int OutOfServiceCountDefaultValue = 0;

        private int outOfServiceCount_;
        /// <summary>
        /// Number of connectors in this aggregation that are currently out of
        /// service.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int OutOfServiceCount {
          get { if ((_hasBits0 & 2) != 0) { return outOfServiceCount_; } else { return OutOfServiceCountDefaultValue; } }
          set {
            _hasBits0 |= 2;
            outOfServiceCount_ = value;
          }
        }
        /// <summary>Gets whether the "out_of_service_count" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasOutOfServiceCount {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "out_of_service_count" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearOutOfServiceCount() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "availability_last_update_time" field.</summary>
        public const int AvailabilityLastUpdateTimeFieldNumber = 6;
        private global::Google.Protobuf.WellKnownTypes.Timestamp availabilityLastUpdateTime_;
        /// <summary>
        /// The timestamp when the connector availability information in this
        /// aggregation was last updated.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Timestamp AvailabilityLastUpdateTime {
          get { return availabilityLastUpdateTime_; }
          set {
            availabilityLastUpdateTime_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as ConnectorAggregation);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(ConnectorAggregation other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Type != other.Type) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(MaxChargeRateKw, other.MaxChargeRateKw)) return false;
          if (Count != other.Count) return false;
          if (AvailableCount != other.AvailableCount) return false;
          if (OutOfServiceCount != other.OutOfServiceCount) return false;
          if (!object.Equals(AvailabilityLastUpdateTime, other.AvailabilityLastUpdateTime)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Type != global::Google.Maps.Places.V1.EVConnectorType.Unspecified) hash ^= Type.GetHashCode();
          if (MaxChargeRateKw != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(MaxChargeRateKw);
          if (Count != 0) hash ^= Count.GetHashCode();
          if (HasAvailableCount) hash ^= AvailableCount.GetHashCode();
          if (HasOutOfServiceCount) hash ^= OutOfServiceCount.GetHashCode();
          if (availabilityLastUpdateTime_ != null) hash ^= AvailabilityLastUpdateTime.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Type != global::Google.Maps.Places.V1.EVConnectorType.Unspecified) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Type);
          }
          if (MaxChargeRateKw != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(MaxChargeRateKw);
          }
          if (Count != 0) {
            output.WriteRawTag(24);
            output.WriteInt32(Count);
          }
          if (HasAvailableCount) {
            output.WriteRawTag(32);
            output.WriteInt32(AvailableCount);
          }
          if (HasOutOfServiceCount) {
            output.WriteRawTag(40);
            output.WriteInt32(OutOfServiceCount);
          }
          if (availabilityLastUpdateTime_ != null) {
            output.WriteRawTag(50);
            output.WriteMessage(AvailabilityLastUpdateTime);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Type != global::Google.Maps.Places.V1.EVConnectorType.Unspecified) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Type);
          }
          if (MaxChargeRateKw != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(MaxChargeRateKw);
          }
          if (Count != 0) {
            output.WriteRawTag(24);
            output.WriteInt32(Count);
          }
          if (HasAvailableCount) {
            output.WriteRawTag(32);
            output.WriteInt32(AvailableCount);
          }
          if (HasOutOfServiceCount) {
            output.WriteRawTag(40);
            output.WriteInt32(OutOfServiceCount);
          }
          if (availabilityLastUpdateTime_ != null) {
            output.WriteRawTag(50);
            output.WriteMessage(AvailabilityLastUpdateTime);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Type != global::Google.Maps.Places.V1.EVConnectorType.Unspecified) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
          }
          if (MaxChargeRateKw != 0D) {
            size += 1 + 8;
          }
          if (Count != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(Count);
          }
          if (HasAvailableCount) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(AvailableCount);
          }
          if (HasOutOfServiceCount) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(OutOfServiceCount);
          }
          if (availabilityLastUpdateTime_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(AvailabilityLastUpdateTime);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(ConnectorAggregation other) {
          if (other == null) {
            return;
          }
          if (other.Type != global::Google.Maps.Places.V1.EVConnectorType.Unspecified) {
            Type = other.Type;
          }
          if (other.MaxChargeRateKw != 0D) {
            MaxChargeRateKw = other.MaxChargeRateKw;
          }
          if (other.Count != 0) {
            Count = other.Count;
          }
          if (other.HasAvailableCount) {
            AvailableCount = other.AvailableCount;
          }
          if (other.HasOutOfServiceCount) {
            OutOfServiceCount = other.OutOfServiceCount;
          }
          if (other.availabilityLastUpdateTime_ != null) {
            if (availabilityLastUpdateTime_ == null) {
              AvailabilityLastUpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            AvailabilityLastUpdateTime.MergeFrom(other.AvailabilityLastUpdateTime);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Type = (global::Google.Maps.Places.V1.EVConnectorType) input.ReadEnum();
                break;
              }
              case 17: {
                MaxChargeRateKw = input.ReadDouble();
                break;
              }
              case 24: {
                Count = input.ReadInt32();
                break;
              }
              case 32: {
                AvailableCount = input.ReadInt32();
                break;
              }
              case 40: {
                OutOfServiceCount = input.ReadInt32();
                break;
              }
              case 50: {
                if (availabilityLastUpdateTime_ == null) {
                  AvailabilityLastUpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(AvailabilityLastUpdateTime);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Type = (global::Google.Maps.Places.V1.EVConnectorType) input.ReadEnum();
                break;
              }
              case 17: {
                MaxChargeRateKw = input.ReadDouble();
                break;
              }
              case 24: {
                Count = input.ReadInt32();
                break;
              }
              case 32: {
                AvailableCount = input.ReadInt32();
                break;
              }
              case 40: {
                OutOfServiceCount = input.ReadInt32();
                break;
              }
              case 50: {
                if (availabilityLastUpdateTime_ == null) {
                  AvailabilityLastUpdateTime = new global::Google.Protobuf.WellKnownTypes.Timestamp();
                }
                input.ReadMessage(AvailabilityLastUpdateTime);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
