// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/cloud/backupdr/v1/backupvault_gce.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Cloud.BackupDR.V1 {

  /// <summary>Holder for reflection information generated from google/cloud/backupdr/v1/backupvault_gce.proto</summary>
  public static partial class BackupvaultGceReflection {

    #region Descriptor
    /// <summary>File descriptor for google/cloud/backupdr/v1/backupvault_gce.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static BackupvaultGceReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ci5nb29nbGUvY2xvdWQvYmFja3VwZHIvdjEvYmFja3VwdmF1bHRfZ2NlLnBy",
            "b3RvEhhnb29nbGUuY2xvdWQuYmFja3VwZHIudjEaH2dvb2dsZS9hcGkvZmll",
            "bGRfYmVoYXZpb3IucHJvdG8aG2dvb2dsZS9hcGkvZmllbGRfaW5mby5wcm90",
            "byLoBwofQ29tcHV0ZUluc3RhbmNlQmFja3VwUHJvcGVydGllcxIYCgtkZXNj",
            "cmlwdGlvbhgBIAEoCUgAiAEBEjEKBHRhZ3MYAiABKAsyHi5nb29nbGUuY2xv",
            "dWQuYmFja3VwZHIudjEuVGFnc0gBiAEBEhkKDG1hY2hpbmVfdHlwZRgDIAEo",
            "CUgCiAEBEhsKDmNhbl9pcF9mb3J3YXJkGAQgASgISAOIAQESRQoRbmV0d29y",
            "a19pbnRlcmZhY2UYBSADKAsyKi5nb29nbGUuY2xvdWQuYmFja3VwZHIudjEu",
            "TmV0d29ya0ludGVyZmFjZRI0CgRkaXNrGAYgAygLMiYuZ29vZ2xlLmNsb3Vk",
            "LmJhY2t1cGRyLnYxLkF0dGFjaGVkRGlzaxI5CghtZXRhZGF0YRgHIAEoCzIi",
            "Lmdvb2dsZS5jbG91ZC5iYWNrdXBkci52MS5NZXRhZGF0YUgEiAEBEkEKD3Nl",
            "cnZpY2VfYWNjb3VudBgIIAMoCzIoLmdvb2dsZS5jbG91ZC5iYWNrdXBkci52",
            "MS5TZXJ2aWNlQWNjb3VudBI9CgpzY2hlZHVsaW5nGAkgASgLMiQuZ29vZ2xl",
            "LmNsb3VkLmJhY2t1cGRyLnYxLlNjaGVkdWxpbmdIBYgBARJGChFndWVzdF9h",
            "Y2NlbGVyYXRvchgKIAMoCzIrLmdvb2dsZS5jbG91ZC5iYWNrdXBkci52MS5B",
            "Y2NlbGVyYXRvckNvbmZpZxIdChBtaW5fY3B1X3BsYXRmb3JtGAsgASgJSAaI",
            "AQESWgoaa2V5X3Jldm9jYXRpb25fYWN0aW9uX3R5cGUYDCABKA4yMS5nb29n",
            "bGUuY2xvdWQuYmFja3VwZHIudjEuS2V5UmV2b2NhdGlvbkFjdGlvblR5cGVI",
            "B4gBARIcCg9zb3VyY2VfaW5zdGFuY2UYDSABKAlICIgBARJVCgZsYWJlbHMY",
            "DiADKAsyRS5nb29nbGUuY2xvdWQuYmFja3VwZHIudjEuQ29tcHV0ZUluc3Rh",
            "bmNlQmFja3VwUHJvcGVydGllcy5MYWJlbHNFbnRyeRotCgtMYWJlbHNFbnRy",
            "eRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBQg4KDF9kZXNjcmlw",
            "dGlvbkIHCgVfdGFnc0IPCg1fbWFjaGluZV90eXBlQhEKD19jYW5faXBfZm9y",
            "d2FyZEILCglfbWV0YWRhdGFCDQoLX3NjaGVkdWxpbmdCEwoRX21pbl9jcHVf",
            "cGxhdGZvcm1CHQobX2tleV9yZXZvY2F0aW9uX2FjdGlvbl90eXBlQhIKEF9z",
            "b3VyY2VfaW5zdGFuY2UishIKIENvbXB1dGVJbnN0YW5jZVJlc3RvcmVQcm9w",
            "ZXJ0aWVzEhYKBG5hbWUYASABKAlCA+BBAkgAiAEBEl4KGWFkdmFuY2VkX21h",
            "Y2hpbmVfZmVhdHVyZXMYAiABKAsyMS5nb29nbGUuY2xvdWQuYmFja3VwZHIu",
            "djEuQWR2YW5jZWRNYWNoaW5lRmVhdHVyZXNCA+BBAUgBiAEBEiAKDmNhbl9p",
            "cF9mb3J3YXJkGAMgASgIQgPgQQFIAogBARJkChxjb25maWRlbnRpYWxfaW5z",
            "dGFuY2VfY29uZmlnGAQgASgLMjQuZ29vZ2xlLmNsb3VkLmJhY2t1cGRyLnYx",
            "LkNvbmZpZGVudGlhbEluc3RhbmNlQ29uZmlnQgPgQQFIA4gBARIlChNkZWxl",
            "dGlvbl9wcm90ZWN0aW9uGAUgASgIQgPgQQFIBIgBARIdCgtkZXNjcmlwdGlv",
            "bhgGIAEoCUID4EEBSAWIAQESOgoFZGlza3MYByADKAsyJi5nb29nbGUuY2xv",
            "dWQuYmFja3VwZHIudjEuQXR0YWNoZWREaXNrQgPgQQESSQoOZGlzcGxheV9k",
            "ZXZpY2UYCCABKAsyJy5nb29nbGUuY2xvdWQuYmFja3VwZHIudjEuRGlzcGxh",
            "eURldmljZUID4EEBSAaIAQESTAoSZ3Vlc3RfYWNjZWxlcmF0b3JzGAkgAygL",
            "MisuZ29vZ2xlLmNsb3VkLmJhY2t1cGRyLnYxLkFjY2VsZXJhdG9yQ29uZmln",
            "QgPgQQESGgoIaG9zdG5hbWUYCiABKAlCA+BBAUgHiAEBEloKF2luc3RhbmNl",
            "X2VuY3J5cHRpb25fa2V5GAsgASgLMi8uZ29vZ2xlLmNsb3VkLmJhY2t1cGRy",
            "LnYxLkN1c3RvbWVyRW5jcnlwdGlvbktleUID4EEBSAiIAQESXwoaa2V5X3Jl",
            "dm9jYXRpb25fYWN0aW9uX3R5cGUYDCABKA4yMS5nb29nbGUuY2xvdWQuYmFj",
            "a3VwZHIudjEuS2V5UmV2b2NhdGlvbkFjdGlvblR5cGVCA+BBAUgJiAEBElsK",
            "BmxhYmVscxgNIAMoCzJGLmdvb2dsZS5jbG91ZC5iYWNrdXBkci52MS5Db21w",
            "dXRlSW5zdGFuY2VSZXN0b3JlUHJvcGVydGllcy5MYWJlbHNFbnRyeUID4EEB",
            "Eh4KDG1hY2hpbmVfdHlwZRgOIAEoCUID4EEBSAqIAQESPgoIbWV0YWRhdGEY",
            "DyABKAsyIi5nb29nbGUuY2xvdWQuYmFja3VwZHIudjEuTWV0YWRhdGFCA+BB",
            "AUgLiAEBEiIKEG1pbl9jcHVfcGxhdGZvcm0YECABKAlCA+BBAUgMiAEBEksK",
            "Em5ldHdvcmtfaW50ZXJmYWNlcxgRIAMoCzIqLmdvb2dsZS5jbG91ZC5iYWNr",
            "dXBkci52MS5OZXR3b3JrSW50ZXJmYWNlQgPgQQESYAoabmV0d29ya19wZXJm",
            "b3JtYW5jZV9jb25maWcYEiABKAsyMi5nb29nbGUuY2xvdWQuYmFja3VwZHIu",
            "djEuTmV0d29ya1BlcmZvcm1hbmNlQ29uZmlnQgPgQQFIDYgBARJCCgZwYXJh",
            "bXMYEyABKAsyKC5nb29nbGUuY2xvdWQuYmFja3VwZHIudjEuSW5zdGFuY2VQ",
            "YXJhbXNCA+BBBEgOiAEBEogBChpwcml2YXRlX2lwdjZfZ29vZ2xlX2FjY2Vz",
            "cxgUIAEoDjJaLmdvb2dsZS5jbG91ZC5iYWNrdXBkci52MS5Db21wdXRlSW5z",
            "dGFuY2VSZXN0b3JlUHJvcGVydGllcy5JbnN0YW5jZVByaXZhdGVJcHY2R29v",
            "Z2xlQWNjZXNzQgPgQQFID4gBARJTChNhbGxvY2F0aW9uX2FmZmluaXR5GBUg",
            "ASgLMiwuZ29vZ2xlLmNsb3VkLmJhY2t1cGRyLnYxLkFsbG9jYXRpb25BZmZp",
            "bml0eUID4EEBSBCIAQESHgoRcmVzb3VyY2VfcG9saWNpZXMYFiADKAlCA+BB",
            "ARJCCgpzY2hlZHVsaW5nGBcgASgLMiQuZ29vZ2xlLmNsb3VkLmJhY2t1cGRy",
            "LnYxLlNjaGVkdWxpbmdCA+BBAUgRiAEBEkcKEHNlcnZpY2VfYWNjb3VudHMY",
            "GCADKAsyKC5nb29nbGUuY2xvdWQuYmFja3VwZHIudjEuU2VydmljZUFjY291",
            "bnRCA+BBARI2CgR0YWdzGBogASgLMh4uZ29vZ2xlLmNsb3VkLmJhY2t1cGRy",
            "LnYxLlRhZ3NCA+BBAUgSiAEBGi0KC0xhYmVsc0VudHJ5EgsKA2tleRgBIAEo",
            "CRINCgV2YWx1ZRgCIAEoCToCOAEixwEKH0luc3RhbmNlUHJpdmF0ZUlwdjZH",
            "b29nbGVBY2Nlc3MSMwovSU5TVEFOQ0VfUFJJVkFURV9JUFY2X0dPT0dMRV9B",
            "Q0NFU1NfVU5TUEVDSUZJRUQQABIbChdJTkhFUklUX0ZST01fU1VCTkVUV09S",
            "SxABEicKI0VOQUJMRV9PVVRCT1VORF9WTV9BQ0NFU1NfVE9fR09PR0xFEAIS",
            "KQolRU5BQkxFX0JJRElSRUNUSU9OQUxfQUNDRVNTX1RPX0dPT0dMRRADQgcK",
            "BV9uYW1lQhwKGl9hZHZhbmNlZF9tYWNoaW5lX2ZlYXR1cmVzQhEKD19jYW5f",
            "aXBfZm9yd2FyZEIfCh1fY29uZmlkZW50aWFsX2luc3RhbmNlX2NvbmZpZ0IW",
            "ChRfZGVsZXRpb25fcHJvdGVjdGlvbkIOCgxfZGVzY3JpcHRpb25CEQoPX2Rp",
            "c3BsYXlfZGV2aWNlQgsKCV9ob3N0bmFtZUIaChhfaW5zdGFuY2VfZW5jcnlw",
            "dGlvbl9rZXlCHQobX2tleV9yZXZvY2F0aW9uX2FjdGlvbl90eXBlQg8KDV9t",
            "YWNoaW5lX3R5cGVCCwoJX21ldGFkYXRhQhMKEV9taW5fY3B1X3BsYXRmb3Jt",
            "Qh0KG19uZXR3b3JrX3BlcmZvcm1hbmNlX2NvbmZpZ0IJCgdfcGFyYW1zQh0K",
            "G19wcml2YXRlX2lwdjZfZ29vZ2xlX2FjY2Vzc0IWChRfYWxsb2NhdGlvbl9h",
            "ZmZpbml0eUINCgtfc2NoZWR1bGluZ0IHCgVfdGFncyJLCiBDb21wdXRlSW5z",
            "dGFuY2VUYXJnZXRFbnZpcm9ubWVudBIUCgdwcm9qZWN0GAEgASgJQgPgQQIS",
            "EQoEem9uZRgCIAEoCUID4EECIpQBCiNDb21wdXRlSW5zdGFuY2VEYXRhU291",
            "cmNlUHJvcGVydGllcxIMCgRuYW1lGAEgASgJEhMKC2Rlc2NyaXB0aW9uGAIg",
            "ASgJEhQKDG1hY2hpbmVfdHlwZRgDIAEoCRIYChB0b3RhbF9kaXNrX2NvdW50",
            "GAQgASgDEhoKEnRvdGFsX2Rpc2tfc2l6ZV9nYhgFIAEoAyKlAgoXQWR2YW5j",
            "ZWRNYWNoaW5lRmVhdHVyZXMSLgocZW5hYmxlX25lc3RlZF92aXJ0dWFsaXph",
            "dGlvbhgBIAEoCEID4EEBSACIAQESIgoQdGhyZWFkc19wZXJfY29yZRgCIAEo",
            "BUID4EEBSAGIAQESJAoSdmlzaWJsZV9jb3JlX2NvdW50GAMgASgFQgPgQQFI",
            "AogBARIoChZlbmFibGVfdWVmaV9uZXR3b3JraW5nGAQgASgIQgPgQQFIA4gB",
            "AUIfCh1fZW5hYmxlX25lc3RlZF92aXJ0dWFsaXphdGlvbkITChFfdGhyZWFk",
            "c19wZXJfY29yZUIVChNfdmlzaWJsZV9jb3JlX2NvdW50QhkKF19lbmFibGVf",
            "dWVmaV9uZXR3b3JraW5nImsKGkNvbmZpZGVudGlhbEluc3RhbmNlQ29uZmln",
            "Ei0KG2VuYWJsZV9jb25maWRlbnRpYWxfY29tcHV0ZRgBIAEoCEID4EEBSACI",
            "AQFCHgocX2VuYWJsZV9jb25maWRlbnRpYWxfY29tcHV0ZSJECg1EaXNwbGF5",
            "RGV2aWNlEiAKDmVuYWJsZV9kaXNwbGF5GAEgASgIQgPgQQFIAIgBAUIRCg9f",
            "ZW5hYmxlX2Rpc3BsYXkihwEKEUFjY2VsZXJhdG9yQ29uZmlnEiIKEGFjY2Vs",
            "ZXJhdG9yX3R5cGUYASABKAlCA+BBAUgAiAEBEiMKEWFjY2VsZXJhdG9yX2Nv",
            "dW50GAIgASgFQgPgQQFIAYgBAUITChFfYWNjZWxlcmF0b3JfdHlwZUIUChJf",
            "YWNjZWxlcmF0b3JfY291bnQivAEKFUN1c3RvbWVyRW5jcnlwdGlvbktleRIW",
            "CgdyYXdfa2V5GAEgASgJQgPgQQFIABIgChFyc2FfZW5jcnlwdGVkX2tleRgC",
            "IAEoCUID4EEBSAASGwoMa21zX2tleV9uYW1lGAMgASgJQgPgQQFIABIpChdr",
            "bXNfa2V5X3NlcnZpY2VfYWNjb3VudBgEIAEoCUID4EEBSAGIAQFCBQoDa2V5",
            "QhoKGF9rbXNfa2V5X3NlcnZpY2VfYWNjb3VudCJJCgVFbnRyeRIVCgNrZXkY",
            "ASABKAlCA+BBAUgAiAEBEhcKBXZhbHVlGAIgASgJQgPgQQFIAYgBAUIGCgRf",
            "a2V5QggKBl92YWx1ZSI/CghNZXRhZGF0YRIzCgVpdGVtcxgBIAMoCzIfLmdv",
            "b2dsZS5jbG91ZC5iYWNrdXBkci52MS5FbnRyeUID4EEBIosJChBOZXR3b3Jr",
            "SW50ZXJmYWNlEhkKB25ldHdvcmsYASABKAlCA+BBAUgAiAEBEhwKCnN1Ym5l",
            "dHdvcmsYAiABKAlCA+BBAUgBiAEBEiQKCmlwX2FkZHJlc3MYAyABKAlCC+BB",
            "AeKMz9cIAggCSAKIAQESJgoMaXB2Nl9hZGRyZXNzGAQgASgJQgvgQQHijM/X",
            "CAIIA0gDiAEBEi0KG2ludGVybmFsX2lwdjZfcHJlZml4X2xlbmd0aBgFIAEo",
            "BUID4EEBSASIAQESFgoEbmFtZRgGIAEoCUID4EEDSAWIAQESQwoOYWNjZXNz",
            "X2NvbmZpZ3MYByADKAsyJi5nb29nbGUuY2xvdWQuYmFja3VwZHIudjEuQWNj",
            "ZXNzQ29uZmlnQgPgQQESSAoTaXB2Nl9hY2Nlc3NfY29uZmlncxgIIAMoCzIm",
            "Lmdvb2dsZS5jbG91ZC5iYWNrdXBkci52MS5BY2Nlc3NDb25maWdCA+BBARJE",
            "Cg9hbGlhc19pcF9yYW5nZXMYCSADKAsyJi5nb29nbGUuY2xvdWQuYmFja3Vw",
            "ZHIudjEuQWxpYXNJcFJhbmdlQgPgQQESTQoKc3RhY2tfdHlwZRgKIAEoDjI0",
            "Lmdvb2dsZS5jbG91ZC5iYWNrdXBkci52MS5OZXR3b3JrSW50ZXJmYWNlLlN0",
            "YWNrVHlwZUgGiAEBEl0KEGlwdjZfYWNjZXNzX3R5cGUYCyABKA4yOS5nb29n",
            "bGUuY2xvdWQuYmFja3VwZHIudjEuTmV0d29ya0ludGVyZmFjZS5JcHY2QWNj",
            "ZXNzVHlwZUID4EEBSAeIAQESHQoLcXVldWVfY291bnQYDCABKAVCA+BBAUgI",
            "iAEBEk4KCG5pY190eXBlGA0gASgOMjIuZ29vZ2xlLmNsb3VkLmJhY2t1cGRy",
            "LnYxLk5ldHdvcmtJbnRlcmZhY2UuTmljVHlwZUID4EEBSAmIAQESJAoSbmV0",
            "d29ya19hdHRhY2htZW50GA4gASgJQgPgQQFICogBASJFCglTdGFja1R5cGUS",
            "GgoWU1RBQ0tfVFlQRV9VTlNQRUNJRklFRBAAEg0KCUlQVjRfT05MWRABEg0K",
            "CUlQVjRfSVBWNhACIk4KDklwdjZBY2Nlc3NUeXBlEiAKHFVOU1BFQ0lGSUVE",
            "X0lQVjZfQUNDRVNTX1RZUEUQABIMCghJTlRFUk5BTBABEgwKCEVYVEVSTkFM",
            "EAIiPgoHTmljVHlwZRIYChROSUNfVFlQRV9VTlNQRUNJRklFRBAAEg4KClZJ",
            "UlRJT19ORVQQARIJCgVHVk5JQxACQgoKCF9uZXR3b3JrQg0KC19zdWJuZXR3",
            "b3JrQg0KC19pcF9hZGRyZXNzQg8KDV9pcHY2X2FkZHJlc3NCHgocX2ludGVy",
            "bmFsX2lwdjZfcHJlZml4X2xlbmd0aEIHCgVfbmFtZUINCgtfc3RhY2tfdHlw",
            "ZUITChFfaXB2Nl9hY2Nlc3NfdHlwZUIOCgxfcXVldWVfY291bnRCCwoJX25p",
            "Y190eXBlQhUKE19uZXR3b3JrX2F0dGFjaG1lbnQi2QEKGE5ldHdvcmtQZXJm",
            "b3JtYW5jZUNvbmZpZxJmCht0b3RhbF9lZ3Jlc3NfYmFuZHdpZHRoX3RpZXIY",
            "ASABKA4yNy5nb29nbGUuY2xvdWQuYmFja3VwZHIudjEuTmV0d29ya1BlcmZv",
            "cm1hbmNlQ29uZmlnLlRpZXJCA+BBAUgAiAEBIjUKBFRpZXISFAoQVElFUl9V",
            "TlNQRUNJRklFRBAAEgsKB0RFRkFVTFQQARIKCgZUSUVSXzEQAkIeChxfdG90",
            "YWxfZWdyZXNzX2JhbmR3aWR0aF90aWVyIqsFCgxBY2Nlc3NDb25maWcSSQoE",
            "dHlwZRgBIAEoDjIxLmdvb2dsZS5jbG91ZC5iYWNrdXBkci52MS5BY2Nlc3ND",
            "b25maWcuQWNjZXNzVHlwZUID4EEBSACIAQESFgoEbmFtZRgCIAEoCUID4EEB",
            "SAGIAQESHQoLZXh0ZXJuYWxfaXAYAyABKAlCA+BBAUgCiAEBEh8KDWV4dGVy",
            "bmFsX2lwdjYYBCABKAlCA+BBAUgDiAEBEi0KG2V4dGVybmFsX2lwdjZfcHJl",
            "Zml4X2xlbmd0aBgFIAEoBUID4EEBSASIAQESIAoOc2V0X3B1YmxpY19wdHIY",
            "BiABKAhCA+BBAUgFiAEBEigKFnB1YmxpY19wdHJfZG9tYWluX25hbWUYByAB",
            "KAlCA+BBAUgGiAEBElIKDG5ldHdvcmtfdGllchgIIAEoDjIyLmdvb2dsZS5j",
            "bG91ZC5iYWNrdXBkci52MS5BY2Nlc3NDb25maWcuTmV0d29ya1RpZXJCA+BB",
            "AUgHiAEBIk4KCkFjY2Vzc1R5cGUSGwoXQUNDRVNTX1RZUEVfVU5TUEVDSUZJ",
            "RUQQABISCg5PTkVfVE9fT05FX05BVBABEg8KC0RJUkVDVF9JUFY2EAIiRgoL",
            "TmV0d29ya1RpZXISHAoYTkVUV09SS19USUVSX1VOU1BFQ0lGSUVEEAASCwoH",
            "UFJFTUlVTRABEgwKCFNUQU5EQVJEEAJCBwoFX3R5cGVCBwoFX25hbWVCDgoM",
            "X2V4dGVybmFsX2lwQhAKDl9leHRlcm5hbF9pcHY2Qh4KHF9leHRlcm5hbF9p",
            "cHY2X3ByZWZpeF9sZW5ndGhCEQoPX3NldF9wdWJsaWNfcHRyQhkKF19wdWJs",
            "aWNfcHRyX2RvbWFpbl9uYW1lQg8KDV9uZXR3b3JrX3RpZXIihAEKDEFsaWFz",
            "SXBSYW5nZRIfCg1pcF9jaWRyX3JhbmdlGAEgASgJQgPgQQFIAIgBARInChVz",
            "dWJuZXR3b3JrX3JhbmdlX25hbWUYAiABKAlCA+BBAUgBiAEBQhAKDl9pcF9j",
            "aWRyX3JhbmdlQhgKFl9zdWJuZXR3b3JrX3JhbmdlX25hbWUiswEKDkluc3Rh",
            "bmNlUGFyYW1zEmUKFXJlc291cmNlX21hbmFnZXJfdGFncxgBIAMoCzJBLmdv",
            "b2dsZS5jbG91ZC5iYWNrdXBkci52MS5JbnN0YW5jZVBhcmFtcy5SZXNvdXJj",
            "ZU1hbmFnZXJUYWdzRW50cnlCA+BBARo6ChhSZXNvdXJjZU1hbmFnZXJUYWdz",
            "RW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASKjAgoSQWxs",
            "b2NhdGlvbkFmZmluaXR5ElwKF2NvbnN1bWVfYWxsb2NhdGlvbl90eXBlGAEg",
            "ASgOMjEuZ29vZ2xlLmNsb3VkLmJhY2t1cGRyLnYxLkFsbG9jYXRpb25BZmZp",
            "bml0eS5UeXBlQgPgQQFIAIgBARIVCgNrZXkYAiABKAlCA+BBAUgBiAEBEhMK",
            "BnZhbHVlcxgDIAMoCUID4EEBIl8KBFR5cGUSFAoQVFlQRV9VTlNQRUNJRklF",
            "RBAAEhIKDk5PX1JFU0VSVkFUSU9OEAESEwoPQU5ZX1JFU0VSVkFUSU9OEAIS",
            "GAoUU1BFQ0lGSUNfUkVTRVJWQVRJT04QA0IaChhfY29uc3VtZV9hbGxvY2F0",
            "aW9uX3R5cGVCBgoEX2tleSLcCQoKU2NoZWR1bGluZxJdChNvbl9ob3N0X21h",
            "aW50ZW5hbmNlGAEgASgOMjYuZ29vZ2xlLmNsb3VkLmJhY2t1cGRyLnYxLlNj",
            "aGVkdWxpbmcuT25Ib3N0TWFpbnRlbmFuY2VCA+BBAUgAiAEBEiMKEWF1dG9t",
            "YXRpY19yZXN0YXJ0GAIgASgIQgPgQQFIAYgBARIdCgtwcmVlbXB0aWJsZRgD",
            "IAEoCEID4EEBSAKIAQESTwoPbm9kZV9hZmZpbml0aWVzGAQgAygLMjEuZ29v",
            "Z2xlLmNsb3VkLmJhY2t1cGRyLnYxLlNjaGVkdWxpbmcuTm9kZUFmZmluaXR5",
            "QgPgQQESHwoNbWluX25vZGVfY3B1cxgFIAEoBUID4EEBSAOIAQESXAoScHJv",
            "dmlzaW9uaW5nX21vZGVsGAYgASgOMjYuZ29vZ2xlLmNsb3VkLmJhY2t1cGRy",
            "LnYxLlNjaGVkdWxpbmcuUHJvdmlzaW9uaW5nTW9kZWxCA+BBAUgEiAEBEm0K",
            "G2luc3RhbmNlX3Rlcm1pbmF0aW9uX2FjdGlvbhgHIAEoDjI+Lmdvb2dsZS5j",
            "bG91ZC5iYWNrdXBkci52MS5TY2hlZHVsaW5nLkluc3RhbmNlVGVybWluYXRp",
            "b25BY3Rpb25CA+BBAUgFiAEBEloKGmxvY2FsX3NzZF9yZWNvdmVyeV90aW1l",
            "b3V0GAogASgLMiwuZ29vZ2xlLmNsb3VkLmJhY2t1cGRyLnYxLlNjaGVkdWxp",
            "bmdEdXJhdGlvbkID4EEBSAaIAQEa4QEKDE5vZGVBZmZpbml0eRIVCgNrZXkY",
            "ASABKAlCA+BBAUgAiAEBElYKCG9wZXJhdG9yGAIgASgOMjouZ29vZ2xlLmNs",
            "b3VkLmJhY2t1cGRyLnYxLlNjaGVkdWxpbmcuTm9kZUFmZmluaXR5Lk9wZXJh",
            "dG9yQgPgQQFIAYgBARITCgZ2YWx1ZXMYAyADKAlCA+BBASI4CghPcGVyYXRv",
            "chIYChRPUEVSQVRPUl9VTlNQRUNJRklFRBAAEgYKAklOEAESCgoGTk9UX0lO",
            "EAJCBgoEX2tleUILCglfb3BlcmF0b3IiVQoRT25Ib3N0TWFpbnRlbmFuY2US",
            "IwofT05fSE9TVF9NQUlOVEVOQU5DRV9VTlNQRUNJRklFRBAAEg0KCVRFUk1J",
            "TkFURRABEgwKB01JR1JBVEUQ6AciTwoRUHJvdmlzaW9uaW5nTW9kZWwSIgoe",
            "UFJPVklTSU9OSU5HX01PREVMX1VOU1BFQ0lGSUVEEAASDAoIU1RBTkRBUkQQ",
            "ARIICgRTUE9UEAIiXgoZSW5zdGFuY2VUZXJtaW5hdGlvbkFjdGlvbhIrCidJ",
            "TlNUQU5DRV9URVJNSU5BVElPTl9BQ1RJT05fVU5TUEVDSUZJRUQQABIKCgZE",
            "RUxFVEUQARIICgRTVE9QEAJCFgoUX29uX2hvc3RfbWFpbnRlbmFuY2VCFAoS",
            "X2F1dG9tYXRpY19yZXN0YXJ0Qg4KDF9wcmVlbXB0aWJsZUIQCg5fbWluX25v",
            "ZGVfY3B1c0IVChNfcHJvdmlzaW9uaW5nX21vZGVsQh4KHF9pbnN0YW5jZV90",
            "ZXJtaW5hdGlvbl9hY3Rpb25CHQobX2xvY2FsX3NzZF9yZWNvdmVyeV90aW1l",
            "b3V0Il4KElNjaGVkdWxpbmdEdXJhdGlvbhIZCgdzZWNvbmRzGAEgASgDQgPg",
            "QQFIAIgBARIXCgVuYW5vcxgCIAEoBUID4EEBSAGIAQFCCgoIX3NlY29uZHNC",
            "CAoGX25hbm9zIkgKDlNlcnZpY2VBY2NvdW50EhcKBWVtYWlsGAEgASgJQgPg",
            "QQFIAIgBARITCgZzY29wZXMYAiADKAlCA+BBAUIICgZfZW1haWwiGgoEVGFn",
            "cxISCgVpdGVtcxgBIAMoCUID4EEBIpEMCgxBdHRhY2hlZERpc2sSXAoRaW5p",
            "dGlhbGl6ZV9wYXJhbXMYASABKAsyNy5nb29nbGUuY2xvdWQuYmFja3VwZHIu",
            "djEuQXR0YWNoZWREaXNrLkluaXRpYWxpemVQYXJhbXNCA+BBAUgAiAEBEh0K",
            "C2RldmljZV9uYW1lGAQgASgJQgPgQQFIAYgBARIWCgRraW5kGAUgASgJQgPg",
            "QQFIAogBARJWChRkaXNrX3R5cGVfZGVwcmVjYXRlZBgGIAEoDjIvLmdvb2ds",
            "ZS5jbG91ZC5iYWNrdXBkci52MS5BdHRhY2hlZERpc2suRGlza1R5cGVCAhgB",
            "SAOIAQESRwoEbW9kZRgHIAEoDjIvLmdvb2dsZS5jbG91ZC5iYWNrdXBkci52",
            "MS5BdHRhY2hlZERpc2suRGlza01vZGVCA+BBAUgEiAEBEhgKBnNvdXJjZRgI",
            "IAEoCUID4EEBSAWIAQESFwoFaW5kZXgYCSABKANCA+BBAUgGiAEBEhYKBGJv",
            "b3QYCiABKAhCA+BBAUgHiAEBEh0KC2F1dG9fZGVsZXRlGAsgASgIQgPgQQFI",
            "CIgBARIUCgdsaWNlbnNlGAwgAygJQgPgQQESVgoOZGlza19pbnRlcmZhY2UY",
            "DSABKA4yNC5nb29nbGUuY2xvdWQuYmFja3VwZHIudjEuQXR0YWNoZWREaXNr",
            "LkRpc2tJbnRlcmZhY2VCA+BBAUgJiAEBEkcKEGd1ZXN0X29zX2ZlYXR1cmUY",
            "DiADKAsyKC5nb29nbGUuY2xvdWQuYmFja3VwZHIudjEuR3Vlc3RPc0ZlYXR1",
            "cmVCA+BBARJWChNkaXNrX2VuY3J5cHRpb25fa2V5GA8gASgLMi8uZ29vZ2xl",
            "LmNsb3VkLmJhY2t1cGRyLnYxLkN1c3RvbWVyRW5jcnlwdGlvbktleUID4EEB",
            "SAqIAQESHgoMZGlza19zaXplX2diGBAgASgDQgPgQQFIC4gBARJXCgtzYXZl",
            "ZF9zdGF0ZRgRIAEoDjI1Lmdvb2dsZS5jbG91ZC5iYWNrdXBkci52MS5BdHRh",
            "Y2hlZERpc2suRGlza1NhdmVkU3RhdGVCBuBBAeBBA0gMiAEBEh4KCWRpc2tf",
            "dHlwZRgSIAEoCUIG4EEB4EEDSA2IAQESRwoEdHlwZRgTIAEoDjIvLmdvb2ds",
            "ZS5jbG91ZC5iYWNrdXBkci52MS5BdHRhY2hlZERpc2suRGlza1R5cGVCA+BB",
            "AUgOiAEBGlkKEEluaXRpYWxpemVQYXJhbXMSGwoJZGlza19uYW1lGAEgASgJ",
            "QgPgQQFIAIgBARIaCg1yZXBsaWNhX3pvbmVzGAIgAygJQgPgQQFCDAoKX2Rp",
            "c2tfbmFtZSJCCghEaXNrVHlwZRIZChVESVNLX1RZUEVfVU5TUEVDSUZJRUQQ",
            "ABILCgdTQ1JBVENIEAESDgoKUEVSU0lTVEVOVBACIlAKCERpc2tNb2RlEhkK",
            "FURJU0tfTU9ERV9VTlNQRUNJRklFRBAAEg4KClJFQURfV1JJVEUQARINCglS",
            "RUFEX09OTFkQAhIKCgZMT0NLRUQQAyJaCg1EaXNrSW50ZXJmYWNlEh4KGkRJ",
            "U0tfSU5URVJGQUNFX1VOU1BFQ0lGSUVEEAASCAoEU0NTSRABEggKBE5WTUUQ",
            "AhIKCgZOVkRJTU0QAxIJCgVJU0NTSRAEIkEKDkRpc2tTYXZlZFN0YXRlEiAK",
            "HERJU0tfU0FWRURfU1RBVEVfVU5TUEVDSUZJRUQQABINCglQUkVTRVJWRUQQ",
            "AUIUChJfaW5pdGlhbGl6ZV9wYXJhbXNCDgoMX2RldmljZV9uYW1lQgcKBV9r",
            "aW5kQhcKFV9kaXNrX3R5cGVfZGVwcmVjYXRlZEIHCgVfbW9kZUIJCgdfc291",
            "cmNlQggKBl9pbmRleEIHCgVfYm9vdEIOCgxfYXV0b19kZWxldGVCEQoPX2Rp",
            "c2tfaW50ZXJmYWNlQhYKFF9kaXNrX2VuY3J5cHRpb25fa2V5Qg8KDV9kaXNr",
            "X3NpemVfZ2JCDgoMX3NhdmVkX3N0YXRlQgwKCl9kaXNrX3R5cGVCBwoFX3R5",
            "cGUitQMKDkd1ZXN0T3NGZWF0dXJlEkcKBHR5cGUYASABKA4yNC5nb29nbGUu",
            "Y2xvdWQuYmFja3VwZHIudjEuR3Vlc3RPc0ZlYXR1cmUuRmVhdHVyZVR5cGVI",
            "AIgBASLQAgoLRmVhdHVyZVR5cGUSHAoYRkVBVFVSRV9UWVBFX1VOU1BFQ0lG",
            "SUVEEAASGgoWVklSVElPX1NDU0lfTVVMVElRVUVVRRABEgsKB1dJTkRPV1MQ",
            "AhITCg9NVUxUSV9JUF9TVUJORVQQAxITCg9VRUZJX0NPTVBBVElCTEUQBBIP",
            "CgtTRUNVUkVfQk9PVBAFEgkKBUdWTklDEAYSDwoLU0VWX0NBUEFCTEUQBxIf",
            "ChtCQVJFX01FVEFMX0xJTlVYX0NPTVBBVElCTEUQCBIdChlTVVNQRU5EX1JF",
            "U1VNRV9DT01QQVRJQkxFEAkSFwoTU0VWX0xJVkVfTUlHUkFUQUJMRRAKEhMK",
            "D1NFVl9TTlBfQ0FQQUJMRRALEg8KC1REWF9DQVBBQkxFEAwSCAoESURQRhAN",
            "EhoKFlNFVl9MSVZFX01JR1JBVEFCTEVfVjIQDkIHCgVfdHlwZSpZChdLZXlS",
            "ZXZvY2F0aW9uQWN0aW9uVHlwZRIqCiZLRVlfUkVWT0NBVElPTl9BQ1RJT05f",
            "VFlQRV9VTlNQRUNJRklFRBAAEggKBE5PTkUQARIICgRTVE9QEAJCwwEKHGNv",
            "bS5nb29nbGUuY2xvdWQuYmFja3VwZHIudjFCE0JhY2t1cHZhdWx0R2NlUHJv",
            "dG9QAVo4Y2xvdWQuZ29vZ2xlLmNvbS9nby9iYWNrdXBkci9hcGl2MS9iYWNr",
            "dXBkcnBiO2JhY2t1cGRycGKqAhhHb29nbGUuQ2xvdWQuQmFja3VwRFIuVjHK",
            "AhhHb29nbGVcQ2xvdWRcQmFja3VwRFJcVjHqAhtHb29nbGU6OkNsb3VkOjpC",
            "YWNrdXBEUjo6VjFiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.FieldBehaviorReflection.Descriptor, global::Google.Api.FieldInfoReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Google.Cloud.BackupDR.V1.KeyRevocationActionType), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.ComputeInstanceBackupProperties), global::Google.Cloud.BackupDR.V1.ComputeInstanceBackupProperties.Parser, new[]{ "Description", "Tags", "MachineType", "CanIpForward", "NetworkInterface", "Disk", "Metadata", "ServiceAccount", "Scheduling", "GuestAccelerator", "MinCpuPlatform", "KeyRevocationActionType", "SourceInstance", "Labels" }, new[]{ "Description", "Tags", "MachineType", "CanIpForward", "Metadata", "Scheduling", "MinCpuPlatform", "KeyRevocationActionType", "SourceInstance" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.ComputeInstanceRestoreProperties), global::Google.Cloud.BackupDR.V1.ComputeInstanceRestoreProperties.Parser, new[]{ "Name", "AdvancedMachineFeatures", "CanIpForward", "ConfidentialInstanceConfig", "DeletionProtection", "Description", "Disks", "DisplayDevice", "GuestAccelerators", "Hostname", "InstanceEncryptionKey", "KeyRevocationActionType", "Labels", "MachineType", "Metadata", "MinCpuPlatform", "NetworkInterfaces", "NetworkPerformanceConfig", "Params", "PrivateIpv6GoogleAccess", "AllocationAffinity", "ResourcePolicies", "Scheduling", "ServiceAccounts", "Tags" }, new[]{ "Name", "AdvancedMachineFeatures", "CanIpForward", "ConfidentialInstanceConfig", "DeletionProtection", "Description", "DisplayDevice", "Hostname", "InstanceEncryptionKey", "KeyRevocationActionType", "MachineType", "Metadata", "MinCpuPlatform", "NetworkPerformanceConfig", "Params", "PrivateIpv6GoogleAccess", "AllocationAffinity", "Scheduling", "Tags" }, new[]{ typeof(global::Google.Cloud.BackupDR.V1.ComputeInstanceRestoreProperties.Types.InstancePrivateIpv6GoogleAccess) }, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.ComputeInstanceTargetEnvironment), global::Google.Cloud.BackupDR.V1.ComputeInstanceTargetEnvironment.Parser, new[]{ "Project", "Zone" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.ComputeInstanceDataSourceProperties), global::Google.Cloud.BackupDR.V1.ComputeInstanceDataSourceProperties.Parser, new[]{ "Name", "Description", "MachineType", "TotalDiskCount", "TotalDiskSizeGb" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.AdvancedMachineFeatures), global::Google.Cloud.BackupDR.V1.AdvancedMachineFeatures.Parser, new[]{ "EnableNestedVirtualization", "ThreadsPerCore", "VisibleCoreCount", "EnableUefiNetworking" }, new[]{ "EnableNestedVirtualization", "ThreadsPerCore", "VisibleCoreCount", "EnableUefiNetworking" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.ConfidentialInstanceConfig), global::Google.Cloud.BackupDR.V1.ConfidentialInstanceConfig.Parser, new[]{ "EnableConfidentialCompute" }, new[]{ "EnableConfidentialCompute" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.DisplayDevice), global::Google.Cloud.BackupDR.V1.DisplayDevice.Parser, new[]{ "EnableDisplay" }, new[]{ "EnableDisplay" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.AcceleratorConfig), global::Google.Cloud.BackupDR.V1.AcceleratorConfig.Parser, new[]{ "AcceleratorType", "AcceleratorCount" }, new[]{ "AcceleratorType", "AcceleratorCount" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.CustomerEncryptionKey), global::Google.Cloud.BackupDR.V1.CustomerEncryptionKey.Parser, new[]{ "RawKey", "RsaEncryptedKey", "KmsKeyName", "KmsKeyServiceAccount" }, new[]{ "Key", "KmsKeyServiceAccount" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.Entry), global::Google.Cloud.BackupDR.V1.Entry.Parser, new[]{ "Key", "Value" }, new[]{ "Key", "Value" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.Metadata), global::Google.Cloud.BackupDR.V1.Metadata.Parser, new[]{ "Items" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.NetworkInterface), global::Google.Cloud.BackupDR.V1.NetworkInterface.Parser, new[]{ "Network", "Subnetwork", "IpAddress", "Ipv6Address", "InternalIpv6PrefixLength", "Name", "AccessConfigs", "Ipv6AccessConfigs", "AliasIpRanges", "StackType", "Ipv6AccessType", "QueueCount", "NicType", "NetworkAttachment" }, new[]{ "Network", "Subnetwork", "IpAddress", "Ipv6Address", "InternalIpv6PrefixLength", "Name", "StackType", "Ipv6AccessType", "QueueCount", "NicType", "NetworkAttachment" }, new[]{ typeof(global::Google.Cloud.BackupDR.V1.NetworkInterface.Types.StackType), typeof(global::Google.Cloud.BackupDR.V1.NetworkInterface.Types.Ipv6AccessType), typeof(global::Google.Cloud.BackupDR.V1.NetworkInterface.Types.NicType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.NetworkPerformanceConfig), global::Google.Cloud.BackupDR.V1.NetworkPerformanceConfig.Parser, new[]{ "TotalEgressBandwidthTier" }, new[]{ "TotalEgressBandwidthTier" }, new[]{ typeof(global::Google.Cloud.BackupDR.V1.NetworkPerformanceConfig.Types.Tier) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.AccessConfig), global::Google.Cloud.BackupDR.V1.AccessConfig.Parser, new[]{ "Type", "Name", "ExternalIp", "ExternalIpv6", "ExternalIpv6PrefixLength", "SetPublicPtr", "PublicPtrDomainName", "NetworkTier" }, new[]{ "Type", "Name", "ExternalIp", "ExternalIpv6", "ExternalIpv6PrefixLength", "SetPublicPtr", "PublicPtrDomainName", "NetworkTier" }, new[]{ typeof(global::Google.Cloud.BackupDR.V1.AccessConfig.Types.AccessType), typeof(global::Google.Cloud.BackupDR.V1.AccessConfig.Types.NetworkTier) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.AliasIpRange), global::Google.Cloud.BackupDR.V1.AliasIpRange.Parser, new[]{ "IpCidrRange", "SubnetworkRangeName" }, new[]{ "IpCidrRange", "SubnetworkRangeName" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.InstanceParams), global::Google.Cloud.BackupDR.V1.InstanceParams.Parser, new[]{ "ResourceManagerTags" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.AllocationAffinity), global::Google.Cloud.BackupDR.V1.AllocationAffinity.Parser, new[]{ "ConsumeAllocationType", "Key", "Values" }, new[]{ "ConsumeAllocationType", "Key" }, new[]{ typeof(global::Google.Cloud.BackupDR.V1.AllocationAffinity.Types.Type) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.Scheduling), global::Google.Cloud.BackupDR.V1.Scheduling.Parser, new[]{ "OnHostMaintenance", "AutomaticRestart", "Preemptible", "NodeAffinities", "MinNodeCpus", "ProvisioningModel", "InstanceTerminationAction", "LocalSsdRecoveryTimeout" }, new[]{ "OnHostMaintenance", "AutomaticRestart", "Preemptible", "MinNodeCpus", "ProvisioningModel", "InstanceTerminationAction", "LocalSsdRecoveryTimeout" }, new[]{ typeof(global::Google.Cloud.BackupDR.V1.Scheduling.Types.OnHostMaintenance), typeof(global::Google.Cloud.BackupDR.V1.Scheduling.Types.ProvisioningModel), typeof(global::Google.Cloud.BackupDR.V1.Scheduling.Types.InstanceTerminationAction) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.Scheduling.Types.NodeAffinity), global::Google.Cloud.BackupDR.V1.Scheduling.Types.NodeAffinity.Parser, new[]{ "Key", "Operator", "Values" }, new[]{ "Key", "Operator" }, new[]{ typeof(global::Google.Cloud.BackupDR.V1.Scheduling.Types.NodeAffinity.Types.Operator) }, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.SchedulingDuration), global::Google.Cloud.BackupDR.V1.SchedulingDuration.Parser, new[]{ "Seconds", "Nanos" }, new[]{ "Seconds", "Nanos" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.ServiceAccount), global::Google.Cloud.BackupDR.V1.ServiceAccount.Parser, new[]{ "Email", "Scopes" }, new[]{ "Email" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.Tags), global::Google.Cloud.BackupDR.V1.Tags.Parser, new[]{ "Items" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.AttachedDisk), global::Google.Cloud.BackupDR.V1.AttachedDisk.Parser, new[]{ "InitializeParams", "DeviceName", "Kind", "DiskTypeDeprecated", "Mode", "Source", "Index", "Boot", "AutoDelete", "License", "DiskInterface", "GuestOsFeature", "DiskEncryptionKey", "DiskSizeGb", "SavedState", "DiskType", "Type" }, new[]{ "InitializeParams", "DeviceName", "Kind", "DiskTypeDeprecated", "Mode", "Source", "Index", "Boot", "AutoDelete", "DiskInterface", "DiskEncryptionKey", "DiskSizeGb", "SavedState", "DiskType", "Type" }, new[]{ typeof(global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskType), typeof(global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskMode), typeof(global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskInterface), typeof(global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskSavedState) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.InitializeParams), global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.InitializeParams.Parser, new[]{ "DiskName", "ReplicaZones" }, new[]{ "DiskName" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.BackupDR.V1.GuestOsFeature), global::Google.Cloud.BackupDR.V1.GuestOsFeature.Parser, new[]{ "Type" }, new[]{ "Type" }, new[]{ typeof(global::Google.Cloud.BackupDR.V1.GuestOsFeature.Types.FeatureType) }, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// Specifies whether the virtual machine instance will be shut down on key
  /// revocation. It is currently used in instance, instance properties and GMI
  /// protos
  /// </summary>
  public enum KeyRevocationActionType {
    /// <summary>
    /// Default value. This value is unused.
    /// </summary>
    [pbr::OriginalName("KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// Indicates user chose no operation.
    /// </summary>
    [pbr::OriginalName("NONE")] None = 1,
    /// <summary>
    /// Indicates user chose to opt for VM shutdown on key revocation.
    /// </summary>
    [pbr::OriginalName("STOP")] Stop = 2,
  }

  #endregion

  #region Messages
  /// <summary>
  /// ComputeInstanceBackupProperties represents Compute Engine instance backup
  /// properties.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ComputeInstanceBackupProperties : pb::IMessage<ComputeInstanceBackupProperties>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ComputeInstanceBackupProperties> _parser = new pb::MessageParser<ComputeInstanceBackupProperties>(() => new ComputeInstanceBackupProperties());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ComputeInstanceBackupProperties> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.BackupDR.V1.BackupvaultGceReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ComputeInstanceBackupProperties() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ComputeInstanceBackupProperties(ComputeInstanceBackupProperties other) : this() {
      _hasBits0 = other._hasBits0;
      description_ = other.description_;
      tags_ = other.tags_ != null ? other.tags_.Clone() : null;
      machineType_ = other.machineType_;
      canIpForward_ = other.canIpForward_;
      networkInterface_ = other.networkInterface_.Clone();
      disk_ = other.disk_.Clone();
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      serviceAccount_ = other.serviceAccount_.Clone();
      scheduling_ = other.scheduling_ != null ? other.scheduling_.Clone() : null;
      guestAccelerator_ = other.guestAccelerator_.Clone();
      minCpuPlatform_ = other.minCpuPlatform_;
      keyRevocationActionType_ = other.keyRevocationActionType_;
      sourceInstance_ = other.sourceInstance_;
      labels_ = other.labels_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ComputeInstanceBackupProperties Clone() {
      return new ComputeInstanceBackupProperties(this);
    }

    /// <summary>Field number for the "description" field.</summary>
    public const int DescriptionFieldNumber = 1;
    private readonly static string DescriptionDefaultValue = "";

    private string description_;
    /// <summary>
    /// An optional text description for the instances that are created from these
    /// properties.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Description {
      get { return description_ ?? DescriptionDefaultValue; }
      set {
        description_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "description" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDescription {
      get { return description_ != null; }
    }
    /// <summary>Clears the value of the "description" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDescription() {
      description_ = null;
    }

    /// <summary>Field number for the "tags" field.</summary>
    public const int TagsFieldNumber = 2;
    private global::Google.Cloud.BackupDR.V1.Tags tags_;
    /// <summary>
    /// A list of tags to apply to the instances that are created from these
    /// properties. The tags identify valid sources or targets for network
    /// firewalls. The setTags method can modify this list of tags. Each tag within
    /// the list must comply with RFC1035 (https://www.ietf.org/rfc/rfc1035.txt).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.Tags Tags {
      get { return tags_; }
      set {
        tags_ = value;
      }
    }

    /// <summary>Field number for the "machine_type" field.</summary>
    public const int MachineTypeFieldNumber = 3;
    private readonly static string MachineTypeDefaultValue = "";

    private string machineType_;
    /// <summary>
    /// The machine type to use for instances that are created from these
    /// properties.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string MachineType {
      get { return machineType_ ?? MachineTypeDefaultValue; }
      set {
        machineType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "machine_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMachineType {
      get { return machineType_ != null; }
    }
    /// <summary>Clears the value of the "machine_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMachineType() {
      machineType_ = null;
    }

    /// <summary>Field number for the "can_ip_forward" field.</summary>
    public const int CanIpForwardFieldNumber = 4;
    private readonly static bool CanIpForwardDefaultValue = false;

    private bool canIpForward_;
    /// <summary>
    /// Enables instances created based on these properties to send packets with
    /// source IP addresses other than their own and receive packets with
    /// destination IP addresses other than their own. If these instances will be
    /// used as an IP gateway or it will be set as the next-hop in a Route
    /// resource, specify `true`. If unsure, leave this set to `false`. See the
    /// https://cloud.google.com/vpc/docs/using-routes#canipforward
    /// documentation for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool CanIpForward {
      get { if ((_hasBits0 & 1) != 0) { return canIpForward_; } else { return CanIpForwardDefaultValue; } }
      set {
        _hasBits0 |= 1;
        canIpForward_ = value;
      }
    }
    /// <summary>Gets whether the "can_ip_forward" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCanIpForward {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "can_ip_forward" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCanIpForward() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "network_interface" field.</summary>
    public const int NetworkInterfaceFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Google.Cloud.BackupDR.V1.NetworkInterface> _repeated_networkInterface_codec
        = pb::FieldCodec.ForMessage(42, global::Google.Cloud.BackupDR.V1.NetworkInterface.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.NetworkInterface> networkInterface_ = new pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.NetworkInterface>();
    /// <summary>
    /// An array of network access configurations for this interface.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.NetworkInterface> NetworkInterface {
      get { return networkInterface_; }
    }

    /// <summary>Field number for the "disk" field.</summary>
    public const int DiskFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Google.Cloud.BackupDR.V1.AttachedDisk> _repeated_disk_codec
        = pb::FieldCodec.ForMessage(50, global::Google.Cloud.BackupDR.V1.AttachedDisk.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.AttachedDisk> disk_ = new pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.AttachedDisk>();
    /// <summary>
    /// An array of disks that are associated with the instances that are created
    /// from these properties.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.AttachedDisk> Disk {
      get { return disk_; }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 7;
    private global::Google.Cloud.BackupDR.V1.Metadata metadata_;
    /// <summary>
    /// The metadata key/value pairs to assign to instances that are created from
    /// these properties. These pairs can consist of custom metadata or predefined
    /// keys. See https://cloud.google.com/compute/docs/metadata/overview for more
    /// information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "service_account" field.</summary>
    public const int ServiceAccountFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Google.Cloud.BackupDR.V1.ServiceAccount> _repeated_serviceAccount_codec
        = pb::FieldCodec.ForMessage(66, global::Google.Cloud.BackupDR.V1.ServiceAccount.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.ServiceAccount> serviceAccount_ = new pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.ServiceAccount>();
    /// <summary>
    /// A list of service accounts with specified scopes. Access tokens for these
    /// service accounts are available to the instances that are created from
    /// these properties. Use metadata queries to obtain the access tokens for
    /// these instances.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.ServiceAccount> ServiceAccount {
      get { return serviceAccount_; }
    }

    /// <summary>Field number for the "scheduling" field.</summary>
    public const int SchedulingFieldNumber = 9;
    private global::Google.Cloud.BackupDR.V1.Scheduling scheduling_;
    /// <summary>
    /// Specifies the scheduling options for the instances that are created from
    /// these properties.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.Scheduling Scheduling {
      get { return scheduling_; }
      set {
        scheduling_ = value;
      }
    }

    /// <summary>Field number for the "guest_accelerator" field.</summary>
    public const int GuestAcceleratorFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Google.Cloud.BackupDR.V1.AcceleratorConfig> _repeated_guestAccelerator_codec
        = pb::FieldCodec.ForMessage(82, global::Google.Cloud.BackupDR.V1.AcceleratorConfig.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.AcceleratorConfig> guestAccelerator_ = new pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.AcceleratorConfig>();
    /// <summary>
    /// A list of guest accelerator cards' type and count to use for instances
    /// created from these properties.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.AcceleratorConfig> GuestAccelerator {
      get { return guestAccelerator_; }
    }

    /// <summary>Field number for the "min_cpu_platform" field.</summary>
    public const int MinCpuPlatformFieldNumber = 11;
    private readonly static string MinCpuPlatformDefaultValue = "";

    private string minCpuPlatform_;
    /// <summary>
    /// Minimum cpu/platform to be used by instances. The instance may be
    /// scheduled on the specified or newer cpu/platform. Applicable values are the
    /// friendly names of CPU platforms, such as
    /// `minCpuPlatform: Intel Haswell` or `minCpuPlatform: Intel Sandy Bridge`.
    /// For more information, read
    /// https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string MinCpuPlatform {
      get { return minCpuPlatform_ ?? MinCpuPlatformDefaultValue; }
      set {
        minCpuPlatform_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "min_cpu_platform" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinCpuPlatform {
      get { return minCpuPlatform_ != null; }
    }
    /// <summary>Clears the value of the "min_cpu_platform" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinCpuPlatform() {
      minCpuPlatform_ = null;
    }

    /// <summary>Field number for the "key_revocation_action_type" field.</summary>
    public const int KeyRevocationActionTypeFieldNumber = 12;
    private readonly static global::Google.Cloud.BackupDR.V1.KeyRevocationActionType KeyRevocationActionTypeDefaultValue = global::Google.Cloud.BackupDR.V1.KeyRevocationActionType.Unspecified;

    private global::Google.Cloud.BackupDR.V1.KeyRevocationActionType keyRevocationActionType_;
    /// <summary>
    /// KeyRevocationActionType of the instance. Supported options are "STOP" and
    /// "NONE". The default value is "NONE" if it is not specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.KeyRevocationActionType KeyRevocationActionType {
      get { if ((_hasBits0 & 2) != 0) { return keyRevocationActionType_; } else { return KeyRevocationActionTypeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        keyRevocationActionType_ = value;
      }
    }
    /// <summary>Gets whether the "key_revocation_action_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKeyRevocationActionType {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "key_revocation_action_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKeyRevocationActionType() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "source_instance" field.</summary>
    public const int SourceInstanceFieldNumber = 13;
    private readonly static string SourceInstanceDefaultValue = "";

    private string sourceInstance_;
    /// <summary>
    /// The source instance used to create this backup. This can be a partial or
    /// full URL to the resource. For example, the following are valid values:
    ///   -https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance
    ///   -projects/project/zones/zone/instances/instance
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SourceInstance {
      get { return sourceInstance_ ?? SourceInstanceDefaultValue; }
      set {
        sourceInstance_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "source_instance" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSourceInstance {
      get { return sourceInstance_ != null; }
    }
    /// <summary>Clears the value of the "source_instance" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSourceInstance() {
      sourceInstance_ = null;
    }

    /// <summary>Field number for the "labels" field.</summary>
    public const int LabelsFieldNumber = 14;
    private static readonly pbc::MapField<string, string>.Codec _map_labels_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 114);
    private readonly pbc::MapField<string, string> labels_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Labels to apply to instances that are created from these properties.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, string> Labels {
      get { return labels_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ComputeInstanceBackupProperties);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ComputeInstanceBackupProperties other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Description != other.Description) return false;
      if (!object.Equals(Tags, other.Tags)) return false;
      if (MachineType != other.MachineType) return false;
      if (CanIpForward != other.CanIpForward) return false;
      if(!networkInterface_.Equals(other.networkInterface_)) return false;
      if(!disk_.Equals(other.disk_)) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!serviceAccount_.Equals(other.serviceAccount_)) return false;
      if (!object.Equals(Scheduling, other.Scheduling)) return false;
      if(!guestAccelerator_.Equals(other.guestAccelerator_)) return false;
      if (MinCpuPlatform != other.MinCpuPlatform) return false;
      if (KeyRevocationActionType != other.KeyRevocationActionType) return false;
      if (SourceInstance != other.SourceInstance) return false;
      if (!Labels.Equals(other.Labels)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasDescription) hash ^= Description.GetHashCode();
      if (tags_ != null) hash ^= Tags.GetHashCode();
      if (HasMachineType) hash ^= MachineType.GetHashCode();
      if (HasCanIpForward) hash ^= CanIpForward.GetHashCode();
      hash ^= networkInterface_.GetHashCode();
      hash ^= disk_.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= serviceAccount_.GetHashCode();
      if (scheduling_ != null) hash ^= Scheduling.GetHashCode();
      hash ^= guestAccelerator_.GetHashCode();
      if (HasMinCpuPlatform) hash ^= MinCpuPlatform.GetHashCode();
      if (HasKeyRevocationActionType) hash ^= KeyRevocationActionType.GetHashCode();
      if (HasSourceInstance) hash ^= SourceInstance.GetHashCode();
      hash ^= Labels.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasDescription) {
        output.WriteRawTag(10);
        output.WriteString(Description);
      }
      if (tags_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Tags);
      }
      if (HasMachineType) {
        output.WriteRawTag(26);
        output.WriteString(MachineType);
      }
      if (HasCanIpForward) {
        output.WriteRawTag(32);
        output.WriteBool(CanIpForward);
      }
      networkInterface_.WriteTo(output, _repeated_networkInterface_codec);
      disk_.WriteTo(output, _repeated_disk_codec);
      if (metadata_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Metadata);
      }
      serviceAccount_.WriteTo(output, _repeated_serviceAccount_codec);
      if (scheduling_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(Scheduling);
      }
      guestAccelerator_.WriteTo(output, _repeated_guestAccelerator_codec);
      if (HasMinCpuPlatform) {
        output.WriteRawTag(90);
        output.WriteString(MinCpuPlatform);
      }
      if (HasKeyRevocationActionType) {
        output.WriteRawTag(96);
        output.WriteEnum((int) KeyRevocationActionType);
      }
      if (HasSourceInstance) {
        output.WriteRawTag(106);
        output.WriteString(SourceInstance);
      }
      labels_.WriteTo(output, _map_labels_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasDescription) {
        output.WriteRawTag(10);
        output.WriteString(Description);
      }
      if (tags_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Tags);
      }
      if (HasMachineType) {
        output.WriteRawTag(26);
        output.WriteString(MachineType);
      }
      if (HasCanIpForward) {
        output.WriteRawTag(32);
        output.WriteBool(CanIpForward);
      }
      networkInterface_.WriteTo(ref output, _repeated_networkInterface_codec);
      disk_.WriteTo(ref output, _repeated_disk_codec);
      if (metadata_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Metadata);
      }
      serviceAccount_.WriteTo(ref output, _repeated_serviceAccount_codec);
      if (scheduling_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(Scheduling);
      }
      guestAccelerator_.WriteTo(ref output, _repeated_guestAccelerator_codec);
      if (HasMinCpuPlatform) {
        output.WriteRawTag(90);
        output.WriteString(MinCpuPlatform);
      }
      if (HasKeyRevocationActionType) {
        output.WriteRawTag(96);
        output.WriteEnum((int) KeyRevocationActionType);
      }
      if (HasSourceInstance) {
        output.WriteRawTag(106);
        output.WriteString(SourceInstance);
      }
      labels_.WriteTo(ref output, _map_labels_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasDescription) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Description);
      }
      if (tags_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Tags);
      }
      if (HasMachineType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MachineType);
      }
      if (HasCanIpForward) {
        size += 1 + 1;
      }
      size += networkInterface_.CalculateSize(_repeated_networkInterface_codec);
      size += disk_.CalculateSize(_repeated_disk_codec);
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += serviceAccount_.CalculateSize(_repeated_serviceAccount_codec);
      if (scheduling_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Scheduling);
      }
      size += guestAccelerator_.CalculateSize(_repeated_guestAccelerator_codec);
      if (HasMinCpuPlatform) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MinCpuPlatform);
      }
      if (HasKeyRevocationActionType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) KeyRevocationActionType);
      }
      if (HasSourceInstance) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SourceInstance);
      }
      size += labels_.CalculateSize(_map_labels_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ComputeInstanceBackupProperties other) {
      if (other == null) {
        return;
      }
      if (other.HasDescription) {
        Description = other.Description;
      }
      if (other.tags_ != null) {
        if (tags_ == null) {
          Tags = new global::Google.Cloud.BackupDR.V1.Tags();
        }
        Tags.MergeFrom(other.Tags);
      }
      if (other.HasMachineType) {
        MachineType = other.MachineType;
      }
      if (other.HasCanIpForward) {
        CanIpForward = other.CanIpForward;
      }
      networkInterface_.Add(other.networkInterface_);
      disk_.Add(other.disk_);
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::Google.Cloud.BackupDR.V1.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      serviceAccount_.Add(other.serviceAccount_);
      if (other.scheduling_ != null) {
        if (scheduling_ == null) {
          Scheduling = new global::Google.Cloud.BackupDR.V1.Scheduling();
        }
        Scheduling.MergeFrom(other.Scheduling);
      }
      guestAccelerator_.Add(other.guestAccelerator_);
      if (other.HasMinCpuPlatform) {
        MinCpuPlatform = other.MinCpuPlatform;
      }
      if (other.HasKeyRevocationActionType) {
        KeyRevocationActionType = other.KeyRevocationActionType;
      }
      if (other.HasSourceInstance) {
        SourceInstance = other.SourceInstance;
      }
      labels_.MergeFrom(other.labels_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Description = input.ReadString();
            break;
          }
          case 18: {
            if (tags_ == null) {
              Tags = new global::Google.Cloud.BackupDR.V1.Tags();
            }
            input.ReadMessage(Tags);
            break;
          }
          case 26: {
            MachineType = input.ReadString();
            break;
          }
          case 32: {
            CanIpForward = input.ReadBool();
            break;
          }
          case 42: {
            networkInterface_.AddEntriesFrom(input, _repeated_networkInterface_codec);
            break;
          }
          case 50: {
            disk_.AddEntriesFrom(input, _repeated_disk_codec);
            break;
          }
          case 58: {
            if (metadata_ == null) {
              Metadata = new global::Google.Cloud.BackupDR.V1.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 66: {
            serviceAccount_.AddEntriesFrom(input, _repeated_serviceAccount_codec);
            break;
          }
          case 74: {
            if (scheduling_ == null) {
              Scheduling = new global::Google.Cloud.BackupDR.V1.Scheduling();
            }
            input.ReadMessage(Scheduling);
            break;
          }
          case 82: {
            guestAccelerator_.AddEntriesFrom(input, _repeated_guestAccelerator_codec);
            break;
          }
          case 90: {
            MinCpuPlatform = input.ReadString();
            break;
          }
          case 96: {
            KeyRevocationActionType = (global::Google.Cloud.BackupDR.V1.KeyRevocationActionType) input.ReadEnum();
            break;
          }
          case 106: {
            SourceInstance = input.ReadString();
            break;
          }
          case 114: {
            labels_.AddEntriesFrom(input, _map_labels_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Description = input.ReadString();
            break;
          }
          case 18: {
            if (tags_ == null) {
              Tags = new global::Google.Cloud.BackupDR.V1.Tags();
            }
            input.ReadMessage(Tags);
            break;
          }
          case 26: {
            MachineType = input.ReadString();
            break;
          }
          case 32: {
            CanIpForward = input.ReadBool();
            break;
          }
          case 42: {
            networkInterface_.AddEntriesFrom(ref input, _repeated_networkInterface_codec);
            break;
          }
          case 50: {
            disk_.AddEntriesFrom(ref input, _repeated_disk_codec);
            break;
          }
          case 58: {
            if (metadata_ == null) {
              Metadata = new global::Google.Cloud.BackupDR.V1.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 66: {
            serviceAccount_.AddEntriesFrom(ref input, _repeated_serviceAccount_codec);
            break;
          }
          case 74: {
            if (scheduling_ == null) {
              Scheduling = new global::Google.Cloud.BackupDR.V1.Scheduling();
            }
            input.ReadMessage(Scheduling);
            break;
          }
          case 82: {
            guestAccelerator_.AddEntriesFrom(ref input, _repeated_guestAccelerator_codec);
            break;
          }
          case 90: {
            MinCpuPlatform = input.ReadString();
            break;
          }
          case 96: {
            KeyRevocationActionType = (global::Google.Cloud.BackupDR.V1.KeyRevocationActionType) input.ReadEnum();
            break;
          }
          case 106: {
            SourceInstance = input.ReadString();
            break;
          }
          case 114: {
            labels_.AddEntriesFrom(ref input, _map_labels_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ComputeInstanceRestoreProperties represents Compute Engine instance
  /// properties to be overridden during restore.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ComputeInstanceRestoreProperties : pb::IMessage<ComputeInstanceRestoreProperties>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ComputeInstanceRestoreProperties> _parser = new pb::MessageParser<ComputeInstanceRestoreProperties>(() => new ComputeInstanceRestoreProperties());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ComputeInstanceRestoreProperties> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.BackupDR.V1.BackupvaultGceReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ComputeInstanceRestoreProperties() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ComputeInstanceRestoreProperties(ComputeInstanceRestoreProperties other) : this() {
      _hasBits0 = other._hasBits0;
      name_ = other.name_;
      advancedMachineFeatures_ = other.advancedMachineFeatures_ != null ? other.advancedMachineFeatures_.Clone() : null;
      canIpForward_ = other.canIpForward_;
      confidentialInstanceConfig_ = other.confidentialInstanceConfig_ != null ? other.confidentialInstanceConfig_.Clone() : null;
      deletionProtection_ = other.deletionProtection_;
      description_ = other.description_;
      disks_ = other.disks_.Clone();
      displayDevice_ = other.displayDevice_ != null ? other.displayDevice_.Clone() : null;
      guestAccelerators_ = other.guestAccelerators_.Clone();
      hostname_ = other.hostname_;
      instanceEncryptionKey_ = other.instanceEncryptionKey_ != null ? other.instanceEncryptionKey_.Clone() : null;
      keyRevocationActionType_ = other.keyRevocationActionType_;
      labels_ = other.labels_.Clone();
      machineType_ = other.machineType_;
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      minCpuPlatform_ = other.minCpuPlatform_;
      networkInterfaces_ = other.networkInterfaces_.Clone();
      networkPerformanceConfig_ = other.networkPerformanceConfig_ != null ? other.networkPerformanceConfig_.Clone() : null;
      params_ = other.params_ != null ? other.params_.Clone() : null;
      privateIpv6GoogleAccess_ = other.privateIpv6GoogleAccess_;
      allocationAffinity_ = other.allocationAffinity_ != null ? other.allocationAffinity_.Clone() : null;
      resourcePolicies_ = other.resourcePolicies_.Clone();
      scheduling_ = other.scheduling_ != null ? other.scheduling_.Clone() : null;
      serviceAccounts_ = other.serviceAccounts_.Clone();
      tags_ = other.tags_ != null ? other.tags_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ComputeInstanceRestoreProperties Clone() {
      return new ComputeInstanceRestoreProperties(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// Required. Name of the compute instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "advanced_machine_features" field.</summary>
    public const int AdvancedMachineFeaturesFieldNumber = 2;
    private global::Google.Cloud.BackupDR.V1.AdvancedMachineFeatures advancedMachineFeatures_;
    /// <summary>
    /// Optional. Controls for advanced machine-related behavior features.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.AdvancedMachineFeatures AdvancedMachineFeatures {
      get { return advancedMachineFeatures_; }
      set {
        advancedMachineFeatures_ = value;
      }
    }

    /// <summary>Field number for the "can_ip_forward" field.</summary>
    public const int CanIpForwardFieldNumber = 3;
    private readonly static bool CanIpForwardDefaultValue = false;

    private bool canIpForward_;
    /// <summary>
    /// Optional. Allows this instance to send and receive packets with
    /// non-matching destination or source IPs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool CanIpForward {
      get { if ((_hasBits0 & 1) != 0) { return canIpForward_; } else { return CanIpForwardDefaultValue; } }
      set {
        _hasBits0 |= 1;
        canIpForward_ = value;
      }
    }
    /// <summary>Gets whether the "can_ip_forward" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCanIpForward {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "can_ip_forward" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCanIpForward() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "confidential_instance_config" field.</summary>
    public const int ConfidentialInstanceConfigFieldNumber = 4;
    private global::Google.Cloud.BackupDR.V1.ConfidentialInstanceConfig confidentialInstanceConfig_;
    /// <summary>
    /// Optional. Controls Confidential compute options on the instance
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.ConfidentialInstanceConfig ConfidentialInstanceConfig {
      get { return confidentialInstanceConfig_; }
      set {
        confidentialInstanceConfig_ = value;
      }
    }

    /// <summary>Field number for the "deletion_protection" field.</summary>
    public const int DeletionProtectionFieldNumber = 5;
    private readonly static bool DeletionProtectionDefaultValue = false;

    private bool deletionProtection_;
    /// <summary>
    /// Optional. Whether the resource should be protected against deletion.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool DeletionProtection {
      get { if ((_hasBits0 & 2) != 0) { return deletionProtection_; } else { return DeletionProtectionDefaultValue; } }
      set {
        _hasBits0 |= 2;
        deletionProtection_ = value;
      }
    }
    /// <summary>Gets whether the "deletion_protection" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDeletionProtection {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "deletion_protection" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDeletionProtection() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "description" field.</summary>
    public const int DescriptionFieldNumber = 6;
    private readonly static string DescriptionDefaultValue = "";

    private string description_;
    /// <summary>
    /// Optional. An optional description of this resource. Provide this property
    /// when you create the resource.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Description {
      get { return description_ ?? DescriptionDefaultValue; }
      set {
        description_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "description" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDescription {
      get { return description_ != null; }
    }
    /// <summary>Clears the value of the "description" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDescription() {
      description_ = null;
    }

    /// <summary>Field number for the "disks" field.</summary>
    public const int DisksFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Google.Cloud.BackupDR.V1.AttachedDisk> _repeated_disks_codec
        = pb::FieldCodec.ForMessage(58, global::Google.Cloud.BackupDR.V1.AttachedDisk.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.AttachedDisk> disks_ = new pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.AttachedDisk>();
    /// <summary>
    /// Optional. Array of disks associated with this instance. Persistent disks
    /// must be created before you can assign them.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.AttachedDisk> Disks {
      get { return disks_; }
    }

    /// <summary>Field number for the "display_device" field.</summary>
    public const int DisplayDeviceFieldNumber = 8;
    private global::Google.Cloud.BackupDR.V1.DisplayDevice displayDevice_;
    /// <summary>
    /// Optional. Enables display device for the instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.DisplayDevice DisplayDevice {
      get { return displayDevice_; }
      set {
        displayDevice_ = value;
      }
    }

    /// <summary>Field number for the "guest_accelerators" field.</summary>
    public const int GuestAcceleratorsFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Google.Cloud.BackupDR.V1.AcceleratorConfig> _repeated_guestAccelerators_codec
        = pb::FieldCodec.ForMessage(74, global::Google.Cloud.BackupDR.V1.AcceleratorConfig.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.AcceleratorConfig> guestAccelerators_ = new pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.AcceleratorConfig>();
    /// <summary>
    /// Optional. A list of the type and count of accelerator cards attached to the
    /// instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.AcceleratorConfig> GuestAccelerators {
      get { return guestAccelerators_; }
    }

    /// <summary>Field number for the "hostname" field.</summary>
    public const int HostnameFieldNumber = 10;
    private readonly static string HostnameDefaultValue = "";

    private string hostname_;
    /// <summary>
    /// Optional. Specifies the hostname of the instance. The specified hostname
    /// must be RFC1035 compliant. If hostname is not specified, the default
    /// hostname is [INSTANCE_NAME].c.[PROJECT_ID].internal when using the global
    /// DNS, and [INSTANCE_NAME].[ZONE].c.[PROJECT_ID].internal when using zonal
    /// DNS.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Hostname {
      get { return hostname_ ?? HostnameDefaultValue; }
      set {
        hostname_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "hostname" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHostname {
      get { return hostname_ != null; }
    }
    /// <summary>Clears the value of the "hostname" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHostname() {
      hostname_ = null;
    }

    /// <summary>Field number for the "instance_encryption_key" field.</summary>
    public const int InstanceEncryptionKeyFieldNumber = 11;
    private global::Google.Cloud.BackupDR.V1.CustomerEncryptionKey instanceEncryptionKey_;
    /// <summary>
    /// Optional. Encrypts suspended data for an instance with a
    /// customer-managed encryption key.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.CustomerEncryptionKey InstanceEncryptionKey {
      get { return instanceEncryptionKey_; }
      set {
        instanceEncryptionKey_ = value;
      }
    }

    /// <summary>Field number for the "key_revocation_action_type" field.</summary>
    public const int KeyRevocationActionTypeFieldNumber = 12;
    private readonly static global::Google.Cloud.BackupDR.V1.KeyRevocationActionType KeyRevocationActionTypeDefaultValue = global::Google.Cloud.BackupDR.V1.KeyRevocationActionType.Unspecified;

    private global::Google.Cloud.BackupDR.V1.KeyRevocationActionType keyRevocationActionType_;
    /// <summary>
    /// Optional. KeyRevocationActionType of the instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.KeyRevocationActionType KeyRevocationActionType {
      get { if ((_hasBits0 & 4) != 0) { return keyRevocationActionType_; } else { return KeyRevocationActionTypeDefaultValue; } }
      set {
        _hasBits0 |= 4;
        keyRevocationActionType_ = value;
      }
    }
    /// <summary>Gets whether the "key_revocation_action_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKeyRevocationActionType {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "key_revocation_action_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKeyRevocationActionType() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "labels" field.</summary>
    public const int LabelsFieldNumber = 13;
    private static readonly pbc::MapField<string, string>.Codec _map_labels_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 106);
    private readonly pbc::MapField<string, string> labels_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Optional. Labels to apply to this instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, string> Labels {
      get { return labels_; }
    }

    /// <summary>Field number for the "machine_type" field.</summary>
    public const int MachineTypeFieldNumber = 14;
    private readonly static string MachineTypeDefaultValue = "";

    private string machineType_;
    /// <summary>
    /// Optional. Full or partial URL of the machine type resource to use for this
    /// instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string MachineType {
      get { return machineType_ ?? MachineTypeDefaultValue; }
      set {
        machineType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "machine_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMachineType {
      get { return machineType_ != null; }
    }
    /// <summary>Clears the value of the "machine_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMachineType() {
      machineType_ = null;
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 15;
    private global::Google.Cloud.BackupDR.V1.Metadata metadata_;
    /// <summary>
    /// Optional. This includes custom metadata and predefined keys.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "min_cpu_platform" field.</summary>
    public const int MinCpuPlatformFieldNumber = 16;
    private readonly static string MinCpuPlatformDefaultValue = "";

    private string minCpuPlatform_;
    /// <summary>
    /// Optional. Minimum CPU platform to use for this instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string MinCpuPlatform {
      get { return minCpuPlatform_ ?? MinCpuPlatformDefaultValue; }
      set {
        minCpuPlatform_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "min_cpu_platform" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinCpuPlatform {
      get { return minCpuPlatform_ != null; }
    }
    /// <summary>Clears the value of the "min_cpu_platform" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinCpuPlatform() {
      minCpuPlatform_ = null;
    }

    /// <summary>Field number for the "network_interfaces" field.</summary>
    public const int NetworkInterfacesFieldNumber = 17;
    private static readonly pb::FieldCodec<global::Google.Cloud.BackupDR.V1.NetworkInterface> _repeated_networkInterfaces_codec
        = pb::FieldCodec.ForMessage(138, global::Google.Cloud.BackupDR.V1.NetworkInterface.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.NetworkInterface> networkInterfaces_ = new pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.NetworkInterface>();
    /// <summary>
    /// Optional. An array of network configurations for this instance. These
    /// specify how interfaces are configured to interact with other network
    /// services, such as connecting to the internet. Multiple interfaces are
    /// supported per instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.NetworkInterface> NetworkInterfaces {
      get { return networkInterfaces_; }
    }

    /// <summary>Field number for the "network_performance_config" field.</summary>
    public const int NetworkPerformanceConfigFieldNumber = 18;
    private global::Google.Cloud.BackupDR.V1.NetworkPerformanceConfig networkPerformanceConfig_;
    /// <summary>
    /// Optional. Configure network performance such as egress bandwidth tier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.NetworkPerformanceConfig NetworkPerformanceConfig {
      get { return networkPerformanceConfig_; }
      set {
        networkPerformanceConfig_ = value;
      }
    }

    /// <summary>Field number for the "params" field.</summary>
    public const int ParamsFieldNumber = 19;
    private global::Google.Cloud.BackupDR.V1.InstanceParams params_;
    /// <summary>
    /// Input only. Additional params passed with the request, but not persisted
    /// as part of resource payload.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.InstanceParams Params {
      get { return params_; }
      set {
        params_ = value;
      }
    }

    /// <summary>Field number for the "private_ipv6_google_access" field.</summary>
    public const int PrivateIpv6GoogleAccessFieldNumber = 20;
    private readonly static global::Google.Cloud.BackupDR.V1.ComputeInstanceRestoreProperties.Types.InstancePrivateIpv6GoogleAccess PrivateIpv6GoogleAccessDefaultValue = global::Google.Cloud.BackupDR.V1.ComputeInstanceRestoreProperties.Types.InstancePrivateIpv6GoogleAccess.Unspecified;

    private global::Google.Cloud.BackupDR.V1.ComputeInstanceRestoreProperties.Types.InstancePrivateIpv6GoogleAccess privateIpv6GoogleAccess_;
    /// <summary>
    /// Optional. The private IPv6 google access type for the VM.
    /// If not specified, use INHERIT_FROM_SUBNETWORK as default.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.ComputeInstanceRestoreProperties.Types.InstancePrivateIpv6GoogleAccess PrivateIpv6GoogleAccess {
      get { if ((_hasBits0 & 8) != 0) { return privateIpv6GoogleAccess_; } else { return PrivateIpv6GoogleAccessDefaultValue; } }
      set {
        _hasBits0 |= 8;
        privateIpv6GoogleAccess_ = value;
      }
    }
    /// <summary>Gets whether the "private_ipv6_google_access" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPrivateIpv6GoogleAccess {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "private_ipv6_google_access" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPrivateIpv6GoogleAccess() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "allocation_affinity" field.</summary>
    public const int AllocationAffinityFieldNumber = 21;
    private global::Google.Cloud.BackupDR.V1.AllocationAffinity allocationAffinity_;
    /// <summary>
    /// Optional. Specifies the reservations that this instance can consume from.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.AllocationAffinity AllocationAffinity {
      get { return allocationAffinity_; }
      set {
        allocationAffinity_ = value;
      }
    }

    /// <summary>Field number for the "resource_policies" field.</summary>
    public const int ResourcePoliciesFieldNumber = 22;
    private static readonly pb::FieldCodec<string> _repeated_resourcePolicies_codec
        = pb::FieldCodec.ForString(178);
    private readonly pbc::RepeatedField<string> resourcePolicies_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Optional. Resource policies applied to this instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> ResourcePolicies {
      get { return resourcePolicies_; }
    }

    /// <summary>Field number for the "scheduling" field.</summary>
    public const int SchedulingFieldNumber = 23;
    private global::Google.Cloud.BackupDR.V1.Scheduling scheduling_;
    /// <summary>
    /// Optional. Sets the scheduling options for this instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.Scheduling Scheduling {
      get { return scheduling_; }
      set {
        scheduling_ = value;
      }
    }

    /// <summary>Field number for the "service_accounts" field.</summary>
    public const int ServiceAccountsFieldNumber = 24;
    private static readonly pb::FieldCodec<global::Google.Cloud.BackupDR.V1.ServiceAccount> _repeated_serviceAccounts_codec
        = pb::FieldCodec.ForMessage(194, global::Google.Cloud.BackupDR.V1.ServiceAccount.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.ServiceAccount> serviceAccounts_ = new pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.ServiceAccount>();
    /// <summary>
    /// Optional. A list of service accounts, with their specified scopes,
    /// authorized for this instance. Only one service account per VM instance is
    /// supported.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.ServiceAccount> ServiceAccounts {
      get { return serviceAccounts_; }
    }

    /// <summary>Field number for the "tags" field.</summary>
    public const int TagsFieldNumber = 26;
    private global::Google.Cloud.BackupDR.V1.Tags tags_;
    /// <summary>
    /// Optional. Tags to apply to this instance. Tags are used to identify valid
    /// sources or targets for network firewalls and are specified by the client
    /// during instance creation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.Tags Tags {
      get { return tags_; }
      set {
        tags_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ComputeInstanceRestoreProperties);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ComputeInstanceRestoreProperties other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(AdvancedMachineFeatures, other.AdvancedMachineFeatures)) return false;
      if (CanIpForward != other.CanIpForward) return false;
      if (!object.Equals(ConfidentialInstanceConfig, other.ConfidentialInstanceConfig)) return false;
      if (DeletionProtection != other.DeletionProtection) return false;
      if (Description != other.Description) return false;
      if(!disks_.Equals(other.disks_)) return false;
      if (!object.Equals(DisplayDevice, other.DisplayDevice)) return false;
      if(!guestAccelerators_.Equals(other.guestAccelerators_)) return false;
      if (Hostname != other.Hostname) return false;
      if (!object.Equals(InstanceEncryptionKey, other.InstanceEncryptionKey)) return false;
      if (KeyRevocationActionType != other.KeyRevocationActionType) return false;
      if (!Labels.Equals(other.Labels)) return false;
      if (MachineType != other.MachineType) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (MinCpuPlatform != other.MinCpuPlatform) return false;
      if(!networkInterfaces_.Equals(other.networkInterfaces_)) return false;
      if (!object.Equals(NetworkPerformanceConfig, other.NetworkPerformanceConfig)) return false;
      if (!object.Equals(Params, other.Params)) return false;
      if (PrivateIpv6GoogleAccess != other.PrivateIpv6GoogleAccess) return false;
      if (!object.Equals(AllocationAffinity, other.AllocationAffinity)) return false;
      if(!resourcePolicies_.Equals(other.resourcePolicies_)) return false;
      if (!object.Equals(Scheduling, other.Scheduling)) return false;
      if(!serviceAccounts_.Equals(other.serviceAccounts_)) return false;
      if (!object.Equals(Tags, other.Tags)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (advancedMachineFeatures_ != null) hash ^= AdvancedMachineFeatures.GetHashCode();
      if (HasCanIpForward) hash ^= CanIpForward.GetHashCode();
      if (confidentialInstanceConfig_ != null) hash ^= ConfidentialInstanceConfig.GetHashCode();
      if (HasDeletionProtection) hash ^= DeletionProtection.GetHashCode();
      if (HasDescription) hash ^= Description.GetHashCode();
      hash ^= disks_.GetHashCode();
      if (displayDevice_ != null) hash ^= DisplayDevice.GetHashCode();
      hash ^= guestAccelerators_.GetHashCode();
      if (HasHostname) hash ^= Hostname.GetHashCode();
      if (instanceEncryptionKey_ != null) hash ^= InstanceEncryptionKey.GetHashCode();
      if (HasKeyRevocationActionType) hash ^= KeyRevocationActionType.GetHashCode();
      hash ^= Labels.GetHashCode();
      if (HasMachineType) hash ^= MachineType.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (HasMinCpuPlatform) hash ^= MinCpuPlatform.GetHashCode();
      hash ^= networkInterfaces_.GetHashCode();
      if (networkPerformanceConfig_ != null) hash ^= NetworkPerformanceConfig.GetHashCode();
      if (params_ != null) hash ^= Params.GetHashCode();
      if (HasPrivateIpv6GoogleAccess) hash ^= PrivateIpv6GoogleAccess.GetHashCode();
      if (allocationAffinity_ != null) hash ^= AllocationAffinity.GetHashCode();
      hash ^= resourcePolicies_.GetHashCode();
      if (scheduling_ != null) hash ^= Scheduling.GetHashCode();
      hash ^= serviceAccounts_.GetHashCode();
      if (tags_ != null) hash ^= Tags.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (advancedMachineFeatures_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(AdvancedMachineFeatures);
      }
      if (HasCanIpForward) {
        output.WriteRawTag(24);
        output.WriteBool(CanIpForward);
      }
      if (confidentialInstanceConfig_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ConfidentialInstanceConfig);
      }
      if (HasDeletionProtection) {
        output.WriteRawTag(40);
        output.WriteBool(DeletionProtection);
      }
      if (HasDescription) {
        output.WriteRawTag(50);
        output.WriteString(Description);
      }
      disks_.WriteTo(output, _repeated_disks_codec);
      if (displayDevice_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(DisplayDevice);
      }
      guestAccelerators_.WriteTo(output, _repeated_guestAccelerators_codec);
      if (HasHostname) {
        output.WriteRawTag(82);
        output.WriteString(Hostname);
      }
      if (instanceEncryptionKey_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(InstanceEncryptionKey);
      }
      if (HasKeyRevocationActionType) {
        output.WriteRawTag(96);
        output.WriteEnum((int) KeyRevocationActionType);
      }
      labels_.WriteTo(output, _map_labels_codec);
      if (HasMachineType) {
        output.WriteRawTag(114);
        output.WriteString(MachineType);
      }
      if (metadata_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(Metadata);
      }
      if (HasMinCpuPlatform) {
        output.WriteRawTag(130, 1);
        output.WriteString(MinCpuPlatform);
      }
      networkInterfaces_.WriteTo(output, _repeated_networkInterfaces_codec);
      if (networkPerformanceConfig_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(NetworkPerformanceConfig);
      }
      if (params_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(Params);
      }
      if (HasPrivateIpv6GoogleAccess) {
        output.WriteRawTag(160, 1);
        output.WriteEnum((int) PrivateIpv6GoogleAccess);
      }
      if (allocationAffinity_ != null) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(AllocationAffinity);
      }
      resourcePolicies_.WriteTo(output, _repeated_resourcePolicies_codec);
      if (scheduling_ != null) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(Scheduling);
      }
      serviceAccounts_.WriteTo(output, _repeated_serviceAccounts_codec);
      if (tags_ != null) {
        output.WriteRawTag(210, 1);
        output.WriteMessage(Tags);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (advancedMachineFeatures_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(AdvancedMachineFeatures);
      }
      if (HasCanIpForward) {
        output.WriteRawTag(24);
        output.WriteBool(CanIpForward);
      }
      if (confidentialInstanceConfig_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ConfidentialInstanceConfig);
      }
      if (HasDeletionProtection) {
        output.WriteRawTag(40);
        output.WriteBool(DeletionProtection);
      }
      if (HasDescription) {
        output.WriteRawTag(50);
        output.WriteString(Description);
      }
      disks_.WriteTo(ref output, _repeated_disks_codec);
      if (displayDevice_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(DisplayDevice);
      }
      guestAccelerators_.WriteTo(ref output, _repeated_guestAccelerators_codec);
      if (HasHostname) {
        output.WriteRawTag(82);
        output.WriteString(Hostname);
      }
      if (instanceEncryptionKey_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(InstanceEncryptionKey);
      }
      if (HasKeyRevocationActionType) {
        output.WriteRawTag(96);
        output.WriteEnum((int) KeyRevocationActionType);
      }
      labels_.WriteTo(ref output, _map_labels_codec);
      if (HasMachineType) {
        output.WriteRawTag(114);
        output.WriteString(MachineType);
      }
      if (metadata_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(Metadata);
      }
      if (HasMinCpuPlatform) {
        output.WriteRawTag(130, 1);
        output.WriteString(MinCpuPlatform);
      }
      networkInterfaces_.WriteTo(ref output, _repeated_networkInterfaces_codec);
      if (networkPerformanceConfig_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(NetworkPerformanceConfig);
      }
      if (params_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(Params);
      }
      if (HasPrivateIpv6GoogleAccess) {
        output.WriteRawTag(160, 1);
        output.WriteEnum((int) PrivateIpv6GoogleAccess);
      }
      if (allocationAffinity_ != null) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(AllocationAffinity);
      }
      resourcePolicies_.WriteTo(ref output, _repeated_resourcePolicies_codec);
      if (scheduling_ != null) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(Scheduling);
      }
      serviceAccounts_.WriteTo(ref output, _repeated_serviceAccounts_codec);
      if (tags_ != null) {
        output.WriteRawTag(210, 1);
        output.WriteMessage(Tags);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (advancedMachineFeatures_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AdvancedMachineFeatures);
      }
      if (HasCanIpForward) {
        size += 1 + 1;
      }
      if (confidentialInstanceConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConfidentialInstanceConfig);
      }
      if (HasDeletionProtection) {
        size += 1 + 1;
      }
      if (HasDescription) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Description);
      }
      size += disks_.CalculateSize(_repeated_disks_codec);
      if (displayDevice_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DisplayDevice);
      }
      size += guestAccelerators_.CalculateSize(_repeated_guestAccelerators_codec);
      if (HasHostname) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Hostname);
      }
      if (instanceEncryptionKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(InstanceEncryptionKey);
      }
      if (HasKeyRevocationActionType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) KeyRevocationActionType);
      }
      size += labels_.CalculateSize(_map_labels_codec);
      if (HasMachineType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MachineType);
      }
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (HasMinCpuPlatform) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(MinCpuPlatform);
      }
      size += networkInterfaces_.CalculateSize(_repeated_networkInterfaces_codec);
      if (networkPerformanceConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(NetworkPerformanceConfig);
      }
      if (params_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Params);
      }
      if (HasPrivateIpv6GoogleAccess) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) PrivateIpv6GoogleAccess);
      }
      if (allocationAffinity_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(AllocationAffinity);
      }
      size += resourcePolicies_.CalculateSize(_repeated_resourcePolicies_codec);
      if (scheduling_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Scheduling);
      }
      size += serviceAccounts_.CalculateSize(_repeated_serviceAccounts_codec);
      if (tags_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Tags);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ComputeInstanceRestoreProperties other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.advancedMachineFeatures_ != null) {
        if (advancedMachineFeatures_ == null) {
          AdvancedMachineFeatures = new global::Google.Cloud.BackupDR.V1.AdvancedMachineFeatures();
        }
        AdvancedMachineFeatures.MergeFrom(other.AdvancedMachineFeatures);
      }
      if (other.HasCanIpForward) {
        CanIpForward = other.CanIpForward;
      }
      if (other.confidentialInstanceConfig_ != null) {
        if (confidentialInstanceConfig_ == null) {
          ConfidentialInstanceConfig = new global::Google.Cloud.BackupDR.V1.ConfidentialInstanceConfig();
        }
        ConfidentialInstanceConfig.MergeFrom(other.ConfidentialInstanceConfig);
      }
      if (other.HasDeletionProtection) {
        DeletionProtection = other.DeletionProtection;
      }
      if (other.HasDescription) {
        Description = other.Description;
      }
      disks_.Add(other.disks_);
      if (other.displayDevice_ != null) {
        if (displayDevice_ == null) {
          DisplayDevice = new global::Google.Cloud.BackupDR.V1.DisplayDevice();
        }
        DisplayDevice.MergeFrom(other.DisplayDevice);
      }
      guestAccelerators_.Add(other.guestAccelerators_);
      if (other.HasHostname) {
        Hostname = other.Hostname;
      }
      if (other.instanceEncryptionKey_ != null) {
        if (instanceEncryptionKey_ == null) {
          InstanceEncryptionKey = new global::Google.Cloud.BackupDR.V1.CustomerEncryptionKey();
        }
        InstanceEncryptionKey.MergeFrom(other.InstanceEncryptionKey);
      }
      if (other.HasKeyRevocationActionType) {
        KeyRevocationActionType = other.KeyRevocationActionType;
      }
      labels_.MergeFrom(other.labels_);
      if (other.HasMachineType) {
        MachineType = other.MachineType;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::Google.Cloud.BackupDR.V1.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.HasMinCpuPlatform) {
        MinCpuPlatform = other.MinCpuPlatform;
      }
      networkInterfaces_.Add(other.networkInterfaces_);
      if (other.networkPerformanceConfig_ != null) {
        if (networkPerformanceConfig_ == null) {
          NetworkPerformanceConfig = new global::Google.Cloud.BackupDR.V1.NetworkPerformanceConfig();
        }
        NetworkPerformanceConfig.MergeFrom(other.NetworkPerformanceConfig);
      }
      if (other.params_ != null) {
        if (params_ == null) {
          Params = new global::Google.Cloud.BackupDR.V1.InstanceParams();
        }
        Params.MergeFrom(other.Params);
      }
      if (other.HasPrivateIpv6GoogleAccess) {
        PrivateIpv6GoogleAccess = other.PrivateIpv6GoogleAccess;
      }
      if (other.allocationAffinity_ != null) {
        if (allocationAffinity_ == null) {
          AllocationAffinity = new global::Google.Cloud.BackupDR.V1.AllocationAffinity();
        }
        AllocationAffinity.MergeFrom(other.AllocationAffinity);
      }
      resourcePolicies_.Add(other.resourcePolicies_);
      if (other.scheduling_ != null) {
        if (scheduling_ == null) {
          Scheduling = new global::Google.Cloud.BackupDR.V1.Scheduling();
        }
        Scheduling.MergeFrom(other.Scheduling);
      }
      serviceAccounts_.Add(other.serviceAccounts_);
      if (other.tags_ != null) {
        if (tags_ == null) {
          Tags = new global::Google.Cloud.BackupDR.V1.Tags();
        }
        Tags.MergeFrom(other.Tags);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (advancedMachineFeatures_ == null) {
              AdvancedMachineFeatures = new global::Google.Cloud.BackupDR.V1.AdvancedMachineFeatures();
            }
            input.ReadMessage(AdvancedMachineFeatures);
            break;
          }
          case 24: {
            CanIpForward = input.ReadBool();
            break;
          }
          case 34: {
            if (confidentialInstanceConfig_ == null) {
              ConfidentialInstanceConfig = new global::Google.Cloud.BackupDR.V1.ConfidentialInstanceConfig();
            }
            input.ReadMessage(ConfidentialInstanceConfig);
            break;
          }
          case 40: {
            DeletionProtection = input.ReadBool();
            break;
          }
          case 50: {
            Description = input.ReadString();
            break;
          }
          case 58: {
            disks_.AddEntriesFrom(input, _repeated_disks_codec);
            break;
          }
          case 66: {
            if (displayDevice_ == null) {
              DisplayDevice = new global::Google.Cloud.BackupDR.V1.DisplayDevice();
            }
            input.ReadMessage(DisplayDevice);
            break;
          }
          case 74: {
            guestAccelerators_.AddEntriesFrom(input, _repeated_guestAccelerators_codec);
            break;
          }
          case 82: {
            Hostname = input.ReadString();
            break;
          }
          case 90: {
            if (instanceEncryptionKey_ == null) {
              InstanceEncryptionKey = new global::Google.Cloud.BackupDR.V1.CustomerEncryptionKey();
            }
            input.ReadMessage(InstanceEncryptionKey);
            break;
          }
          case 96: {
            KeyRevocationActionType = (global::Google.Cloud.BackupDR.V1.KeyRevocationActionType) input.ReadEnum();
            break;
          }
          case 106: {
            labels_.AddEntriesFrom(input, _map_labels_codec);
            break;
          }
          case 114: {
            MachineType = input.ReadString();
            break;
          }
          case 122: {
            if (metadata_ == null) {
              Metadata = new global::Google.Cloud.BackupDR.V1.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 130: {
            MinCpuPlatform = input.ReadString();
            break;
          }
          case 138: {
            networkInterfaces_.AddEntriesFrom(input, _repeated_networkInterfaces_codec);
            break;
          }
          case 146: {
            if (networkPerformanceConfig_ == null) {
              NetworkPerformanceConfig = new global::Google.Cloud.BackupDR.V1.NetworkPerformanceConfig();
            }
            input.ReadMessage(NetworkPerformanceConfig);
            break;
          }
          case 154: {
            if (params_ == null) {
              Params = new global::Google.Cloud.BackupDR.V1.InstanceParams();
            }
            input.ReadMessage(Params);
            break;
          }
          case 160: {
            PrivateIpv6GoogleAccess = (global::Google.Cloud.BackupDR.V1.ComputeInstanceRestoreProperties.Types.InstancePrivateIpv6GoogleAccess) input.ReadEnum();
            break;
          }
          case 170: {
            if (allocationAffinity_ == null) {
              AllocationAffinity = new global::Google.Cloud.BackupDR.V1.AllocationAffinity();
            }
            input.ReadMessage(AllocationAffinity);
            break;
          }
          case 178: {
            resourcePolicies_.AddEntriesFrom(input, _repeated_resourcePolicies_codec);
            break;
          }
          case 186: {
            if (scheduling_ == null) {
              Scheduling = new global::Google.Cloud.BackupDR.V1.Scheduling();
            }
            input.ReadMessage(Scheduling);
            break;
          }
          case 194: {
            serviceAccounts_.AddEntriesFrom(input, _repeated_serviceAccounts_codec);
            break;
          }
          case 210: {
            if (tags_ == null) {
              Tags = new global::Google.Cloud.BackupDR.V1.Tags();
            }
            input.ReadMessage(Tags);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (advancedMachineFeatures_ == null) {
              AdvancedMachineFeatures = new global::Google.Cloud.BackupDR.V1.AdvancedMachineFeatures();
            }
            input.ReadMessage(AdvancedMachineFeatures);
            break;
          }
          case 24: {
            CanIpForward = input.ReadBool();
            break;
          }
          case 34: {
            if (confidentialInstanceConfig_ == null) {
              ConfidentialInstanceConfig = new global::Google.Cloud.BackupDR.V1.ConfidentialInstanceConfig();
            }
            input.ReadMessage(ConfidentialInstanceConfig);
            break;
          }
          case 40: {
            DeletionProtection = input.ReadBool();
            break;
          }
          case 50: {
            Description = input.ReadString();
            break;
          }
          case 58: {
            disks_.AddEntriesFrom(ref input, _repeated_disks_codec);
            break;
          }
          case 66: {
            if (displayDevice_ == null) {
              DisplayDevice = new global::Google.Cloud.BackupDR.V1.DisplayDevice();
            }
            input.ReadMessage(DisplayDevice);
            break;
          }
          case 74: {
            guestAccelerators_.AddEntriesFrom(ref input, _repeated_guestAccelerators_codec);
            break;
          }
          case 82: {
            Hostname = input.ReadString();
            break;
          }
          case 90: {
            if (instanceEncryptionKey_ == null) {
              InstanceEncryptionKey = new global::Google.Cloud.BackupDR.V1.CustomerEncryptionKey();
            }
            input.ReadMessage(InstanceEncryptionKey);
            break;
          }
          case 96: {
            KeyRevocationActionType = (global::Google.Cloud.BackupDR.V1.KeyRevocationActionType) input.ReadEnum();
            break;
          }
          case 106: {
            labels_.AddEntriesFrom(ref input, _map_labels_codec);
            break;
          }
          case 114: {
            MachineType = input.ReadString();
            break;
          }
          case 122: {
            if (metadata_ == null) {
              Metadata = new global::Google.Cloud.BackupDR.V1.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 130: {
            MinCpuPlatform = input.ReadString();
            break;
          }
          case 138: {
            networkInterfaces_.AddEntriesFrom(ref input, _repeated_networkInterfaces_codec);
            break;
          }
          case 146: {
            if (networkPerformanceConfig_ == null) {
              NetworkPerformanceConfig = new global::Google.Cloud.BackupDR.V1.NetworkPerformanceConfig();
            }
            input.ReadMessage(NetworkPerformanceConfig);
            break;
          }
          case 154: {
            if (params_ == null) {
              Params = new global::Google.Cloud.BackupDR.V1.InstanceParams();
            }
            input.ReadMessage(Params);
            break;
          }
          case 160: {
            PrivateIpv6GoogleAccess = (global::Google.Cloud.BackupDR.V1.ComputeInstanceRestoreProperties.Types.InstancePrivateIpv6GoogleAccess) input.ReadEnum();
            break;
          }
          case 170: {
            if (allocationAffinity_ == null) {
              AllocationAffinity = new global::Google.Cloud.BackupDR.V1.AllocationAffinity();
            }
            input.ReadMessage(AllocationAffinity);
            break;
          }
          case 178: {
            resourcePolicies_.AddEntriesFrom(ref input, _repeated_resourcePolicies_codec);
            break;
          }
          case 186: {
            if (scheduling_ == null) {
              Scheduling = new global::Google.Cloud.BackupDR.V1.Scheduling();
            }
            input.ReadMessage(Scheduling);
            break;
          }
          case 194: {
            serviceAccounts_.AddEntriesFrom(ref input, _repeated_serviceAccounts_codec);
            break;
          }
          case 210: {
            if (tags_ == null) {
              Tags = new global::Google.Cloud.BackupDR.V1.Tags();
            }
            input.ReadMessage(Tags);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ComputeInstanceRestoreProperties message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// The private IPv6 google access type for the VMs.
      /// </summary>
      public enum InstancePrivateIpv6GoogleAccess {
        /// <summary>
        /// Default value. This value is unused.
        /// </summary>
        [pbr::OriginalName("INSTANCE_PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Each network interface inherits PrivateIpv6GoogleAccess from its
        /// subnetwork.
        /// </summary>
        [pbr::OriginalName("INHERIT_FROM_SUBNETWORK")] InheritFromSubnetwork = 1,
        /// <summary>
        /// Outbound private IPv6 access from VMs in this subnet to Google services.
        /// If specified, the subnetwork who is attached to the instance's default
        /// network interface will be assigned an internal IPv6 prefix if it doesn't
        /// have before.
        /// </summary>
        [pbr::OriginalName("ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE")] EnableOutboundVmAccessToGoogle = 2,
        /// <summary>
        /// Bidirectional private IPv6 access to/from Google services. If
        /// specified, the subnetwork who is attached to the instance's default
        /// network interface will be assigned an internal IPv6 prefix if it doesn't
        /// have before.
        /// </summary>
        [pbr::OriginalName("ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE")] EnableBidirectionalAccessToGoogle = 3,
      }

    }
    #endregion

  }

  /// <summary>
  /// ComputeInstanceTargetEnvironment represents Compute Engine target
  /// environment to be used during restore.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ComputeInstanceTargetEnvironment : pb::IMessage<ComputeInstanceTargetEnvironment>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ComputeInstanceTargetEnvironment> _parser = new pb::MessageParser<ComputeInstanceTargetEnvironment>(() => new ComputeInstanceTargetEnvironment());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ComputeInstanceTargetEnvironment> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.BackupDR.V1.BackupvaultGceReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ComputeInstanceTargetEnvironment() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ComputeInstanceTargetEnvironment(ComputeInstanceTargetEnvironment other) : this() {
      project_ = other.project_;
      zone_ = other.zone_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ComputeInstanceTargetEnvironment Clone() {
      return new ComputeInstanceTargetEnvironment(this);
    }

    /// <summary>Field number for the "project" field.</summary>
    public const int ProjectFieldNumber = 1;
    private string project_ = "";
    /// <summary>
    /// Required. Target project for the Compute Engine instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Project {
      get { return project_; }
      set {
        project_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "zone" field.</summary>
    public const int ZoneFieldNumber = 2;
    private string zone_ = "";
    /// <summary>
    /// Required. The zone of the Compute Engine instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Zone {
      get { return zone_; }
      set {
        zone_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ComputeInstanceTargetEnvironment);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ComputeInstanceTargetEnvironment other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Project != other.Project) return false;
      if (Zone != other.Zone) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Project.Length != 0) hash ^= Project.GetHashCode();
      if (Zone.Length != 0) hash ^= Zone.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Project.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Project);
      }
      if (Zone.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Zone);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Project.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Project);
      }
      if (Zone.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Zone);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Project.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Project);
      }
      if (Zone.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Zone);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ComputeInstanceTargetEnvironment other) {
      if (other == null) {
        return;
      }
      if (other.Project.Length != 0) {
        Project = other.Project;
      }
      if (other.Zone.Length != 0) {
        Zone = other.Zone;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Project = input.ReadString();
            break;
          }
          case 18: {
            Zone = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Project = input.ReadString();
            break;
          }
          case 18: {
            Zone = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ComputeInstanceDataSourceProperties represents the properties of a
  /// ComputeEngine resource that are stored in the DataSource.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ComputeInstanceDataSourceProperties : pb::IMessage<ComputeInstanceDataSourceProperties>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ComputeInstanceDataSourceProperties> _parser = new pb::MessageParser<ComputeInstanceDataSourceProperties>(() => new ComputeInstanceDataSourceProperties());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ComputeInstanceDataSourceProperties> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.BackupDR.V1.BackupvaultGceReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ComputeInstanceDataSourceProperties() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ComputeInstanceDataSourceProperties(ComputeInstanceDataSourceProperties other) : this() {
      name_ = other.name_;
      description_ = other.description_;
      machineType_ = other.machineType_;
      totalDiskCount_ = other.totalDiskCount_;
      totalDiskSizeGb_ = other.totalDiskSizeGb_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ComputeInstanceDataSourceProperties Clone() {
      return new ComputeInstanceDataSourceProperties(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Name of the compute instance backed up by the datasource.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "description" field.</summary>
    public const int DescriptionFieldNumber = 2;
    private string description_ = "";
    /// <summary>
    /// The description of the Compute Engine instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Description {
      get { return description_; }
      set {
        description_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "machine_type" field.</summary>
    public const int MachineTypeFieldNumber = 3;
    private string machineType_ = "";
    /// <summary>
    /// The machine type of the instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string MachineType {
      get { return machineType_; }
      set {
        machineType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "total_disk_count" field.</summary>
    public const int TotalDiskCountFieldNumber = 4;
    private long totalDiskCount_;
    /// <summary>
    /// The total number of disks attached to the Instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long TotalDiskCount {
      get { return totalDiskCount_; }
      set {
        totalDiskCount_ = value;
      }
    }

    /// <summary>Field number for the "total_disk_size_gb" field.</summary>
    public const int TotalDiskSizeGbFieldNumber = 5;
    private long totalDiskSizeGb_;
    /// <summary>
    /// The sum of all the disk sizes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long TotalDiskSizeGb {
      get { return totalDiskSizeGb_; }
      set {
        totalDiskSizeGb_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ComputeInstanceDataSourceProperties);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ComputeInstanceDataSourceProperties other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Description != other.Description) return false;
      if (MachineType != other.MachineType) return false;
      if (TotalDiskCount != other.TotalDiskCount) return false;
      if (TotalDiskSizeGb != other.TotalDiskSizeGb) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Description.Length != 0) hash ^= Description.GetHashCode();
      if (MachineType.Length != 0) hash ^= MachineType.GetHashCode();
      if (TotalDiskCount != 0L) hash ^= TotalDiskCount.GetHashCode();
      if (TotalDiskSizeGb != 0L) hash ^= TotalDiskSizeGb.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Description.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Description);
      }
      if (MachineType.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(MachineType);
      }
      if (TotalDiskCount != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(TotalDiskCount);
      }
      if (TotalDiskSizeGb != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(TotalDiskSizeGb);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Description.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Description);
      }
      if (MachineType.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(MachineType);
      }
      if (TotalDiskCount != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(TotalDiskCount);
      }
      if (TotalDiskSizeGb != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(TotalDiskSizeGb);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Description.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Description);
      }
      if (MachineType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MachineType);
      }
      if (TotalDiskCount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TotalDiskCount);
      }
      if (TotalDiskSizeGb != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TotalDiskSizeGb);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ComputeInstanceDataSourceProperties other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Description.Length != 0) {
        Description = other.Description;
      }
      if (other.MachineType.Length != 0) {
        MachineType = other.MachineType;
      }
      if (other.TotalDiskCount != 0L) {
        TotalDiskCount = other.TotalDiskCount;
      }
      if (other.TotalDiskSizeGb != 0L) {
        TotalDiskSizeGb = other.TotalDiskSizeGb;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Description = input.ReadString();
            break;
          }
          case 26: {
            MachineType = input.ReadString();
            break;
          }
          case 32: {
            TotalDiskCount = input.ReadInt64();
            break;
          }
          case 40: {
            TotalDiskSizeGb = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Description = input.ReadString();
            break;
          }
          case 26: {
            MachineType = input.ReadString();
            break;
          }
          case 32: {
            TotalDiskCount = input.ReadInt64();
            break;
          }
          case 40: {
            TotalDiskSizeGb = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Specifies options for controlling advanced machine features.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class AdvancedMachineFeatures : pb::IMessage<AdvancedMachineFeatures>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AdvancedMachineFeatures> _parser = new pb::MessageParser<AdvancedMachineFeatures>(() => new AdvancedMachineFeatures());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AdvancedMachineFeatures> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.BackupDR.V1.BackupvaultGceReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AdvancedMachineFeatures() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AdvancedMachineFeatures(AdvancedMachineFeatures other) : this() {
      _hasBits0 = other._hasBits0;
      enableNestedVirtualization_ = other.enableNestedVirtualization_;
      threadsPerCore_ = other.threadsPerCore_;
      visibleCoreCount_ = other.visibleCoreCount_;
      enableUefiNetworking_ = other.enableUefiNetworking_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AdvancedMachineFeatures Clone() {
      return new AdvancedMachineFeatures(this);
    }

    /// <summary>Field number for the "enable_nested_virtualization" field.</summary>
    public const int EnableNestedVirtualizationFieldNumber = 1;
    private readonly static bool EnableNestedVirtualizationDefaultValue = false;

    private bool enableNestedVirtualization_;
    /// <summary>
    /// Optional. Whether to enable nested virtualization or not (default is
    /// false).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool EnableNestedVirtualization {
      get { if ((_hasBits0 & 1) != 0) { return enableNestedVirtualization_; } else { return EnableNestedVirtualizationDefaultValue; } }
      set {
        _hasBits0 |= 1;
        enableNestedVirtualization_ = value;
      }
    }
    /// <summary>Gets whether the "enable_nested_virtualization" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEnableNestedVirtualization {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "enable_nested_virtualization" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEnableNestedVirtualization() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "threads_per_core" field.</summary>
    public const int ThreadsPerCoreFieldNumber = 2;
    private readonly static int ThreadsPerCoreDefaultValue = 0;

    private int threadsPerCore_;
    /// <summary>
    /// Optional. The number of threads per physical core. To disable simultaneous
    /// multithreading (SMT) set this to 1. If unset, the maximum number
    /// of threads supported per core by the underlying processor is
    /// assumed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int ThreadsPerCore {
      get { if ((_hasBits0 & 2) != 0) { return threadsPerCore_; } else { return ThreadsPerCoreDefaultValue; } }
      set {
        _hasBits0 |= 2;
        threadsPerCore_ = value;
      }
    }
    /// <summary>Gets whether the "threads_per_core" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasThreadsPerCore {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "threads_per_core" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearThreadsPerCore() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "visible_core_count" field.</summary>
    public const int VisibleCoreCountFieldNumber = 3;
    private readonly static int VisibleCoreCountDefaultValue = 0;

    private int visibleCoreCount_;
    /// <summary>
    /// Optional. The number of physical cores to expose to an instance. Multiply
    /// by the number of threads per core to compute the total number of virtual
    /// CPUs to expose to the instance. If unset, the number of cores is
    /// inferred from the instance's nominal CPU count and the underlying
    /// platform's SMT width.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int VisibleCoreCount {
      get { if ((_hasBits0 & 4) != 0) { return visibleCoreCount_; } else { return VisibleCoreCountDefaultValue; } }
      set {
        _hasBits0 |= 4;
        visibleCoreCount_ = value;
      }
    }
    /// <summary>Gets whether the "visible_core_count" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVisibleCoreCount {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "visible_core_count" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVisibleCoreCount() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "enable_uefi_networking" field.</summary>
    public const int EnableUefiNetworkingFieldNumber = 4;
    private readonly static bool EnableUefiNetworkingDefaultValue = false;

    private bool enableUefiNetworking_;
    /// <summary>
    /// Optional. Whether to enable UEFI networking for instance creation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool EnableUefiNetworking {
      get { if ((_hasBits0 & 8) != 0) { return enableUefiNetworking_; } else { return EnableUefiNetworkingDefaultValue; } }
      set {
        _hasBits0 |= 8;
        enableUefiNetworking_ = value;
      }
    }
    /// <summary>Gets whether the "enable_uefi_networking" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEnableUefiNetworking {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "enable_uefi_networking" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEnableUefiNetworking() {
      _hasBits0 &= ~8;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AdvancedMachineFeatures);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AdvancedMachineFeatures other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (EnableNestedVirtualization != other.EnableNestedVirtualization) return false;
      if (ThreadsPerCore != other.ThreadsPerCore) return false;
      if (VisibleCoreCount != other.VisibleCoreCount) return false;
      if (EnableUefiNetworking != other.EnableUefiNetworking) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasEnableNestedVirtualization) hash ^= EnableNestedVirtualization.GetHashCode();
      if (HasThreadsPerCore) hash ^= ThreadsPerCore.GetHashCode();
      if (HasVisibleCoreCount) hash ^= VisibleCoreCount.GetHashCode();
      if (HasEnableUefiNetworking) hash ^= EnableUefiNetworking.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasEnableNestedVirtualization) {
        output.WriteRawTag(8);
        output.WriteBool(EnableNestedVirtualization);
      }
      if (HasThreadsPerCore) {
        output.WriteRawTag(16);
        output.WriteInt32(ThreadsPerCore);
      }
      if (HasVisibleCoreCount) {
        output.WriteRawTag(24);
        output.WriteInt32(VisibleCoreCount);
      }
      if (HasEnableUefiNetworking) {
        output.WriteRawTag(32);
        output.WriteBool(EnableUefiNetworking);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasEnableNestedVirtualization) {
        output.WriteRawTag(8);
        output.WriteBool(EnableNestedVirtualization);
      }
      if (HasThreadsPerCore) {
        output.WriteRawTag(16);
        output.WriteInt32(ThreadsPerCore);
      }
      if (HasVisibleCoreCount) {
        output.WriteRawTag(24);
        output.WriteInt32(VisibleCoreCount);
      }
      if (HasEnableUefiNetworking) {
        output.WriteRawTag(32);
        output.WriteBool(EnableUefiNetworking);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasEnableNestedVirtualization) {
        size += 1 + 1;
      }
      if (HasThreadsPerCore) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ThreadsPerCore);
      }
      if (HasVisibleCoreCount) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(VisibleCoreCount);
      }
      if (HasEnableUefiNetworking) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AdvancedMachineFeatures other) {
      if (other == null) {
        return;
      }
      if (other.HasEnableNestedVirtualization) {
        EnableNestedVirtualization = other.EnableNestedVirtualization;
      }
      if (other.HasThreadsPerCore) {
        ThreadsPerCore = other.ThreadsPerCore;
      }
      if (other.HasVisibleCoreCount) {
        VisibleCoreCount = other.VisibleCoreCount;
      }
      if (other.HasEnableUefiNetworking) {
        EnableUefiNetworking = other.EnableUefiNetworking;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            EnableNestedVirtualization = input.ReadBool();
            break;
          }
          case 16: {
            ThreadsPerCore = input.ReadInt32();
            break;
          }
          case 24: {
            VisibleCoreCount = input.ReadInt32();
            break;
          }
          case 32: {
            EnableUefiNetworking = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            EnableNestedVirtualization = input.ReadBool();
            break;
          }
          case 16: {
            ThreadsPerCore = input.ReadInt32();
            break;
          }
          case 24: {
            VisibleCoreCount = input.ReadInt32();
            break;
          }
          case 32: {
            EnableUefiNetworking = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A set of Confidential Instance options.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ConfidentialInstanceConfig : pb::IMessage<ConfidentialInstanceConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ConfidentialInstanceConfig> _parser = new pb::MessageParser<ConfidentialInstanceConfig>(() => new ConfidentialInstanceConfig());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ConfidentialInstanceConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.BackupDR.V1.BackupvaultGceReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfidentialInstanceConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfidentialInstanceConfig(ConfidentialInstanceConfig other) : this() {
      _hasBits0 = other._hasBits0;
      enableConfidentialCompute_ = other.enableConfidentialCompute_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfidentialInstanceConfig Clone() {
      return new ConfidentialInstanceConfig(this);
    }

    /// <summary>Field number for the "enable_confidential_compute" field.</summary>
    public const int EnableConfidentialComputeFieldNumber = 1;
    private readonly static bool EnableConfidentialComputeDefaultValue = false;

    private bool enableConfidentialCompute_;
    /// <summary>
    /// Optional. Defines whether the instance should have confidential compute
    /// enabled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool EnableConfidentialCompute {
      get { if ((_hasBits0 & 1) != 0) { return enableConfidentialCompute_; } else { return EnableConfidentialComputeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        enableConfidentialCompute_ = value;
      }
    }
    /// <summary>Gets whether the "enable_confidential_compute" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEnableConfidentialCompute {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "enable_confidential_compute" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEnableConfidentialCompute() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ConfidentialInstanceConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ConfidentialInstanceConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (EnableConfidentialCompute != other.EnableConfidentialCompute) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasEnableConfidentialCompute) hash ^= EnableConfidentialCompute.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasEnableConfidentialCompute) {
        output.WriteRawTag(8);
        output.WriteBool(EnableConfidentialCompute);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasEnableConfidentialCompute) {
        output.WriteRawTag(8);
        output.WriteBool(EnableConfidentialCompute);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasEnableConfidentialCompute) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ConfidentialInstanceConfig other) {
      if (other == null) {
        return;
      }
      if (other.HasEnableConfidentialCompute) {
        EnableConfidentialCompute = other.EnableConfidentialCompute;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            EnableConfidentialCompute = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            EnableConfidentialCompute = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A set of Display Device options
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class DisplayDevice : pb::IMessage<DisplayDevice>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DisplayDevice> _parser = new pb::MessageParser<DisplayDevice>(() => new DisplayDevice());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<DisplayDevice> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.BackupDR.V1.BackupvaultGceReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DisplayDevice() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DisplayDevice(DisplayDevice other) : this() {
      _hasBits0 = other._hasBits0;
      enableDisplay_ = other.enableDisplay_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DisplayDevice Clone() {
      return new DisplayDevice(this);
    }

    /// <summary>Field number for the "enable_display" field.</summary>
    public const int EnableDisplayFieldNumber = 1;
    private readonly static bool EnableDisplayDefaultValue = false;

    private bool enableDisplay_;
    /// <summary>
    /// Optional. Enables display for the Compute Engine VM
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool EnableDisplay {
      get { if ((_hasBits0 & 1) != 0) { return enableDisplay_; } else { return EnableDisplayDefaultValue; } }
      set {
        _hasBits0 |= 1;
        enableDisplay_ = value;
      }
    }
    /// <summary>Gets whether the "enable_display" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEnableDisplay {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "enable_display" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEnableDisplay() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as DisplayDevice);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(DisplayDevice other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (EnableDisplay != other.EnableDisplay) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasEnableDisplay) hash ^= EnableDisplay.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasEnableDisplay) {
        output.WriteRawTag(8);
        output.WriteBool(EnableDisplay);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasEnableDisplay) {
        output.WriteRawTag(8);
        output.WriteBool(EnableDisplay);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasEnableDisplay) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(DisplayDevice other) {
      if (other == null) {
        return;
      }
      if (other.HasEnableDisplay) {
        EnableDisplay = other.EnableDisplay;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            EnableDisplay = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            EnableDisplay = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A specification of the type and number of accelerator cards attached to the
  /// instance.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class AcceleratorConfig : pb::IMessage<AcceleratorConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AcceleratorConfig> _parser = new pb::MessageParser<AcceleratorConfig>(() => new AcceleratorConfig());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AcceleratorConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.BackupDR.V1.BackupvaultGceReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AcceleratorConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AcceleratorConfig(AcceleratorConfig other) : this() {
      _hasBits0 = other._hasBits0;
      acceleratorType_ = other.acceleratorType_;
      acceleratorCount_ = other.acceleratorCount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AcceleratorConfig Clone() {
      return new AcceleratorConfig(this);
    }

    /// <summary>Field number for the "accelerator_type" field.</summary>
    public const int AcceleratorTypeFieldNumber = 1;
    private readonly static string AcceleratorTypeDefaultValue = "";

    private string acceleratorType_;
    /// <summary>
    /// Optional. Full or partial URL of the accelerator type resource to attach to
    /// this instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string AcceleratorType {
      get { return acceleratorType_ ?? AcceleratorTypeDefaultValue; }
      set {
        acceleratorType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "accelerator_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAcceleratorType {
      get { return acceleratorType_ != null; }
    }
    /// <summary>Clears the value of the "accelerator_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAcceleratorType() {
      acceleratorType_ = null;
    }

    /// <summary>Field number for the "accelerator_count" field.</summary>
    public const int AcceleratorCountFieldNumber = 2;
    private readonly static int AcceleratorCountDefaultValue = 0;

    private int acceleratorCount_;
    /// <summary>
    /// Optional. The number of the guest accelerator cards exposed to this
    /// instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int AcceleratorCount {
      get { if ((_hasBits0 & 1) != 0) { return acceleratorCount_; } else { return AcceleratorCountDefaultValue; } }
      set {
        _hasBits0 |= 1;
        acceleratorCount_ = value;
      }
    }
    /// <summary>Gets whether the "accelerator_count" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAcceleratorCount {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "accelerator_count" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAcceleratorCount() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AcceleratorConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AcceleratorConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AcceleratorType != other.AcceleratorType) return false;
      if (AcceleratorCount != other.AcceleratorCount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasAcceleratorType) hash ^= AcceleratorType.GetHashCode();
      if (HasAcceleratorCount) hash ^= AcceleratorCount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasAcceleratorType) {
        output.WriteRawTag(10);
        output.WriteString(AcceleratorType);
      }
      if (HasAcceleratorCount) {
        output.WriteRawTag(16);
        output.WriteInt32(AcceleratorCount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasAcceleratorType) {
        output.WriteRawTag(10);
        output.WriteString(AcceleratorType);
      }
      if (HasAcceleratorCount) {
        output.WriteRawTag(16);
        output.WriteInt32(AcceleratorCount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasAcceleratorType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AcceleratorType);
      }
      if (HasAcceleratorCount) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(AcceleratorCount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AcceleratorConfig other) {
      if (other == null) {
        return;
      }
      if (other.HasAcceleratorType) {
        AcceleratorType = other.AcceleratorType;
      }
      if (other.HasAcceleratorCount) {
        AcceleratorCount = other.AcceleratorCount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            AcceleratorType = input.ReadString();
            break;
          }
          case 16: {
            AcceleratorCount = input.ReadInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            AcceleratorType = input.ReadString();
            break;
          }
          case 16: {
            AcceleratorCount = input.ReadInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A customer-supplied encryption key.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class CustomerEncryptionKey : pb::IMessage<CustomerEncryptionKey>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CustomerEncryptionKey> _parser = new pb::MessageParser<CustomerEncryptionKey>(() => new CustomerEncryptionKey());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CustomerEncryptionKey> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.BackupDR.V1.BackupvaultGceReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CustomerEncryptionKey() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CustomerEncryptionKey(CustomerEncryptionKey other) : this() {
      kmsKeyServiceAccount_ = other.kmsKeyServiceAccount_;
      switch (other.KeyCase) {
        case KeyOneofCase.RawKey:
          RawKey = other.RawKey;
          break;
        case KeyOneofCase.RsaEncryptedKey:
          RsaEncryptedKey = other.RsaEncryptedKey;
          break;
        case KeyOneofCase.KmsKeyName:
          KmsKeyName = other.KmsKeyName;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CustomerEncryptionKey Clone() {
      return new CustomerEncryptionKey(this);
    }

    /// <summary>Field number for the "raw_key" field.</summary>
    public const int RawKeyFieldNumber = 1;
    /// <summary>
    /// Optional. Specifies a 256-bit customer-supplied
    /// encryption key.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RawKey {
      get { return HasRawKey ? (string) key_ : ""; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        keyCase_ = KeyOneofCase.RawKey;
      }
    }
    /// <summary>Gets whether the "raw_key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRawKey {
      get { return keyCase_ == KeyOneofCase.RawKey; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "raw_key" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRawKey() {
      if (HasRawKey) {
        ClearKey();
      }
    }

    /// <summary>Field number for the "rsa_encrypted_key" field.</summary>
    public const int RsaEncryptedKeyFieldNumber = 2;
    /// <summary>
    /// Optional. RSA-wrapped 2048-bit
    /// customer-supplied encryption key to either encrypt or decrypt this
    /// resource.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RsaEncryptedKey {
      get { return HasRsaEncryptedKey ? (string) key_ : ""; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        keyCase_ = KeyOneofCase.RsaEncryptedKey;
      }
    }
    /// <summary>Gets whether the "rsa_encrypted_key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRsaEncryptedKey {
      get { return keyCase_ == KeyOneofCase.RsaEncryptedKey; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "rsa_encrypted_key" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRsaEncryptedKey() {
      if (HasRsaEncryptedKey) {
        ClearKey();
      }
    }

    /// <summary>Field number for the "kms_key_name" field.</summary>
    public const int KmsKeyNameFieldNumber = 3;
    /// <summary>
    /// Optional. The name of the encryption key that is stored in Google Cloud
    /// KMS.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string KmsKeyName {
      get { return HasKmsKeyName ? (string) key_ : ""; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        keyCase_ = KeyOneofCase.KmsKeyName;
      }
    }
    /// <summary>Gets whether the "kms_key_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKmsKeyName {
      get { return keyCase_ == KeyOneofCase.KmsKeyName; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "kms_key_name" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKmsKeyName() {
      if (HasKmsKeyName) {
        ClearKey();
      }
    }

    /// <summary>Field number for the "kms_key_service_account" field.</summary>
    public const int KmsKeyServiceAccountFieldNumber = 4;
    private readonly static string KmsKeyServiceAccountDefaultValue = "";

    private string kmsKeyServiceAccount_;
    /// <summary>
    /// Optional. The service account being used for the encryption request for the
    /// given KMS key. If absent, the Compute Engine default service account is
    /// used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string KmsKeyServiceAccount {
      get { return kmsKeyServiceAccount_ ?? KmsKeyServiceAccountDefaultValue; }
      set {
        kmsKeyServiceAccount_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "kms_key_service_account" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKmsKeyServiceAccount {
      get { return kmsKeyServiceAccount_ != null; }
    }
    /// <summary>Clears the value of the "kms_key_service_account" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKmsKeyServiceAccount() {
      kmsKeyServiceAccount_ = null;
    }

    private object key_;
    /// <summary>Enum of possible cases for the "key" oneof.</summary>
    public enum KeyOneofCase {
      None = 0,
      RawKey = 1,
      RsaEncryptedKey = 2,
      KmsKeyName = 3,
    }
    private KeyOneofCase keyCase_ = KeyOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyOneofCase KeyCase {
      get { return keyCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKey() {
      keyCase_ = KeyOneofCase.None;
      key_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CustomerEncryptionKey);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CustomerEncryptionKey other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (RawKey != other.RawKey) return false;
      if (RsaEncryptedKey != other.RsaEncryptedKey) return false;
      if (KmsKeyName != other.KmsKeyName) return false;
      if (KmsKeyServiceAccount != other.KmsKeyServiceAccount) return false;
      if (KeyCase != other.KeyCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasRawKey) hash ^= RawKey.GetHashCode();
      if (HasRsaEncryptedKey) hash ^= RsaEncryptedKey.GetHashCode();
      if (HasKmsKeyName) hash ^= KmsKeyName.GetHashCode();
      if (HasKmsKeyServiceAccount) hash ^= KmsKeyServiceAccount.GetHashCode();
      hash ^= (int) keyCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasRawKey) {
        output.WriteRawTag(10);
        output.WriteString(RawKey);
      }
      if (HasRsaEncryptedKey) {
        output.WriteRawTag(18);
        output.WriteString(RsaEncryptedKey);
      }
      if (HasKmsKeyName) {
        output.WriteRawTag(26);
        output.WriteString(KmsKeyName);
      }
      if (HasKmsKeyServiceAccount) {
        output.WriteRawTag(34);
        output.WriteString(KmsKeyServiceAccount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasRawKey) {
        output.WriteRawTag(10);
        output.WriteString(RawKey);
      }
      if (HasRsaEncryptedKey) {
        output.WriteRawTag(18);
        output.WriteString(RsaEncryptedKey);
      }
      if (HasKmsKeyName) {
        output.WriteRawTag(26);
        output.WriteString(KmsKeyName);
      }
      if (HasKmsKeyServiceAccount) {
        output.WriteRawTag(34);
        output.WriteString(KmsKeyServiceAccount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasRawKey) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RawKey);
      }
      if (HasRsaEncryptedKey) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RsaEncryptedKey);
      }
      if (HasKmsKeyName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(KmsKeyName);
      }
      if (HasKmsKeyServiceAccount) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(KmsKeyServiceAccount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CustomerEncryptionKey other) {
      if (other == null) {
        return;
      }
      if (other.HasKmsKeyServiceAccount) {
        KmsKeyServiceAccount = other.KmsKeyServiceAccount;
      }
      switch (other.KeyCase) {
        case KeyOneofCase.RawKey:
          RawKey = other.RawKey;
          break;
        case KeyOneofCase.RsaEncryptedKey:
          RsaEncryptedKey = other.RsaEncryptedKey;
          break;
        case KeyOneofCase.KmsKeyName:
          KmsKeyName = other.KmsKeyName;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            RawKey = input.ReadString();
            break;
          }
          case 18: {
            RsaEncryptedKey = input.ReadString();
            break;
          }
          case 26: {
            KmsKeyName = input.ReadString();
            break;
          }
          case 34: {
            KmsKeyServiceAccount = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            RawKey = input.ReadString();
            break;
          }
          case 18: {
            RsaEncryptedKey = input.ReadString();
            break;
          }
          case 26: {
            KmsKeyName = input.ReadString();
            break;
          }
          case 34: {
            KmsKeyServiceAccount = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A key/value pair to be used for storing metadata.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Entry : pb::IMessage<Entry>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Entry> _parser = new pb::MessageParser<Entry>(() => new Entry());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Entry> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.BackupDR.V1.BackupvaultGceReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Entry() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Entry(Entry other) : this() {
      key_ = other.key_;
      value_ = other.value_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Entry Clone() {
      return new Entry(this);
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 1;
    private readonly static string KeyDefaultValue = "";

    private string key_;
    /// <summary>
    /// Optional. Key for the metadata entry.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Key {
      get { return key_ ?? KeyDefaultValue; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKey {
      get { return key_ != null; }
    }
    /// <summary>Clears the value of the "key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKey() {
      key_ = null;
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private readonly static string ValueDefaultValue = "";

    private string value_;
    /// <summary>
    /// Optional. Value for the metadata entry. These are free-form strings, and
    /// only have meaning as interpreted by the image running in the instance. The
    /// only restriction placed on values is that their size must be less than
    /// or equal to 262144 bytes (256 KiB).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Value {
      get { return value_ ?? ValueDefaultValue; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "value" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasValue {
      get { return value_ != null; }
    }
    /// <summary>Clears the value of the "value" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearValue() {
      value_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Entry);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Entry other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Key != other.Key) return false;
      if (Value != other.Value) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasKey) hash ^= Key.GetHashCode();
      if (HasValue) hash ^= Value.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasKey) {
        output.WriteRawTag(10);
        output.WriteString(Key);
      }
      if (HasValue) {
        output.WriteRawTag(18);
        output.WriteString(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasKey) {
        output.WriteRawTag(10);
        output.WriteString(Key);
      }
      if (HasValue) {
        output.WriteRawTag(18);
        output.WriteString(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasKey) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
      }
      if (HasValue) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Entry other) {
      if (other == null) {
        return;
      }
      if (other.HasKey) {
        Key = other.Key;
      }
      if (other.HasValue) {
        Value = other.Value;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Key = input.ReadString();
            break;
          }
          case 18: {
            Value = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Key = input.ReadString();
            break;
          }
          case 18: {
            Value = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A metadata key/value entry.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Metadata : pb::IMessage<Metadata>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Metadata> _parser = new pb::MessageParser<Metadata>(() => new Metadata());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Metadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.BackupDR.V1.BackupvaultGceReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Metadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Metadata(Metadata other) : this() {
      items_ = other.items_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Metadata Clone() {
      return new Metadata(this);
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Cloud.BackupDR.V1.Entry> _repeated_items_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Cloud.BackupDR.V1.Entry.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.Entry> items_ = new pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.Entry>();
    /// <summary>
    /// Optional. Array of key/value pairs. The total size of all keys and values
    /// must be less than 512 KB.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.Entry> Items {
      get { return items_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Metadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Metadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!items_.Equals(other.items_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= items_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      items_.WriteTo(output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      items_.WriteTo(ref output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += items_.CalculateSize(_repeated_items_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Metadata other) {
      if (other == null) {
        return;
      }
      items_.Add(other.items_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A network interface resource attached to an instance.
  /// s
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class NetworkInterface : pb::IMessage<NetworkInterface>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NetworkInterface> _parser = new pb::MessageParser<NetworkInterface>(() => new NetworkInterface());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NetworkInterface> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.BackupDR.V1.BackupvaultGceReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkInterface() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkInterface(NetworkInterface other) : this() {
      _hasBits0 = other._hasBits0;
      network_ = other.network_;
      subnetwork_ = other.subnetwork_;
      ipAddress_ = other.ipAddress_;
      ipv6Address_ = other.ipv6Address_;
      internalIpv6PrefixLength_ = other.internalIpv6PrefixLength_;
      name_ = other.name_;
      accessConfigs_ = other.accessConfigs_.Clone();
      ipv6AccessConfigs_ = other.ipv6AccessConfigs_.Clone();
      aliasIpRanges_ = other.aliasIpRanges_.Clone();
      stackType_ = other.stackType_;
      ipv6AccessType_ = other.ipv6AccessType_;
      queueCount_ = other.queueCount_;
      nicType_ = other.nicType_;
      networkAttachment_ = other.networkAttachment_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkInterface Clone() {
      return new NetworkInterface(this);
    }

    /// <summary>Field number for the "network" field.</summary>
    public const int NetworkFieldNumber = 1;
    private readonly static string NetworkDefaultValue = "";

    private string network_;
    /// <summary>
    /// Optional. URL of the VPC network resource for this instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Network {
      get { return network_ ?? NetworkDefaultValue; }
      set {
        network_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "network" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNetwork {
      get { return network_ != null; }
    }
    /// <summary>Clears the value of the "network" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNetwork() {
      network_ = null;
    }

    /// <summary>Field number for the "subnetwork" field.</summary>
    public const int SubnetworkFieldNumber = 2;
    private readonly static string SubnetworkDefaultValue = "";

    private string subnetwork_;
    /// <summary>
    /// Optional. The URL of the Subnetwork resource for this instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Subnetwork {
      get { return subnetwork_ ?? SubnetworkDefaultValue; }
      set {
        subnetwork_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "subnetwork" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSubnetwork {
      get { return subnetwork_ != null; }
    }
    /// <summary>Clears the value of the "subnetwork" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSubnetwork() {
      subnetwork_ = null;
    }

    /// <summary>Field number for the "ip_address" field.</summary>
    public const int IpAddressFieldNumber = 3;
    private readonly static string IpAddressDefaultValue = "";

    private string ipAddress_;
    /// <summary>
    /// Optional. An IPv4 internal IP address to assign to the instance for this
    /// network interface. If not specified by the user, an unused internal IP is
    /// assigned by the system.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string IpAddress {
      get { return ipAddress_ ?? IpAddressDefaultValue; }
      set {
        ipAddress_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "ip_address" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIpAddress {
      get { return ipAddress_ != null; }
    }
    /// <summary>Clears the value of the "ip_address" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIpAddress() {
      ipAddress_ = null;
    }

    /// <summary>Field number for the "ipv6_address" field.</summary>
    public const int Ipv6AddressFieldNumber = 4;
    private readonly static string Ipv6AddressDefaultValue = "";

    private string ipv6Address_;
    /// <summary>
    /// Optional. An IPv6 internal network address for this network interface. To
    /// use a static internal IP address, it must be unused and in the same region
    /// as the instance's zone. If not specified, Google Cloud will automatically
    /// assign an internal IPv6 address from the instance's subnetwork.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Ipv6Address {
      get { return ipv6Address_ ?? Ipv6AddressDefaultValue; }
      set {
        ipv6Address_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "ipv6_address" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIpv6Address {
      get { return ipv6Address_ != null; }
    }
    /// <summary>Clears the value of the "ipv6_address" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIpv6Address() {
      ipv6Address_ = null;
    }

    /// <summary>Field number for the "internal_ipv6_prefix_length" field.</summary>
    public const int InternalIpv6PrefixLengthFieldNumber = 5;
    private readonly static int InternalIpv6PrefixLengthDefaultValue = 0;

    private int internalIpv6PrefixLength_;
    /// <summary>
    /// Optional. The prefix length of the primary internal IPv6 range.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int InternalIpv6PrefixLength {
      get { if ((_hasBits0 & 1) != 0) { return internalIpv6PrefixLength_; } else { return InternalIpv6PrefixLengthDefaultValue; } }
      set {
        _hasBits0 |= 1;
        internalIpv6PrefixLength_ = value;
      }
    }
    /// <summary>Gets whether the "internal_ipv6_prefix_length" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasInternalIpv6PrefixLength {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "internal_ipv6_prefix_length" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearInternalIpv6PrefixLength() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 6;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// Output only. [Output Only] The name of the network interface, which is
    /// generated by the server.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "access_configs" field.</summary>
    public const int AccessConfigsFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Google.Cloud.BackupDR.V1.AccessConfig> _repeated_accessConfigs_codec
        = pb::FieldCodec.ForMessage(58, global::Google.Cloud.BackupDR.V1.AccessConfig.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.AccessConfig> accessConfigs_ = new pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.AccessConfig>();
    /// <summary>
    /// Optional. An array of configurations for this interface. Currently, only
    /// one access config,ONE_TO_ONE_NAT is supported. If there are no
    /// accessConfigs specified, then this instance will have
    /// no external internet access.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.AccessConfig> AccessConfigs {
      get { return accessConfigs_; }
    }

    /// <summary>Field number for the "ipv6_access_configs" field.</summary>
    public const int Ipv6AccessConfigsFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Google.Cloud.BackupDR.V1.AccessConfig> _repeated_ipv6AccessConfigs_codec
        = pb::FieldCodec.ForMessage(66, global::Google.Cloud.BackupDR.V1.AccessConfig.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.AccessConfig> ipv6AccessConfigs_ = new pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.AccessConfig>();
    /// <summary>
    /// Optional. An array of IPv6 access configurations for this interface.
    /// Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there
    /// is no ipv6AccessConfig specified, then this instance will
    /// have no external IPv6 Internet access.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.AccessConfig> Ipv6AccessConfigs {
      get { return ipv6AccessConfigs_; }
    }

    /// <summary>Field number for the "alias_ip_ranges" field.</summary>
    public const int AliasIpRangesFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Google.Cloud.BackupDR.V1.AliasIpRange> _repeated_aliasIpRanges_codec
        = pb::FieldCodec.ForMessage(74, global::Google.Cloud.BackupDR.V1.AliasIpRange.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.AliasIpRange> aliasIpRanges_ = new pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.AliasIpRange>();
    /// <summary>
    /// Optional. An array of alias IP ranges for this network interface.
    /// You can only specify this field for network interfaces in VPC networks.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.AliasIpRange> AliasIpRanges {
      get { return aliasIpRanges_; }
    }

    /// <summary>Field number for the "stack_type" field.</summary>
    public const int StackTypeFieldNumber = 10;
    private readonly static global::Google.Cloud.BackupDR.V1.NetworkInterface.Types.StackType StackTypeDefaultValue = global::Google.Cloud.BackupDR.V1.NetworkInterface.Types.StackType.Unspecified;

    private global::Google.Cloud.BackupDR.V1.NetworkInterface.Types.StackType stackType_;
    /// <summary>
    /// The stack type for this network interface.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.NetworkInterface.Types.StackType StackType {
      get { if ((_hasBits0 & 2) != 0) { return stackType_; } else { return StackTypeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        stackType_ = value;
      }
    }
    /// <summary>Gets whether the "stack_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStackType {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "stack_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStackType() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "ipv6_access_type" field.</summary>
    public const int Ipv6AccessTypeFieldNumber = 11;
    private readonly static global::Google.Cloud.BackupDR.V1.NetworkInterface.Types.Ipv6AccessType Ipv6AccessTypeDefaultValue = global::Google.Cloud.BackupDR.V1.NetworkInterface.Types.Ipv6AccessType.UnspecifiedIpv6AccessType;

    private global::Google.Cloud.BackupDR.V1.NetworkInterface.Types.Ipv6AccessType ipv6AccessType_;
    /// <summary>
    /// Optional. [Output Only] One of EXTERNAL, INTERNAL to indicate whether the
    /// IP can be accessed from the Internet. This field is always inherited from
    /// its subnetwork.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.NetworkInterface.Types.Ipv6AccessType Ipv6AccessType {
      get { if ((_hasBits0 & 4) != 0) { return ipv6AccessType_; } else { return Ipv6AccessTypeDefaultValue; } }
      set {
        _hasBits0 |= 4;
        ipv6AccessType_ = value;
      }
    }
    /// <summary>Gets whether the "ipv6_access_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIpv6AccessType {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "ipv6_access_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIpv6AccessType() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "queue_count" field.</summary>
    public const int QueueCountFieldNumber = 12;
    private readonly static int QueueCountDefaultValue = 0;

    private int queueCount_;
    /// <summary>
    /// Optional. The networking queue count that's specified by users for the
    /// network interface. Both Rx and Tx queues will be set to this number. It'll
    /// be empty if not specified by the users.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int QueueCount {
      get { if ((_hasBits0 & 8) != 0) { return queueCount_; } else { return QueueCountDefaultValue; } }
      set {
        _hasBits0 |= 8;
        queueCount_ = value;
      }
    }
    /// <summary>Gets whether the "queue_count" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasQueueCount {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "queue_count" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearQueueCount() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "nic_type" field.</summary>
    public const int NicTypeFieldNumber = 13;
    private readonly static global::Google.Cloud.BackupDR.V1.NetworkInterface.Types.NicType NicTypeDefaultValue = global::Google.Cloud.BackupDR.V1.NetworkInterface.Types.NicType.Unspecified;

    private global::Google.Cloud.BackupDR.V1.NetworkInterface.Types.NicType nicType_;
    /// <summary>
    /// Optional. The type of vNIC to be used on this interface. This may be gVNIC
    /// or VirtioNet.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.NetworkInterface.Types.NicType NicType {
      get { if ((_hasBits0 & 16) != 0) { return nicType_; } else { return NicTypeDefaultValue; } }
      set {
        _hasBits0 |= 16;
        nicType_ = value;
      }
    }
    /// <summary>Gets whether the "nic_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNicType {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "nic_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNicType() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "network_attachment" field.</summary>
    public const int NetworkAttachmentFieldNumber = 14;
    private readonly static string NetworkAttachmentDefaultValue = "";

    private string networkAttachment_;
    /// <summary>
    /// Optional. The URL of the network attachment that this interface should
    /// connect to in the following format:
    /// projects/{project_number}/regions/{region_name}/networkAttachments/{network_attachment_name}.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string NetworkAttachment {
      get { return networkAttachment_ ?? NetworkAttachmentDefaultValue; }
      set {
        networkAttachment_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "network_attachment" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNetworkAttachment {
      get { return networkAttachment_ != null; }
    }
    /// <summary>Clears the value of the "network_attachment" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNetworkAttachment() {
      networkAttachment_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NetworkInterface);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NetworkInterface other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Network != other.Network) return false;
      if (Subnetwork != other.Subnetwork) return false;
      if (IpAddress != other.IpAddress) return false;
      if (Ipv6Address != other.Ipv6Address) return false;
      if (InternalIpv6PrefixLength != other.InternalIpv6PrefixLength) return false;
      if (Name != other.Name) return false;
      if(!accessConfigs_.Equals(other.accessConfigs_)) return false;
      if(!ipv6AccessConfigs_.Equals(other.ipv6AccessConfigs_)) return false;
      if(!aliasIpRanges_.Equals(other.aliasIpRanges_)) return false;
      if (StackType != other.StackType) return false;
      if (Ipv6AccessType != other.Ipv6AccessType) return false;
      if (QueueCount != other.QueueCount) return false;
      if (NicType != other.NicType) return false;
      if (NetworkAttachment != other.NetworkAttachment) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasNetwork) hash ^= Network.GetHashCode();
      if (HasSubnetwork) hash ^= Subnetwork.GetHashCode();
      if (HasIpAddress) hash ^= IpAddress.GetHashCode();
      if (HasIpv6Address) hash ^= Ipv6Address.GetHashCode();
      if (HasInternalIpv6PrefixLength) hash ^= InternalIpv6PrefixLength.GetHashCode();
      if (HasName) hash ^= Name.GetHashCode();
      hash ^= accessConfigs_.GetHashCode();
      hash ^= ipv6AccessConfigs_.GetHashCode();
      hash ^= aliasIpRanges_.GetHashCode();
      if (HasStackType) hash ^= StackType.GetHashCode();
      if (HasIpv6AccessType) hash ^= Ipv6AccessType.GetHashCode();
      if (HasQueueCount) hash ^= QueueCount.GetHashCode();
      if (HasNicType) hash ^= NicType.GetHashCode();
      if (HasNetworkAttachment) hash ^= NetworkAttachment.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasNetwork) {
        output.WriteRawTag(10);
        output.WriteString(Network);
      }
      if (HasSubnetwork) {
        output.WriteRawTag(18);
        output.WriteString(Subnetwork);
      }
      if (HasIpAddress) {
        output.WriteRawTag(26);
        output.WriteString(IpAddress);
      }
      if (HasIpv6Address) {
        output.WriteRawTag(34);
        output.WriteString(Ipv6Address);
      }
      if (HasInternalIpv6PrefixLength) {
        output.WriteRawTag(40);
        output.WriteInt32(InternalIpv6PrefixLength);
      }
      if (HasName) {
        output.WriteRawTag(50);
        output.WriteString(Name);
      }
      accessConfigs_.WriteTo(output, _repeated_accessConfigs_codec);
      ipv6AccessConfigs_.WriteTo(output, _repeated_ipv6AccessConfigs_codec);
      aliasIpRanges_.WriteTo(output, _repeated_aliasIpRanges_codec);
      if (HasStackType) {
        output.WriteRawTag(80);
        output.WriteEnum((int) StackType);
      }
      if (HasIpv6AccessType) {
        output.WriteRawTag(88);
        output.WriteEnum((int) Ipv6AccessType);
      }
      if (HasQueueCount) {
        output.WriteRawTag(96);
        output.WriteInt32(QueueCount);
      }
      if (HasNicType) {
        output.WriteRawTag(104);
        output.WriteEnum((int) NicType);
      }
      if (HasNetworkAttachment) {
        output.WriteRawTag(114);
        output.WriteString(NetworkAttachment);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasNetwork) {
        output.WriteRawTag(10);
        output.WriteString(Network);
      }
      if (HasSubnetwork) {
        output.WriteRawTag(18);
        output.WriteString(Subnetwork);
      }
      if (HasIpAddress) {
        output.WriteRawTag(26);
        output.WriteString(IpAddress);
      }
      if (HasIpv6Address) {
        output.WriteRawTag(34);
        output.WriteString(Ipv6Address);
      }
      if (HasInternalIpv6PrefixLength) {
        output.WriteRawTag(40);
        output.WriteInt32(InternalIpv6PrefixLength);
      }
      if (HasName) {
        output.WriteRawTag(50);
        output.WriteString(Name);
      }
      accessConfigs_.WriteTo(ref output, _repeated_accessConfigs_codec);
      ipv6AccessConfigs_.WriteTo(ref output, _repeated_ipv6AccessConfigs_codec);
      aliasIpRanges_.WriteTo(ref output, _repeated_aliasIpRanges_codec);
      if (HasStackType) {
        output.WriteRawTag(80);
        output.WriteEnum((int) StackType);
      }
      if (HasIpv6AccessType) {
        output.WriteRawTag(88);
        output.WriteEnum((int) Ipv6AccessType);
      }
      if (HasQueueCount) {
        output.WriteRawTag(96);
        output.WriteInt32(QueueCount);
      }
      if (HasNicType) {
        output.WriteRawTag(104);
        output.WriteEnum((int) NicType);
      }
      if (HasNetworkAttachment) {
        output.WriteRawTag(114);
        output.WriteString(NetworkAttachment);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasNetwork) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Network);
      }
      if (HasSubnetwork) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Subnetwork);
      }
      if (HasIpAddress) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(IpAddress);
      }
      if (HasIpv6Address) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Ipv6Address);
      }
      if (HasInternalIpv6PrefixLength) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(InternalIpv6PrefixLength);
      }
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      size += accessConfigs_.CalculateSize(_repeated_accessConfigs_codec);
      size += ipv6AccessConfigs_.CalculateSize(_repeated_ipv6AccessConfigs_codec);
      size += aliasIpRanges_.CalculateSize(_repeated_aliasIpRanges_codec);
      if (HasStackType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) StackType);
      }
      if (HasIpv6AccessType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Ipv6AccessType);
      }
      if (HasQueueCount) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(QueueCount);
      }
      if (HasNicType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) NicType);
      }
      if (HasNetworkAttachment) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NetworkAttachment);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NetworkInterface other) {
      if (other == null) {
        return;
      }
      if (other.HasNetwork) {
        Network = other.Network;
      }
      if (other.HasSubnetwork) {
        Subnetwork = other.Subnetwork;
      }
      if (other.HasIpAddress) {
        IpAddress = other.IpAddress;
      }
      if (other.HasIpv6Address) {
        Ipv6Address = other.Ipv6Address;
      }
      if (other.HasInternalIpv6PrefixLength) {
        InternalIpv6PrefixLength = other.InternalIpv6PrefixLength;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      accessConfigs_.Add(other.accessConfigs_);
      ipv6AccessConfigs_.Add(other.ipv6AccessConfigs_);
      aliasIpRanges_.Add(other.aliasIpRanges_);
      if (other.HasStackType) {
        StackType = other.StackType;
      }
      if (other.HasIpv6AccessType) {
        Ipv6AccessType = other.Ipv6AccessType;
      }
      if (other.HasQueueCount) {
        QueueCount = other.QueueCount;
      }
      if (other.HasNicType) {
        NicType = other.NicType;
      }
      if (other.HasNetworkAttachment) {
        NetworkAttachment = other.NetworkAttachment;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Network = input.ReadString();
            break;
          }
          case 18: {
            Subnetwork = input.ReadString();
            break;
          }
          case 26: {
            IpAddress = input.ReadString();
            break;
          }
          case 34: {
            Ipv6Address = input.ReadString();
            break;
          }
          case 40: {
            InternalIpv6PrefixLength = input.ReadInt32();
            break;
          }
          case 50: {
            Name = input.ReadString();
            break;
          }
          case 58: {
            accessConfigs_.AddEntriesFrom(input, _repeated_accessConfigs_codec);
            break;
          }
          case 66: {
            ipv6AccessConfigs_.AddEntriesFrom(input, _repeated_ipv6AccessConfigs_codec);
            break;
          }
          case 74: {
            aliasIpRanges_.AddEntriesFrom(input, _repeated_aliasIpRanges_codec);
            break;
          }
          case 80: {
            StackType = (global::Google.Cloud.BackupDR.V1.NetworkInterface.Types.StackType) input.ReadEnum();
            break;
          }
          case 88: {
            Ipv6AccessType = (global::Google.Cloud.BackupDR.V1.NetworkInterface.Types.Ipv6AccessType) input.ReadEnum();
            break;
          }
          case 96: {
            QueueCount = input.ReadInt32();
            break;
          }
          case 104: {
            NicType = (global::Google.Cloud.BackupDR.V1.NetworkInterface.Types.NicType) input.ReadEnum();
            break;
          }
          case 114: {
            NetworkAttachment = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Network = input.ReadString();
            break;
          }
          case 18: {
            Subnetwork = input.ReadString();
            break;
          }
          case 26: {
            IpAddress = input.ReadString();
            break;
          }
          case 34: {
            Ipv6Address = input.ReadString();
            break;
          }
          case 40: {
            InternalIpv6PrefixLength = input.ReadInt32();
            break;
          }
          case 50: {
            Name = input.ReadString();
            break;
          }
          case 58: {
            accessConfigs_.AddEntriesFrom(ref input, _repeated_accessConfigs_codec);
            break;
          }
          case 66: {
            ipv6AccessConfigs_.AddEntriesFrom(ref input, _repeated_ipv6AccessConfigs_codec);
            break;
          }
          case 74: {
            aliasIpRanges_.AddEntriesFrom(ref input, _repeated_aliasIpRanges_codec);
            break;
          }
          case 80: {
            StackType = (global::Google.Cloud.BackupDR.V1.NetworkInterface.Types.StackType) input.ReadEnum();
            break;
          }
          case 88: {
            Ipv6AccessType = (global::Google.Cloud.BackupDR.V1.NetworkInterface.Types.Ipv6AccessType) input.ReadEnum();
            break;
          }
          case 96: {
            QueueCount = input.ReadInt32();
            break;
          }
          case 104: {
            NicType = (global::Google.Cloud.BackupDR.V1.NetworkInterface.Types.NicType) input.ReadEnum();
            break;
          }
          case 114: {
            NetworkAttachment = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the NetworkInterface message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Stack type for this network interface.
      /// </summary>
      public enum StackType {
        /// <summary>
        /// Default should be STACK_TYPE_UNSPECIFIED.
        /// </summary>
        [pbr::OriginalName("STACK_TYPE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// The network interface will be assigned IPv4 address.
        /// </summary>
        [pbr::OriginalName("IPV4_ONLY")] Ipv4Only = 1,
        /// <summary>
        /// The network interface can have both IPv4 and IPv6 addresses.
        /// </summary>
        [pbr::OriginalName("IPV4_IPV6")] Ipv4Ipv6 = 2,
      }

      /// <summary>
      /// IPv6 access type for this network interface.
      /// </summary>
      public enum Ipv6AccessType {
        /// <summary>
        /// IPv6 access type not set. Means this network interface hasn't been
        /// turned on IPv6 yet.
        /// </summary>
        [pbr::OriginalName("UNSPECIFIED_IPV6_ACCESS_TYPE")] UnspecifiedIpv6AccessType = 0,
        /// <summary>
        /// This network interface can have internal IPv6.
        /// </summary>
        [pbr::OriginalName("INTERNAL")] Internal = 1,
        /// <summary>
        /// This network interface can have external IPv6.
        /// </summary>
        [pbr::OriginalName("EXTERNAL")] External = 2,
      }

      /// <summary>
      /// Nic type for this network interface.
      /// </summary>
      public enum NicType {
        /// <summary>
        /// Default should be NIC_TYPE_UNSPECIFIED.
        /// </summary>
        [pbr::OriginalName("NIC_TYPE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// VIRTIO
        /// </summary>
        [pbr::OriginalName("VIRTIO_NET")] VirtioNet = 1,
        /// <summary>
        /// GVNIC
        /// </summary>
        [pbr::OriginalName("GVNIC")] Gvnic = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// Network performance configuration.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class NetworkPerformanceConfig : pb::IMessage<NetworkPerformanceConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NetworkPerformanceConfig> _parser = new pb::MessageParser<NetworkPerformanceConfig>(() => new NetworkPerformanceConfig());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NetworkPerformanceConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.BackupDR.V1.BackupvaultGceReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPerformanceConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPerformanceConfig(NetworkPerformanceConfig other) : this() {
      _hasBits0 = other._hasBits0;
      totalEgressBandwidthTier_ = other.totalEgressBandwidthTier_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPerformanceConfig Clone() {
      return new NetworkPerformanceConfig(this);
    }

    /// <summary>Field number for the "total_egress_bandwidth_tier" field.</summary>
    public const int TotalEgressBandwidthTierFieldNumber = 1;
    private readonly static global::Google.Cloud.BackupDR.V1.NetworkPerformanceConfig.Types.Tier TotalEgressBandwidthTierDefaultValue = global::Google.Cloud.BackupDR.V1.NetworkPerformanceConfig.Types.Tier.Unspecified;

    private global::Google.Cloud.BackupDR.V1.NetworkPerformanceConfig.Types.Tier totalEgressBandwidthTier_;
    /// <summary>
    /// Optional. The tier of the total egress bandwidth.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.NetworkPerformanceConfig.Types.Tier TotalEgressBandwidthTier {
      get { if ((_hasBits0 & 1) != 0) { return totalEgressBandwidthTier_; } else { return TotalEgressBandwidthTierDefaultValue; } }
      set {
        _hasBits0 |= 1;
        totalEgressBandwidthTier_ = value;
      }
    }
    /// <summary>Gets whether the "total_egress_bandwidth_tier" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTotalEgressBandwidthTier {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "total_egress_bandwidth_tier" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTotalEgressBandwidthTier() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NetworkPerformanceConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NetworkPerformanceConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TotalEgressBandwidthTier != other.TotalEgressBandwidthTier) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasTotalEgressBandwidthTier) hash ^= TotalEgressBandwidthTier.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasTotalEgressBandwidthTier) {
        output.WriteRawTag(8);
        output.WriteEnum((int) TotalEgressBandwidthTier);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasTotalEgressBandwidthTier) {
        output.WriteRawTag(8);
        output.WriteEnum((int) TotalEgressBandwidthTier);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasTotalEgressBandwidthTier) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TotalEgressBandwidthTier);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NetworkPerformanceConfig other) {
      if (other == null) {
        return;
      }
      if (other.HasTotalEgressBandwidthTier) {
        TotalEgressBandwidthTier = other.TotalEgressBandwidthTier;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            TotalEgressBandwidthTier = (global::Google.Cloud.BackupDR.V1.NetworkPerformanceConfig.Types.Tier) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            TotalEgressBandwidthTier = (global::Google.Cloud.BackupDR.V1.NetworkPerformanceConfig.Types.Tier) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the NetworkPerformanceConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Network performance tier.
      /// </summary>
      public enum Tier {
        /// <summary>
        /// This value is unused.
        /// </summary>
        [pbr::OriginalName("TIER_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Default network performance config.
        /// </summary>
        [pbr::OriginalName("DEFAULT")] Default = 1,
        /// <summary>
        /// Tier 1 network performance config.
        /// </summary>
        [pbr::OriginalName("TIER_1")] _1 = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// An access configuration attached to an instance's network interface.
  /// Only one access config per instance is supported.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class AccessConfig : pb::IMessage<AccessConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AccessConfig> _parser = new pb::MessageParser<AccessConfig>(() => new AccessConfig());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AccessConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.BackupDR.V1.BackupvaultGceReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AccessConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AccessConfig(AccessConfig other) : this() {
      _hasBits0 = other._hasBits0;
      type_ = other.type_;
      name_ = other.name_;
      externalIp_ = other.externalIp_;
      externalIpv6_ = other.externalIpv6_;
      externalIpv6PrefixLength_ = other.externalIpv6PrefixLength_;
      setPublicPtr_ = other.setPublicPtr_;
      publicPtrDomainName_ = other.publicPtrDomainName_;
      networkTier_ = other.networkTier_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AccessConfig Clone() {
      return new AccessConfig(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private readonly static global::Google.Cloud.BackupDR.V1.AccessConfig.Types.AccessType TypeDefaultValue = global::Google.Cloud.BackupDR.V1.AccessConfig.Types.AccessType.Unspecified;

    private global::Google.Cloud.BackupDR.V1.AccessConfig.Types.AccessType type_;
    /// <summary>
    /// Optional. In accessConfigs (IPv4), the
    ///  default and only option is ONE_TO_ONE_NAT. In
    ///  ipv6AccessConfigs, the default and only option is
    ///  DIRECT_IPV6.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.AccessConfig.Types.AccessType Type {
      get { if ((_hasBits0 & 1) != 0) { return type_; } else { return TypeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        type_ = value;
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 2;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// Optional. The name of this access configuration.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "external_ip" field.</summary>
    public const int ExternalIpFieldNumber = 3;
    private readonly static string ExternalIpDefaultValue = "";

    private string externalIp_;
    /// <summary>
    /// Optional. The external IP address of this access configuration.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ExternalIp {
      get { return externalIp_ ?? ExternalIpDefaultValue; }
      set {
        externalIp_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "external_ip" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasExternalIp {
      get { return externalIp_ != null; }
    }
    /// <summary>Clears the value of the "external_ip" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearExternalIp() {
      externalIp_ = null;
    }

    /// <summary>Field number for the "external_ipv6" field.</summary>
    public const int ExternalIpv6FieldNumber = 4;
    private readonly static string ExternalIpv6DefaultValue = "";

    private string externalIpv6_;
    /// <summary>
    /// Optional. The external IPv6 address of this access configuration.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ExternalIpv6 {
      get { return externalIpv6_ ?? ExternalIpv6DefaultValue; }
      set {
        externalIpv6_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "external_ipv6" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasExternalIpv6 {
      get { return externalIpv6_ != null; }
    }
    /// <summary>Clears the value of the "external_ipv6" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearExternalIpv6() {
      externalIpv6_ = null;
    }

    /// <summary>Field number for the "external_ipv6_prefix_length" field.</summary>
    public const int ExternalIpv6PrefixLengthFieldNumber = 5;
    private readonly static int ExternalIpv6PrefixLengthDefaultValue = 0;

    private int externalIpv6PrefixLength_;
    /// <summary>
    /// Optional. The prefix length of the external IPv6 range.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int ExternalIpv6PrefixLength {
      get { if ((_hasBits0 & 2) != 0) { return externalIpv6PrefixLength_; } else { return ExternalIpv6PrefixLengthDefaultValue; } }
      set {
        _hasBits0 |= 2;
        externalIpv6PrefixLength_ = value;
      }
    }
    /// <summary>Gets whether the "external_ipv6_prefix_length" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasExternalIpv6PrefixLength {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "external_ipv6_prefix_length" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearExternalIpv6PrefixLength() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "set_public_ptr" field.</summary>
    public const int SetPublicPtrFieldNumber = 6;
    private readonly static bool SetPublicPtrDefaultValue = false;

    private bool setPublicPtr_;
    /// <summary>
    /// Optional. Specifies whether a public DNS 'PTR' record should be created to
    /// map the external IP address of the instance to a DNS domain name.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool SetPublicPtr {
      get { if ((_hasBits0 & 4) != 0) { return setPublicPtr_; } else { return SetPublicPtrDefaultValue; } }
      set {
        _hasBits0 |= 4;
        setPublicPtr_ = value;
      }
    }
    /// <summary>Gets whether the "set_public_ptr" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSetPublicPtr {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "set_public_ptr" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSetPublicPtr() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "public_ptr_domain_name" field.</summary>
    public const int PublicPtrDomainNameFieldNumber = 7;
    private readonly static string PublicPtrDomainNameDefaultValue = "";

    private string publicPtrDomainName_;
    /// <summary>
    /// Optional. The DNS domain name for the public PTR record.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string PublicPtrDomainName {
      get { return publicPtrDomainName_ ?? PublicPtrDomainNameDefaultValue; }
      set {
        publicPtrDomainName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "public_ptr_domain_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPublicPtrDomainName {
      get { return publicPtrDomainName_ != null; }
    }
    /// <summary>Clears the value of the "public_ptr_domain_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPublicPtrDomainName() {
      publicPtrDomainName_ = null;
    }

    /// <summary>Field number for the "network_tier" field.</summary>
    public const int NetworkTierFieldNumber = 8;
    private readonly static global::Google.Cloud.BackupDR.V1.AccessConfig.Types.NetworkTier NetworkTierDefaultValue = global::Google.Cloud.BackupDR.V1.AccessConfig.Types.NetworkTier.Unspecified;

    private global::Google.Cloud.BackupDR.V1.AccessConfig.Types.NetworkTier networkTier_;
    /// <summary>
    /// Optional. This signifies the networking tier used for configuring this
    /// access
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.AccessConfig.Types.NetworkTier NetworkTier {
      get { if ((_hasBits0 & 8) != 0) { return networkTier_; } else { return NetworkTierDefaultValue; } }
      set {
        _hasBits0 |= 8;
        networkTier_ = value;
      }
    }
    /// <summary>Gets whether the "network_tier" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNetworkTier {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "network_tier" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNetworkTier() {
      _hasBits0 &= ~8;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AccessConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AccessConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (Name != other.Name) return false;
      if (ExternalIp != other.ExternalIp) return false;
      if (ExternalIpv6 != other.ExternalIpv6) return false;
      if (ExternalIpv6PrefixLength != other.ExternalIpv6PrefixLength) return false;
      if (SetPublicPtr != other.SetPublicPtr) return false;
      if (PublicPtrDomainName != other.PublicPtrDomainName) return false;
      if (NetworkTier != other.NetworkTier) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasType) hash ^= Type.GetHashCode();
      if (HasName) hash ^= Name.GetHashCode();
      if (HasExternalIp) hash ^= ExternalIp.GetHashCode();
      if (HasExternalIpv6) hash ^= ExternalIpv6.GetHashCode();
      if (HasExternalIpv6PrefixLength) hash ^= ExternalIpv6PrefixLength.GetHashCode();
      if (HasSetPublicPtr) hash ^= SetPublicPtr.GetHashCode();
      if (HasPublicPtrDomainName) hash ^= PublicPtrDomainName.GetHashCode();
      if (HasNetworkTier) hash ^= NetworkTier.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (HasName) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      if (HasExternalIp) {
        output.WriteRawTag(26);
        output.WriteString(ExternalIp);
      }
      if (HasExternalIpv6) {
        output.WriteRawTag(34);
        output.WriteString(ExternalIpv6);
      }
      if (HasExternalIpv6PrefixLength) {
        output.WriteRawTag(40);
        output.WriteInt32(ExternalIpv6PrefixLength);
      }
      if (HasSetPublicPtr) {
        output.WriteRawTag(48);
        output.WriteBool(SetPublicPtr);
      }
      if (HasPublicPtrDomainName) {
        output.WriteRawTag(58);
        output.WriteString(PublicPtrDomainName);
      }
      if (HasNetworkTier) {
        output.WriteRawTag(64);
        output.WriteEnum((int) NetworkTier);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (HasName) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      if (HasExternalIp) {
        output.WriteRawTag(26);
        output.WriteString(ExternalIp);
      }
      if (HasExternalIpv6) {
        output.WriteRawTag(34);
        output.WriteString(ExternalIpv6);
      }
      if (HasExternalIpv6PrefixLength) {
        output.WriteRawTag(40);
        output.WriteInt32(ExternalIpv6PrefixLength);
      }
      if (HasSetPublicPtr) {
        output.WriteRawTag(48);
        output.WriteBool(SetPublicPtr);
      }
      if (HasPublicPtrDomainName) {
        output.WriteRawTag(58);
        output.WriteString(PublicPtrDomainName);
      }
      if (HasNetworkTier) {
        output.WriteRawTag(64);
        output.WriteEnum((int) NetworkTier);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasExternalIp) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ExternalIp);
      }
      if (HasExternalIpv6) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ExternalIpv6);
      }
      if (HasExternalIpv6PrefixLength) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ExternalIpv6PrefixLength);
      }
      if (HasSetPublicPtr) {
        size += 1 + 1;
      }
      if (HasPublicPtrDomainName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PublicPtrDomainName);
      }
      if (HasNetworkTier) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) NetworkTier);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AccessConfig other) {
      if (other == null) {
        return;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasExternalIp) {
        ExternalIp = other.ExternalIp;
      }
      if (other.HasExternalIpv6) {
        ExternalIpv6 = other.ExternalIpv6;
      }
      if (other.HasExternalIpv6PrefixLength) {
        ExternalIpv6PrefixLength = other.ExternalIpv6PrefixLength;
      }
      if (other.HasSetPublicPtr) {
        SetPublicPtr = other.SetPublicPtr;
      }
      if (other.HasPublicPtrDomainName) {
        PublicPtrDomainName = other.PublicPtrDomainName;
      }
      if (other.HasNetworkTier) {
        NetworkTier = other.NetworkTier;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Type = (global::Google.Cloud.BackupDR.V1.AccessConfig.Types.AccessType) input.ReadEnum();
            break;
          }
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 26: {
            ExternalIp = input.ReadString();
            break;
          }
          case 34: {
            ExternalIpv6 = input.ReadString();
            break;
          }
          case 40: {
            ExternalIpv6PrefixLength = input.ReadInt32();
            break;
          }
          case 48: {
            SetPublicPtr = input.ReadBool();
            break;
          }
          case 58: {
            PublicPtrDomainName = input.ReadString();
            break;
          }
          case 64: {
            NetworkTier = (global::Google.Cloud.BackupDR.V1.AccessConfig.Types.NetworkTier) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Type = (global::Google.Cloud.BackupDR.V1.AccessConfig.Types.AccessType) input.ReadEnum();
            break;
          }
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 26: {
            ExternalIp = input.ReadString();
            break;
          }
          case 34: {
            ExternalIpv6 = input.ReadString();
            break;
          }
          case 40: {
            ExternalIpv6PrefixLength = input.ReadInt32();
            break;
          }
          case 48: {
            SetPublicPtr = input.ReadBool();
            break;
          }
          case 58: {
            PublicPtrDomainName = input.ReadString();
            break;
          }
          case 64: {
            NetworkTier = (global::Google.Cloud.BackupDR.V1.AccessConfig.Types.NetworkTier) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the AccessConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// The type of configuration.
      /// </summary>
      public enum AccessType {
        /// <summary>
        /// Default value. This value is unused.
        /// </summary>
        [pbr::OriginalName("ACCESS_TYPE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// ONE_TO_ONE_NAT
        /// </summary>
        [pbr::OriginalName("ONE_TO_ONE_NAT")] OneToOneNat = 1,
        /// <summary>
        /// Direct IPv6 access.
        /// </summary>
        [pbr::OriginalName("DIRECT_IPV6")] DirectIpv6 = 2,
      }

      /// <summary>
      /// Network tier property used by addresses, instances and forwarding rules.
      /// </summary>
      public enum NetworkTier {
        /// <summary>
        /// Default value. This value is unused.
        /// </summary>
        [pbr::OriginalName("NETWORK_TIER_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// High quality, Google-grade network tier, support for all networking
        /// products.
        /// </summary>
        [pbr::OriginalName("PREMIUM")] Premium = 1,
        /// <summary>
        /// Public internet quality, only limited support for other networking
        /// products.
        /// </summary>
        [pbr::OriginalName("STANDARD")] Standard = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// An alias IP range attached to an instance's network interface.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class AliasIpRange : pb::IMessage<AliasIpRange>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AliasIpRange> _parser = new pb::MessageParser<AliasIpRange>(() => new AliasIpRange());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AliasIpRange> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.BackupDR.V1.BackupvaultGceReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AliasIpRange() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AliasIpRange(AliasIpRange other) : this() {
      ipCidrRange_ = other.ipCidrRange_;
      subnetworkRangeName_ = other.subnetworkRangeName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AliasIpRange Clone() {
      return new AliasIpRange(this);
    }

    /// <summary>Field number for the "ip_cidr_range" field.</summary>
    public const int IpCidrRangeFieldNumber = 1;
    private readonly static string IpCidrRangeDefaultValue = "";

    private string ipCidrRange_;
    /// <summary>
    /// Optional. The IP alias ranges to allocate for this interface.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string IpCidrRange {
      get { return ipCidrRange_ ?? IpCidrRangeDefaultValue; }
      set {
        ipCidrRange_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "ip_cidr_range" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIpCidrRange {
      get { return ipCidrRange_ != null; }
    }
    /// <summary>Clears the value of the "ip_cidr_range" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIpCidrRange() {
      ipCidrRange_ = null;
    }

    /// <summary>Field number for the "subnetwork_range_name" field.</summary>
    public const int SubnetworkRangeNameFieldNumber = 2;
    private readonly static string SubnetworkRangeNameDefaultValue = "";

    private string subnetworkRangeName_;
    /// <summary>
    /// Optional. The name of a subnetwork secondary IP range from which to
    /// allocate an IP alias range. If not specified, the primary range of the
    /// subnetwork is used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SubnetworkRangeName {
      get { return subnetworkRangeName_ ?? SubnetworkRangeNameDefaultValue; }
      set {
        subnetworkRangeName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "subnetwork_range_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSubnetworkRangeName {
      get { return subnetworkRangeName_ != null; }
    }
    /// <summary>Clears the value of the "subnetwork_range_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSubnetworkRangeName() {
      subnetworkRangeName_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AliasIpRange);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AliasIpRange other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (IpCidrRange != other.IpCidrRange) return false;
      if (SubnetworkRangeName != other.SubnetworkRangeName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasIpCidrRange) hash ^= IpCidrRange.GetHashCode();
      if (HasSubnetworkRangeName) hash ^= SubnetworkRangeName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasIpCidrRange) {
        output.WriteRawTag(10);
        output.WriteString(IpCidrRange);
      }
      if (HasSubnetworkRangeName) {
        output.WriteRawTag(18);
        output.WriteString(SubnetworkRangeName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasIpCidrRange) {
        output.WriteRawTag(10);
        output.WriteString(IpCidrRange);
      }
      if (HasSubnetworkRangeName) {
        output.WriteRawTag(18);
        output.WriteString(SubnetworkRangeName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasIpCidrRange) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(IpCidrRange);
      }
      if (HasSubnetworkRangeName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SubnetworkRangeName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AliasIpRange other) {
      if (other == null) {
        return;
      }
      if (other.HasIpCidrRange) {
        IpCidrRange = other.IpCidrRange;
      }
      if (other.HasSubnetworkRangeName) {
        SubnetworkRangeName = other.SubnetworkRangeName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            IpCidrRange = input.ReadString();
            break;
          }
          case 18: {
            SubnetworkRangeName = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            IpCidrRange = input.ReadString();
            break;
          }
          case 18: {
            SubnetworkRangeName = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Additional instance params.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class InstanceParams : pb::IMessage<InstanceParams>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<InstanceParams> _parser = new pb::MessageParser<InstanceParams>(() => new InstanceParams());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<InstanceParams> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.BackupDR.V1.BackupvaultGceReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstanceParams() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstanceParams(InstanceParams other) : this() {
      resourceManagerTags_ = other.resourceManagerTags_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public InstanceParams Clone() {
      return new InstanceParams(this);
    }

    /// <summary>Field number for the "resource_manager_tags" field.</summary>
    public const int ResourceManagerTagsFieldNumber = 1;
    private static readonly pbc::MapField<string, string>.Codec _map_resourceManagerTags_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 10);
    private readonly pbc::MapField<string, string> resourceManagerTags_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Optional. Resource manager tags to be bound to the instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, string> ResourceManagerTags {
      get { return resourceManagerTags_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as InstanceParams);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(InstanceParams other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!ResourceManagerTags.Equals(other.ResourceManagerTags)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= ResourceManagerTags.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      resourceManagerTags_.WriteTo(output, _map_resourceManagerTags_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      resourceManagerTags_.WriteTo(ref output, _map_resourceManagerTags_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += resourceManagerTags_.CalculateSize(_map_resourceManagerTags_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(InstanceParams other) {
      if (other == null) {
        return;
      }
      resourceManagerTags_.MergeFrom(other.resourceManagerTags_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            resourceManagerTags_.AddEntriesFrom(input, _map_resourceManagerTags_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            resourceManagerTags_.AddEntriesFrom(ref input, _map_resourceManagerTags_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Specifies the reservations that this instance can consume from.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class AllocationAffinity : pb::IMessage<AllocationAffinity>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AllocationAffinity> _parser = new pb::MessageParser<AllocationAffinity>(() => new AllocationAffinity());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AllocationAffinity> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.BackupDR.V1.BackupvaultGceReflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AllocationAffinity() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AllocationAffinity(AllocationAffinity other) : this() {
      _hasBits0 = other._hasBits0;
      consumeAllocationType_ = other.consumeAllocationType_;
      key_ = other.key_;
      values_ = other.values_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AllocationAffinity Clone() {
      return new AllocationAffinity(this);
    }

    /// <summary>Field number for the "consume_allocation_type" field.</summary>
    public const int ConsumeAllocationTypeFieldNumber = 1;
    private readonly static global::Google.Cloud.BackupDR.V1.AllocationAffinity.Types.Type ConsumeAllocationTypeDefaultValue = global::Google.Cloud.BackupDR.V1.AllocationAffinity.Types.Type.Unspecified;

    private global::Google.Cloud.BackupDR.V1.AllocationAffinity.Types.Type consumeAllocationType_;
    /// <summary>
    /// Optional. Specifies the type of reservation from which this instance can
    /// consume
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.AllocationAffinity.Types.Type ConsumeAllocationType {
      get { if ((_hasBits0 & 1) != 0) { return consumeAllocationType_; } else { return ConsumeAllocationTypeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        consumeAllocationType_ = value;
      }
    }
    /// <summary>Gets whether the "consume_allocation_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConsumeAllocationType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "consume_allocation_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConsumeAllocationType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 2;
    private readonly static string KeyDefaultValue = "";

    private string key_;
    /// <summary>
    /// Optional. Corresponds to the label key of a reservation resource.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Key {
      get { return key_ ?? KeyDefaultValue; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKey {
      get { return key_ != null; }
    }
    /// <summary>Clears the value of the "key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKey() {
      key_ = null;
    }

    /// <summary>Field number for the "values" field.</summary>
    public const int ValuesFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_values_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> values_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Optional. Corresponds to the label values of a reservation resource.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Values {
      get { return values_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AllocationAffinity);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AllocationAffinity other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ConsumeAllocationType != other.ConsumeAllocationType) return false;
      if (Key != other.Key) return false;
      if(!values_.Equals(other.values_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasConsumeAllocationType) hash ^= ConsumeAllocationType.GetHashCode();
      if (HasKey) hash ^= Key.GetHashCode();
      hash ^= values_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasConsumeAllocationType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) ConsumeAllocationType);
      }
      if (HasKey) {
        output.WriteRawTag(18);
        output.WriteString(Key);
      }
      values_.WriteTo(output, _repeated_values_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasConsumeAllocationType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) ConsumeAllocationType);
      }
      if (HasKey) {
        output.WriteRawTag(18);
        output.WriteString(Key);
      }
      values_.WriteTo(ref output, _repeated_values_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasConsumeAllocationType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ConsumeAllocationType);
      }
      if (HasKey) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
      }
      size += values_.CalculateSize(_repeated_values_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AllocationAffinity other) {
      if (other == null) {
        return;
      }
      if (other.HasConsumeAllocationType) {
        ConsumeAllocationType = other.ConsumeAllocationType;
      }
      if (other.HasKey) {
        Key = other.Key;
      }
      values_.Add(other.values_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ConsumeAllocationType = (global::Google.Cloud.BackupDR.V1.AllocationAffinity.Types.Type) input.ReadEnum();
            break;
          }
          case 18: {
            Key = input.ReadString();
            break;
          }
          case 26: {
            values_.AddEntriesFrom(input, _repeated_values_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ConsumeAllocationType = (global::Google.Cloud.BackupDR.V1.AllocationAffinity.Types.Type) input.ReadEnum();
            break;
          }
          case 18: {
            Key = input.ReadString();
            break;
          }
          case 26: {
            values_.AddEntriesFrom(ref input, _repeated_values_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the AllocationAffinity message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Indicates whether to consume from a reservation or not.
      /// </summary>
      public enum Type {
        /// <summary>
        /// Default value. This value is unused.
        /// </summary>
        [pbr::OriginalName("TYPE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Do not consume from any allocated capacity.
        /// </summary>
        [pbr::OriginalName("NO_RESERVATION")] NoReservation = 1,
        /// <summary>
        /// Consume any allocation available.
        /// </summary>
        [pbr::OriginalName("ANY_RESERVATION")] AnyReservation = 2,
        /// <summary>
        /// Must consume from a specific reservation. Must specify key value fields
        /// for specifying the reservations.
        /// </summary>
        [pbr::OriginalName("SPECIFIC_RESERVATION")] SpecificReservation = 3,
      }

    }
    #endregion

  }

  /// <summary>
  /// Sets the scheduling options for an Instance.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Scheduling : pb::IMessage<Scheduling>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Scheduling> _parser = new pb::MessageParser<Scheduling>(() => new Scheduling());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Scheduling> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.BackupDR.V1.BackupvaultGceReflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Scheduling() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Scheduling(Scheduling other) : this() {
      _hasBits0 = other._hasBits0;
      onHostMaintenance_ = other.onHostMaintenance_;
      automaticRestart_ = other.automaticRestart_;
      preemptible_ = other.preemptible_;
      nodeAffinities_ = other.nodeAffinities_.Clone();
      minNodeCpus_ = other.minNodeCpus_;
      provisioningModel_ = other.provisioningModel_;
      instanceTerminationAction_ = other.instanceTerminationAction_;
      localSsdRecoveryTimeout_ = other.localSsdRecoveryTimeout_ != null ? other.localSsdRecoveryTimeout_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Scheduling Clone() {
      return new Scheduling(this);
    }

    /// <summary>Field number for the "on_host_maintenance" field.</summary>
    public const int OnHostMaintenanceFieldNumber = 1;
    private readonly static global::Google.Cloud.BackupDR.V1.Scheduling.Types.OnHostMaintenance OnHostMaintenanceDefaultValue = global::Google.Cloud.BackupDR.V1.Scheduling.Types.OnHostMaintenance.Unspecified;

    private global::Google.Cloud.BackupDR.V1.Scheduling.Types.OnHostMaintenance onHostMaintenance_;
    /// <summary>
    /// Optional. Defines the maintenance behavior for this instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.Scheduling.Types.OnHostMaintenance OnHostMaintenance {
      get { if ((_hasBits0 & 1) != 0) { return onHostMaintenance_; } else { return OnHostMaintenanceDefaultValue; } }
      set {
        _hasBits0 |= 1;
        onHostMaintenance_ = value;
      }
    }
    /// <summary>Gets whether the "on_host_maintenance" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOnHostMaintenance {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "on_host_maintenance" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOnHostMaintenance() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "automatic_restart" field.</summary>
    public const int AutomaticRestartFieldNumber = 2;
    private readonly static bool AutomaticRestartDefaultValue = false;

    private bool automaticRestart_;
    /// <summary>
    /// Optional. Specifies whether the instance should be automatically restarted
    /// if it is terminated by Compute Engine (not terminated by a user).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AutomaticRestart {
      get { if ((_hasBits0 & 2) != 0) { return automaticRestart_; } else { return AutomaticRestartDefaultValue; } }
      set {
        _hasBits0 |= 2;
        automaticRestart_ = value;
      }
    }
    /// <summary>Gets whether the "automatic_restart" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAutomaticRestart {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "automatic_restart" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAutomaticRestart() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "preemptible" field.</summary>
    public const int PreemptibleFieldNumber = 3;
    private readonly static bool PreemptibleDefaultValue = false;

    private bool preemptible_;
    /// <summary>
    /// Optional. Defines whether the instance is preemptible.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Preemptible {
      get { if ((_hasBits0 & 4) != 0) { return preemptible_; } else { return PreemptibleDefaultValue; } }
      set {
        _hasBits0 |= 4;
        preemptible_ = value;
      }
    }
    /// <summary>Gets whether the "preemptible" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPreemptible {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "preemptible" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPreemptible() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "node_affinities" field.</summary>
    public const int NodeAffinitiesFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Google.Cloud.BackupDR.V1.Scheduling.Types.NodeAffinity> _repeated_nodeAffinities_codec
        = pb::FieldCodec.ForMessage(34, global::Google.Cloud.BackupDR.V1.Scheduling.Types.NodeAffinity.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.Scheduling.Types.NodeAffinity> nodeAffinities_ = new pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.Scheduling.Types.NodeAffinity>();
    /// <summary>
    /// Optional. A set of node affinity and anti-affinity configurations.
    /// Overrides reservationAffinity.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.Scheduling.Types.NodeAffinity> NodeAffinities {
      get { return nodeAffinities_; }
    }

    /// <summary>Field number for the "min_node_cpus" field.</summary>
    public const int MinNodeCpusFieldNumber = 5;
    private readonly static int MinNodeCpusDefaultValue = 0;

    private int minNodeCpus_;
    /// <summary>
    /// Optional. The minimum number of virtual CPUs this instance will consume
    /// when running on a sole-tenant node.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MinNodeCpus {
      get { if ((_hasBits0 & 8) != 0) { return minNodeCpus_; } else { return MinNodeCpusDefaultValue; } }
      set {
        _hasBits0 |= 8;
        minNodeCpus_ = value;
      }
    }
    /// <summary>Gets whether the "min_node_cpus" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinNodeCpus {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "min_node_cpus" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinNodeCpus() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "provisioning_model" field.</summary>
    public const int ProvisioningModelFieldNumber = 6;
    private readonly static global::Google.Cloud.BackupDR.V1.Scheduling.Types.ProvisioningModel ProvisioningModelDefaultValue = global::Google.Cloud.BackupDR.V1.Scheduling.Types.ProvisioningModel.Unspecified;

    private global::Google.Cloud.BackupDR.V1.Scheduling.Types.ProvisioningModel provisioningModel_;
    /// <summary>
    /// Optional. Specifies the provisioning model of the instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.Scheduling.Types.ProvisioningModel ProvisioningModel {
      get { if ((_hasBits0 & 16) != 0) { return provisioningModel_; } else { return ProvisioningModelDefaultValue; } }
      set {
        _hasBits0 |= 16;
        provisioningModel_ = value;
      }
    }
    /// <summary>Gets whether the "provisioning_model" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasProvisioningModel {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "provisioning_model" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearProvisioningModel() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "instance_termination_action" field.</summary>
    public const int InstanceTerminationActionFieldNumber = 7;
    private readonly static global::Google.Cloud.BackupDR.V1.Scheduling.Types.InstanceTerminationAction InstanceTerminationActionDefaultValue = global::Google.Cloud.BackupDR.V1.Scheduling.Types.InstanceTerminationAction.Unspecified;

    private global::Google.Cloud.BackupDR.V1.Scheduling.Types.InstanceTerminationAction instanceTerminationAction_;
    /// <summary>
    /// Optional. Specifies the termination action for the instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.Scheduling.Types.InstanceTerminationAction InstanceTerminationAction {
      get { if ((_hasBits0 & 32) != 0) { return instanceTerminationAction_; } else { return InstanceTerminationActionDefaultValue; } }
      set {
        _hasBits0 |= 32;
        instanceTerminationAction_ = value;
      }
    }
    /// <summary>Gets whether the "instance_termination_action" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasInstanceTerminationAction {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "instance_termination_action" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearInstanceTerminationAction() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "local_ssd_recovery_timeout" field.</summary>
    public const int LocalSsdRecoveryTimeoutFieldNumber = 10;
    private global::Google.Cloud.BackupDR.V1.SchedulingDuration localSsdRecoveryTimeout_;
    /// <summary>
    /// Optional. Specifies the maximum amount of time a Local Ssd Vm should wait
    /// while recovery of the Local Ssd state is attempted. Its value should be in
    /// between 0 and 168 hours with hour granularity and the default value being 1
    /// hour.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.SchedulingDuration LocalSsdRecoveryTimeout {
      get { return localSsdRecoveryTimeout_; }
      set {
        localSsdRecoveryTimeout_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Scheduling);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Scheduling other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (OnHostMaintenance != other.OnHostMaintenance) return false;
      if (AutomaticRestart != other.AutomaticRestart) return false;
      if (Preemptible != other.Preemptible) return false;
      if(!nodeAffinities_.Equals(other.nodeAffinities_)) return false;
      if (MinNodeCpus != other.MinNodeCpus) return false;
      if (ProvisioningModel != other.ProvisioningModel) return false;
      if (InstanceTerminationAction != other.InstanceTerminationAction) return false;
      if (!object.Equals(LocalSsdRecoveryTimeout, other.LocalSsdRecoveryTimeout)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasOnHostMaintenance) hash ^= OnHostMaintenance.GetHashCode();
      if (HasAutomaticRestart) hash ^= AutomaticRestart.GetHashCode();
      if (HasPreemptible) hash ^= Preemptible.GetHashCode();
      hash ^= nodeAffinities_.GetHashCode();
      if (HasMinNodeCpus) hash ^= MinNodeCpus.GetHashCode();
      if (HasProvisioningModel) hash ^= ProvisioningModel.GetHashCode();
      if (HasInstanceTerminationAction) hash ^= InstanceTerminationAction.GetHashCode();
      if (localSsdRecoveryTimeout_ != null) hash ^= LocalSsdRecoveryTimeout.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasOnHostMaintenance) {
        output.WriteRawTag(8);
        output.WriteEnum((int) OnHostMaintenance);
      }
      if (HasAutomaticRestart) {
        output.WriteRawTag(16);
        output.WriteBool(AutomaticRestart);
      }
      if (HasPreemptible) {
        output.WriteRawTag(24);
        output.WriteBool(Preemptible);
      }
      nodeAffinities_.WriteTo(output, _repeated_nodeAffinities_codec);
      if (HasMinNodeCpus) {
        output.WriteRawTag(40);
        output.WriteInt32(MinNodeCpus);
      }
      if (HasProvisioningModel) {
        output.WriteRawTag(48);
        output.WriteEnum((int) ProvisioningModel);
      }
      if (HasInstanceTerminationAction) {
        output.WriteRawTag(56);
        output.WriteEnum((int) InstanceTerminationAction);
      }
      if (localSsdRecoveryTimeout_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(LocalSsdRecoveryTimeout);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasOnHostMaintenance) {
        output.WriteRawTag(8);
        output.WriteEnum((int) OnHostMaintenance);
      }
      if (HasAutomaticRestart) {
        output.WriteRawTag(16);
        output.WriteBool(AutomaticRestart);
      }
      if (HasPreemptible) {
        output.WriteRawTag(24);
        output.WriteBool(Preemptible);
      }
      nodeAffinities_.WriteTo(ref output, _repeated_nodeAffinities_codec);
      if (HasMinNodeCpus) {
        output.WriteRawTag(40);
        output.WriteInt32(MinNodeCpus);
      }
      if (HasProvisioningModel) {
        output.WriteRawTag(48);
        output.WriteEnum((int) ProvisioningModel);
      }
      if (HasInstanceTerminationAction) {
        output.WriteRawTag(56);
        output.WriteEnum((int) InstanceTerminationAction);
      }
      if (localSsdRecoveryTimeout_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(LocalSsdRecoveryTimeout);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasOnHostMaintenance) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) OnHostMaintenance);
      }
      if (HasAutomaticRestart) {
        size += 1 + 1;
      }
      if (HasPreemptible) {
        size += 1 + 1;
      }
      size += nodeAffinities_.CalculateSize(_repeated_nodeAffinities_codec);
      if (HasMinNodeCpus) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MinNodeCpus);
      }
      if (HasProvisioningModel) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ProvisioningModel);
      }
      if (HasInstanceTerminationAction) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) InstanceTerminationAction);
      }
      if (localSsdRecoveryTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocalSsdRecoveryTimeout);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Scheduling other) {
      if (other == null) {
        return;
      }
      if (other.HasOnHostMaintenance) {
        OnHostMaintenance = other.OnHostMaintenance;
      }
      if (other.HasAutomaticRestart) {
        AutomaticRestart = other.AutomaticRestart;
      }
      if (other.HasPreemptible) {
        Preemptible = other.Preemptible;
      }
      nodeAffinities_.Add(other.nodeAffinities_);
      if (other.HasMinNodeCpus) {
        MinNodeCpus = other.MinNodeCpus;
      }
      if (other.HasProvisioningModel) {
        ProvisioningModel = other.ProvisioningModel;
      }
      if (other.HasInstanceTerminationAction) {
        InstanceTerminationAction = other.InstanceTerminationAction;
      }
      if (other.localSsdRecoveryTimeout_ != null) {
        if (localSsdRecoveryTimeout_ == null) {
          LocalSsdRecoveryTimeout = new global::Google.Cloud.BackupDR.V1.SchedulingDuration();
        }
        LocalSsdRecoveryTimeout.MergeFrom(other.LocalSsdRecoveryTimeout);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            OnHostMaintenance = (global::Google.Cloud.BackupDR.V1.Scheduling.Types.OnHostMaintenance) input.ReadEnum();
            break;
          }
          case 16: {
            AutomaticRestart = input.ReadBool();
            break;
          }
          case 24: {
            Preemptible = input.ReadBool();
            break;
          }
          case 34: {
            nodeAffinities_.AddEntriesFrom(input, _repeated_nodeAffinities_codec);
            break;
          }
          case 40: {
            MinNodeCpus = input.ReadInt32();
            break;
          }
          case 48: {
            ProvisioningModel = (global::Google.Cloud.BackupDR.V1.Scheduling.Types.ProvisioningModel) input.ReadEnum();
            break;
          }
          case 56: {
            InstanceTerminationAction = (global::Google.Cloud.BackupDR.V1.Scheduling.Types.InstanceTerminationAction) input.ReadEnum();
            break;
          }
          case 82: {
            if (localSsdRecoveryTimeout_ == null) {
              LocalSsdRecoveryTimeout = new global::Google.Cloud.BackupDR.V1.SchedulingDuration();
            }
            input.ReadMessage(LocalSsdRecoveryTimeout);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            OnHostMaintenance = (global::Google.Cloud.BackupDR.V1.Scheduling.Types.OnHostMaintenance) input.ReadEnum();
            break;
          }
          case 16: {
            AutomaticRestart = input.ReadBool();
            break;
          }
          case 24: {
            Preemptible = input.ReadBool();
            break;
          }
          case 34: {
            nodeAffinities_.AddEntriesFrom(ref input, _repeated_nodeAffinities_codec);
            break;
          }
          case 40: {
            MinNodeCpus = input.ReadInt32();
            break;
          }
          case 48: {
            ProvisioningModel = (global::Google.Cloud.BackupDR.V1.Scheduling.Types.ProvisioningModel) input.ReadEnum();
            break;
          }
          case 56: {
            InstanceTerminationAction = (global::Google.Cloud.BackupDR.V1.Scheduling.Types.InstanceTerminationAction) input.ReadEnum();
            break;
          }
          case 82: {
            if (localSsdRecoveryTimeout_ == null) {
              LocalSsdRecoveryTimeout = new global::Google.Cloud.BackupDR.V1.SchedulingDuration();
            }
            input.ReadMessage(LocalSsdRecoveryTimeout);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Scheduling message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Defines the maintenance behavior for this instance=
      /// </summary>
      public enum OnHostMaintenance {
        /// <summary>
        /// Default value. This value is unused.
        /// </summary>
        [pbr::OriginalName("ON_HOST_MAINTENANCE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Tells Compute Engine to terminate and (optionally) restart the instance
        /// away from the maintenance activity.
        /// </summary>
        [pbr::OriginalName("TERMINATE")] Terminate = 1,
        /// <summary>
        /// Default, Allows Compute Engine to automatically migrate instances
        /// out of the way of maintenance events.
        /// </summary>
        [pbr::OriginalName("MIGRATE")] Migrate = 1000,
      }

      /// <summary>
      /// Defines the provisioning model for an instance.
      /// </summary>
      public enum ProvisioningModel {
        /// <summary>
        /// Default value. This value is not used.
        /// </summary>
        [pbr::OriginalName("PROVISIONING_MODEL_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Standard provisioning with user controlled runtime, no discounts.
        /// </summary>
        [pbr::OriginalName("STANDARD")] Standard = 1,
        /// <summary>
        /// Heavily discounted, no guaranteed runtime.
        /// </summary>
        [pbr::OriginalName("SPOT")] Spot = 2,
      }

      /// <summary>
      /// Defines the supported termination actions for an instance.
      /// </summary>
      public enum InstanceTerminationAction {
        /// <summary>
        /// Default value. This value is unused.
        /// </summary>
        [pbr::OriginalName("INSTANCE_TERMINATION_ACTION_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Delete the VM.
        /// </summary>
        [pbr::OriginalName("DELETE")] Delete = 1,
        /// <summary>
        /// Stop the VM without storing in-memory content. default action.
        /// </summary>
        [pbr::OriginalName("STOP")] Stop = 2,
      }

      /// <summary>
      /// Node Affinity: the configuration of desired nodes onto which this Instance
      /// could be scheduled.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class NodeAffinity : pb::IMessage<NodeAffinity>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<NodeAffinity> _parser = new pb::MessageParser<NodeAffinity>(() => new NodeAffinity());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<NodeAffinity> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.BackupDR.V1.Scheduling.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public NodeAffinity() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public NodeAffinity(NodeAffinity other) : this() {
          _hasBits0 = other._hasBits0;
          key_ = other.key_;
          operator_ = other.operator_;
          values_ = other.values_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public NodeAffinity Clone() {
          return new NodeAffinity(this);
        }

        /// <summary>Field number for the "key" field.</summary>
        public const int KeyFieldNumber = 1;
        private readonly static string KeyDefaultValue = "";

        private string key_;
        /// <summary>
        /// Optional. Corresponds to the label key of Node resource.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Key {
          get { return key_ ?? KeyDefaultValue; }
          set {
            key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "key" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasKey {
          get { return key_ != null; }
        }
        /// <summary>Clears the value of the "key" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearKey() {
          key_ = null;
        }

        /// <summary>Field number for the "operator" field.</summary>
        public const int OperatorFieldNumber = 2;
        private readonly static global::Google.Cloud.BackupDR.V1.Scheduling.Types.NodeAffinity.Types.Operator OperatorDefaultValue = global::Google.Cloud.BackupDR.V1.Scheduling.Types.NodeAffinity.Types.Operator.Unspecified;

        private global::Google.Cloud.BackupDR.V1.Scheduling.Types.NodeAffinity.Types.Operator operator_;
        /// <summary>
        /// Optional. Defines the operation of node selection.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Cloud.BackupDR.V1.Scheduling.Types.NodeAffinity.Types.Operator Operator {
          get { if ((_hasBits0 & 1) != 0) { return operator_; } else { return OperatorDefaultValue; } }
          set {
            _hasBits0 |= 1;
            operator_ = value;
          }
        }
        /// <summary>Gets whether the "operator" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasOperator {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "operator" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearOperator() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "values" field.</summary>
        public const int ValuesFieldNumber = 3;
        private static readonly pb::FieldCodec<string> _repeated_values_codec
            = pb::FieldCodec.ForString(26);
        private readonly pbc::RepeatedField<string> values_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// Optional. Corresponds to the label values of Node resource.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<string> Values {
          get { return values_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as NodeAffinity);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(NodeAffinity other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Key != other.Key) return false;
          if (Operator != other.Operator) return false;
          if(!values_.Equals(other.values_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasKey) hash ^= Key.GetHashCode();
          if (HasOperator) hash ^= Operator.GetHashCode();
          hash ^= values_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasKey) {
            output.WriteRawTag(10);
            output.WriteString(Key);
          }
          if (HasOperator) {
            output.WriteRawTag(16);
            output.WriteEnum((int) Operator);
          }
          values_.WriteTo(output, _repeated_values_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasKey) {
            output.WriteRawTag(10);
            output.WriteString(Key);
          }
          if (HasOperator) {
            output.WriteRawTag(16);
            output.WriteEnum((int) Operator);
          }
          values_.WriteTo(ref output, _repeated_values_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasKey) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
          }
          if (HasOperator) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Operator);
          }
          size += values_.CalculateSize(_repeated_values_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(NodeAffinity other) {
          if (other == null) {
            return;
          }
          if (other.HasKey) {
            Key = other.Key;
          }
          if (other.HasOperator) {
            Operator = other.Operator;
          }
          values_.Add(other.values_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Key = input.ReadString();
                break;
              }
              case 16: {
                Operator = (global::Google.Cloud.BackupDR.V1.Scheduling.Types.NodeAffinity.Types.Operator) input.ReadEnum();
                break;
              }
              case 26: {
                values_.AddEntriesFrom(input, _repeated_values_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Key = input.ReadString();
                break;
              }
              case 16: {
                Operator = (global::Google.Cloud.BackupDR.V1.Scheduling.Types.NodeAffinity.Types.Operator) input.ReadEnum();
                break;
              }
              case 26: {
                values_.AddEntriesFrom(ref input, _repeated_values_codec);
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the NodeAffinity message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// Defines the type of node selections.
          /// </summary>
          public enum Operator {
            /// <summary>
            /// Default value. This value is unused.
            /// </summary>
            [pbr::OriginalName("OPERATOR_UNSPECIFIED")] Unspecified = 0,
            /// <summary>
            /// Requires Compute Engine to seek for matched nodes.
            /// </summary>
            [pbr::OriginalName("IN")] In = 1,
            /// <summary>
            /// Requires Compute Engine to avoid certain nodes.
            /// </summary>
            [pbr::OriginalName("NOT_IN")] NotIn = 2,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// A SchedulingDuration represents a fixed-length span of time represented
  /// as a count of seconds and fractions of seconds at nanosecond
  /// resolution. It is independent of any calendar and concepts like "day"
  /// or "month". Range is approximately 10,000 years.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SchedulingDuration : pb::IMessage<SchedulingDuration>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SchedulingDuration> _parser = new pb::MessageParser<SchedulingDuration>(() => new SchedulingDuration());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SchedulingDuration> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.BackupDR.V1.BackupvaultGceReflection.Descriptor.MessageTypes[18]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SchedulingDuration() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SchedulingDuration(SchedulingDuration other) : this() {
      _hasBits0 = other._hasBits0;
      seconds_ = other.seconds_;
      nanos_ = other.nanos_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SchedulingDuration Clone() {
      return new SchedulingDuration(this);
    }

    /// <summary>Field number for the "seconds" field.</summary>
    public const int SecondsFieldNumber = 1;
    private readonly static long SecondsDefaultValue = 0L;

    private long seconds_;
    /// <summary>
    /// Optional. Span of time at a resolution of a second.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Seconds {
      get { if ((_hasBits0 & 1) != 0) { return seconds_; } else { return SecondsDefaultValue; } }
      set {
        _hasBits0 |= 1;
        seconds_ = value;
      }
    }
    /// <summary>Gets whether the "seconds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSeconds {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "seconds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSeconds() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "nanos" field.</summary>
    public const int NanosFieldNumber = 2;
    private readonly static int NanosDefaultValue = 0;

    private int nanos_;
    /// <summary>
    /// Optional. Span of time that's a fraction of a second at nanosecond
    /// resolution.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Nanos {
      get { if ((_hasBits0 & 2) != 0) { return nanos_; } else { return NanosDefaultValue; } }
      set {
        _hasBits0 |= 2;
        nanos_ = value;
      }
    }
    /// <summary>Gets whether the "nanos" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNanos {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "nanos" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNanos() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SchedulingDuration);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SchedulingDuration other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Seconds != other.Seconds) return false;
      if (Nanos != other.Nanos) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasSeconds) hash ^= Seconds.GetHashCode();
      if (HasNanos) hash ^= Nanos.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasSeconds) {
        output.WriteRawTag(8);
        output.WriteInt64(Seconds);
      }
      if (HasNanos) {
        output.WriteRawTag(16);
        output.WriteInt32(Nanos);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasSeconds) {
        output.WriteRawTag(8);
        output.WriteInt64(Seconds);
      }
      if (HasNanos) {
        output.WriteRawTag(16);
        output.WriteInt32(Nanos);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasSeconds) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Seconds);
      }
      if (HasNanos) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Nanos);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SchedulingDuration other) {
      if (other == null) {
        return;
      }
      if (other.HasSeconds) {
        Seconds = other.Seconds;
      }
      if (other.HasNanos) {
        Nanos = other.Nanos;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Seconds = input.ReadInt64();
            break;
          }
          case 16: {
            Nanos = input.ReadInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Seconds = input.ReadInt64();
            break;
          }
          case 16: {
            Nanos = input.ReadInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A service account.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ServiceAccount : pb::IMessage<ServiceAccount>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ServiceAccount> _parser = new pb::MessageParser<ServiceAccount>(() => new ServiceAccount());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ServiceAccount> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.BackupDR.V1.BackupvaultGceReflection.Descriptor.MessageTypes[19]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceAccount() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceAccount(ServiceAccount other) : this() {
      email_ = other.email_;
      scopes_ = other.scopes_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceAccount Clone() {
      return new ServiceAccount(this);
    }

    /// <summary>Field number for the "email" field.</summary>
    public const int EmailFieldNumber = 1;
    private readonly static string EmailDefaultValue = "";

    private string email_;
    /// <summary>
    /// Optional. Email address of the service account.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Email {
      get { return email_ ?? EmailDefaultValue; }
      set {
        email_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "email" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEmail {
      get { return email_ != null; }
    }
    /// <summary>Clears the value of the "email" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEmail() {
      email_ = null;
    }

    /// <summary>Field number for the "scopes" field.</summary>
    public const int ScopesFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_scopes_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> scopes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Optional. The list of scopes to be made available for this service account.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Scopes {
      get { return scopes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ServiceAccount);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ServiceAccount other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Email != other.Email) return false;
      if(!scopes_.Equals(other.scopes_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasEmail) hash ^= Email.GetHashCode();
      hash ^= scopes_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasEmail) {
        output.WriteRawTag(10);
        output.WriteString(Email);
      }
      scopes_.WriteTo(output, _repeated_scopes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasEmail) {
        output.WriteRawTag(10);
        output.WriteString(Email);
      }
      scopes_.WriteTo(ref output, _repeated_scopes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasEmail) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Email);
      }
      size += scopes_.CalculateSize(_repeated_scopes_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ServiceAccount other) {
      if (other == null) {
        return;
      }
      if (other.HasEmail) {
        Email = other.Email;
      }
      scopes_.Add(other.scopes_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Email = input.ReadString();
            break;
          }
          case 18: {
            scopes_.AddEntriesFrom(input, _repeated_scopes_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Email = input.ReadString();
            break;
          }
          case 18: {
            scopes_.AddEntriesFrom(ref input, _repeated_scopes_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A set of instance tags.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Tags : pb::IMessage<Tags>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Tags> _parser = new pb::MessageParser<Tags>(() => new Tags());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Tags> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.BackupDR.V1.BackupvaultGceReflection.Descriptor.MessageTypes[20]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Tags() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Tags(Tags other) : this() {
      items_ = other.items_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Tags Clone() {
      return new Tags(this);
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_items_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> items_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Optional. An array of tags. Each tag must be 1-63 characters long, and
    /// comply with RFC1035.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Items {
      get { return items_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Tags);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Tags other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!items_.Equals(other.items_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= items_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      items_.WriteTo(output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      items_.WriteTo(ref output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += items_.CalculateSize(_repeated_items_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Tags other) {
      if (other == null) {
        return;
      }
      items_.Add(other.items_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// An instance-attached disk resource.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class AttachedDisk : pb::IMessage<AttachedDisk>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AttachedDisk> _parser = new pb::MessageParser<AttachedDisk>(() => new AttachedDisk());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AttachedDisk> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.BackupDR.V1.BackupvaultGceReflection.Descriptor.MessageTypes[21]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AttachedDisk() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AttachedDisk(AttachedDisk other) : this() {
      _hasBits0 = other._hasBits0;
      initializeParams_ = other.initializeParams_ != null ? other.initializeParams_.Clone() : null;
      deviceName_ = other.deviceName_;
      kind_ = other.kind_;
      diskTypeDeprecated_ = other.diskTypeDeprecated_;
      mode_ = other.mode_;
      source_ = other.source_;
      index_ = other.index_;
      boot_ = other.boot_;
      autoDelete_ = other.autoDelete_;
      license_ = other.license_.Clone();
      diskInterface_ = other.diskInterface_;
      guestOsFeature_ = other.guestOsFeature_.Clone();
      diskEncryptionKey_ = other.diskEncryptionKey_ != null ? other.diskEncryptionKey_.Clone() : null;
      diskSizeGb_ = other.diskSizeGb_;
      savedState_ = other.savedState_;
      diskType_ = other.diskType_;
      type_ = other.type_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AttachedDisk Clone() {
      return new AttachedDisk(this);
    }

    /// <summary>Field number for the "initialize_params" field.</summary>
    public const int InitializeParamsFieldNumber = 1;
    private global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.InitializeParams initializeParams_;
    /// <summary>
    /// Optional. Specifies the parameters to initialize this disk.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.InitializeParams InitializeParams {
      get { return initializeParams_; }
      set {
        initializeParams_ = value;
      }
    }

    /// <summary>Field number for the "device_name" field.</summary>
    public const int DeviceNameFieldNumber = 4;
    private readonly static string DeviceNameDefaultValue = "";

    private string deviceName_;
    /// <summary>
    /// Optional. This is used as an identifier for the disks. This is the unique
    /// name has to provided to modify disk parameters like disk_name and
    /// replica_zones (in case of RePDs)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DeviceName {
      get { return deviceName_ ?? DeviceNameDefaultValue; }
      set {
        deviceName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "device_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDeviceName {
      get { return deviceName_ != null; }
    }
    /// <summary>Clears the value of the "device_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDeviceName() {
      deviceName_ = null;
    }

    /// <summary>Field number for the "kind" field.</summary>
    public const int KindFieldNumber = 5;
    private readonly static string KindDefaultValue = "";

    private string kind_;
    /// <summary>
    /// Optional. Type of the resource.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Kind {
      get { return kind_ ?? KindDefaultValue; }
      set {
        kind_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "kind" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKind {
      get { return kind_ != null; }
    }
    /// <summary>Clears the value of the "kind" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKind() {
      kind_ = null;
    }

    /// <summary>Field number for the "disk_type_deprecated" field.</summary>
    public const int DiskTypeDeprecatedFieldNumber = 6;
    private readonly static global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskType DiskTypeDeprecatedDefaultValue = global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskType.Unspecified;

    private global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskType diskTypeDeprecated_;
    /// <summary>
    /// Specifies the type of the disk.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskType DiskTypeDeprecated {
      get { if ((_hasBits0 & 1) != 0) { return diskTypeDeprecated_; } else { return DiskTypeDeprecatedDefaultValue; } }
      set {
        _hasBits0 |= 1;
        diskTypeDeprecated_ = value;
      }
    }
    /// <summary>Gets whether the "disk_type_deprecated" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDiskTypeDeprecated {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "disk_type_deprecated" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDiskTypeDeprecated() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "mode" field.</summary>
    public const int ModeFieldNumber = 7;
    private readonly static global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskMode ModeDefaultValue = global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskMode.Unspecified;

    private global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskMode mode_;
    /// <summary>
    /// Optional. The mode in which to attach this disk.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskMode Mode {
      get { if ((_hasBits0 & 2) != 0) { return mode_; } else { return ModeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        mode_ = value;
      }
    }
    /// <summary>Gets whether the "mode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMode {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "mode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMode() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "source" field.</summary>
    public const int SourceFieldNumber = 8;
    private readonly static string SourceDefaultValue = "";

    private string source_;
    /// <summary>
    /// Optional. Specifies a valid partial or full URL to an existing Persistent
    /// Disk resource.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Source {
      get { return source_ ?? SourceDefaultValue; }
      set {
        source_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "source" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSource {
      get { return source_ != null; }
    }
    /// <summary>Clears the value of the "source" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSource() {
      source_ = null;
    }

    /// <summary>Field number for the "index" field.</summary>
    public const int IndexFieldNumber = 9;
    private readonly static long IndexDefaultValue = 0L;

    private long index_;
    /// <summary>
    /// Optional. A zero-based index to this disk, where 0 is reserved for the
    /// boot disk.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long Index {
      get { if ((_hasBits0 & 4) != 0) { return index_; } else { return IndexDefaultValue; } }
      set {
        _hasBits0 |= 4;
        index_ = value;
      }
    }
    /// <summary>Gets whether the "index" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIndex {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "index" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIndex() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "boot" field.</summary>
    public const int BootFieldNumber = 10;
    private readonly static bool BootDefaultValue = false;

    private bool boot_;
    /// <summary>
    /// Optional. Indicates that this is a boot disk. The virtual machine will use
    /// the first partition of the disk for its root filesystem.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Boot {
      get { if ((_hasBits0 & 8) != 0) { return boot_; } else { return BootDefaultValue; } }
      set {
        _hasBits0 |= 8;
        boot_ = value;
      }
    }
    /// <summary>Gets whether the "boot" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasBoot {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "boot" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearBoot() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "auto_delete" field.</summary>
    public const int AutoDeleteFieldNumber = 11;
    private readonly static bool AutoDeleteDefaultValue = false;

    private bool autoDelete_;
    /// <summary>
    /// Optional. Specifies whether the disk will be auto-deleted when the instance
    /// is deleted (but not when the disk is detached from the instance).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AutoDelete {
      get { if ((_hasBits0 & 16) != 0) { return autoDelete_; } else { return AutoDeleteDefaultValue; } }
      set {
        _hasBits0 |= 16;
        autoDelete_ = value;
      }
    }
    /// <summary>Gets whether the "auto_delete" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAutoDelete {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "auto_delete" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAutoDelete() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "license" field.</summary>
    public const int LicenseFieldNumber = 12;
    private static readonly pb::FieldCodec<string> _repeated_license_codec
        = pb::FieldCodec.ForString(98);
    private readonly pbc::RepeatedField<string> license_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Optional. Any valid publicly visible licenses.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> License {
      get { return license_; }
    }

    /// <summary>Field number for the "disk_interface" field.</summary>
    public const int DiskInterfaceFieldNumber = 13;
    private readonly static global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskInterface DiskInterfaceDefaultValue = global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskInterface.Unspecified;

    private global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskInterface diskInterface_;
    /// <summary>
    /// Optional. Specifies the disk interface to use for attaching this disk.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskInterface DiskInterface {
      get { if ((_hasBits0 & 32) != 0) { return diskInterface_; } else { return DiskInterfaceDefaultValue; } }
      set {
        _hasBits0 |= 32;
        diskInterface_ = value;
      }
    }
    /// <summary>Gets whether the "disk_interface" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDiskInterface {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "disk_interface" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDiskInterface() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "guest_os_feature" field.</summary>
    public const int GuestOsFeatureFieldNumber = 14;
    private static readonly pb::FieldCodec<global::Google.Cloud.BackupDR.V1.GuestOsFeature> _repeated_guestOsFeature_codec
        = pb::FieldCodec.ForMessage(114, global::Google.Cloud.BackupDR.V1.GuestOsFeature.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.GuestOsFeature> guestOsFeature_ = new pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.GuestOsFeature>();
    /// <summary>
    /// Optional. A list of features to enable on the guest operating system.
    /// Applicable only for bootable images.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Cloud.BackupDR.V1.GuestOsFeature> GuestOsFeature {
      get { return guestOsFeature_; }
    }

    /// <summary>Field number for the "disk_encryption_key" field.</summary>
    public const int DiskEncryptionKeyFieldNumber = 15;
    private global::Google.Cloud.BackupDR.V1.CustomerEncryptionKey diskEncryptionKey_;
    /// <summary>
    /// Optional. Encrypts or decrypts a disk using a customer-supplied
    /// encryption key.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.CustomerEncryptionKey DiskEncryptionKey {
      get { return diskEncryptionKey_; }
      set {
        diskEncryptionKey_ = value;
      }
    }

    /// <summary>Field number for the "disk_size_gb" field.</summary>
    public const int DiskSizeGbFieldNumber = 16;
    private readonly static long DiskSizeGbDefaultValue = 0L;

    private long diskSizeGb_;
    /// <summary>
    /// Optional. The size of the disk in GB.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long DiskSizeGb {
      get { if ((_hasBits0 & 64) != 0) { return diskSizeGb_; } else { return DiskSizeGbDefaultValue; } }
      set {
        _hasBits0 |= 64;
        diskSizeGb_ = value;
      }
    }
    /// <summary>Gets whether the "disk_size_gb" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDiskSizeGb {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "disk_size_gb" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDiskSizeGb() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "saved_state" field.</summary>
    public const int SavedStateFieldNumber = 17;
    private readonly static global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskSavedState SavedStateDefaultValue = global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskSavedState.Unspecified;

    private global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskSavedState savedState_;
    /// <summary>
    /// Optional. Output only. The state of the disk.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskSavedState SavedState {
      get { if ((_hasBits0 & 128) != 0) { return savedState_; } else { return SavedStateDefaultValue; } }
      set {
        _hasBits0 |= 128;
        savedState_ = value;
      }
    }
    /// <summary>Gets whether the "saved_state" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSavedState {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "saved_state" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSavedState() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "disk_type" field.</summary>
    public const int DiskTypeFieldNumber = 18;
    private readonly static string DiskTypeDefaultValue = "";

    private string diskType_;
    /// <summary>
    /// Optional. Output only. The URI of the disk type resource. For example:
    /// projects/project/zones/zone/diskTypes/pd-standard or pd-ssd
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DiskType {
      get { return diskType_ ?? DiskTypeDefaultValue; }
      set {
        diskType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "disk_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDiskType {
      get { return diskType_ != null; }
    }
    /// <summary>Clears the value of the "disk_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDiskType() {
      diskType_ = null;
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 19;
    private readonly static global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskType TypeDefaultValue = global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskType.Unspecified;

    private global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskType type_;
    /// <summary>
    /// Optional. Specifies the type of the disk.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskType Type {
      get { if ((_hasBits0 & 256) != 0) { return type_; } else { return TypeDefaultValue; } }
      set {
        _hasBits0 |= 256;
        type_ = value;
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      _hasBits0 &= ~256;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AttachedDisk);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AttachedDisk other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(InitializeParams, other.InitializeParams)) return false;
      if (DeviceName != other.DeviceName) return false;
      if (Kind != other.Kind) return false;
      if (DiskTypeDeprecated != other.DiskTypeDeprecated) return false;
      if (Mode != other.Mode) return false;
      if (Source != other.Source) return false;
      if (Index != other.Index) return false;
      if (Boot != other.Boot) return false;
      if (AutoDelete != other.AutoDelete) return false;
      if(!license_.Equals(other.license_)) return false;
      if (DiskInterface != other.DiskInterface) return false;
      if(!guestOsFeature_.Equals(other.guestOsFeature_)) return false;
      if (!object.Equals(DiskEncryptionKey, other.DiskEncryptionKey)) return false;
      if (DiskSizeGb != other.DiskSizeGb) return false;
      if (SavedState != other.SavedState) return false;
      if (DiskType != other.DiskType) return false;
      if (Type != other.Type) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (initializeParams_ != null) hash ^= InitializeParams.GetHashCode();
      if (HasDeviceName) hash ^= DeviceName.GetHashCode();
      if (HasKind) hash ^= Kind.GetHashCode();
      if (HasDiskTypeDeprecated) hash ^= DiskTypeDeprecated.GetHashCode();
      if (HasMode) hash ^= Mode.GetHashCode();
      if (HasSource) hash ^= Source.GetHashCode();
      if (HasIndex) hash ^= Index.GetHashCode();
      if (HasBoot) hash ^= Boot.GetHashCode();
      if (HasAutoDelete) hash ^= AutoDelete.GetHashCode();
      hash ^= license_.GetHashCode();
      if (HasDiskInterface) hash ^= DiskInterface.GetHashCode();
      hash ^= guestOsFeature_.GetHashCode();
      if (diskEncryptionKey_ != null) hash ^= DiskEncryptionKey.GetHashCode();
      if (HasDiskSizeGb) hash ^= DiskSizeGb.GetHashCode();
      if (HasSavedState) hash ^= SavedState.GetHashCode();
      if (HasDiskType) hash ^= DiskType.GetHashCode();
      if (HasType) hash ^= Type.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (initializeParams_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(InitializeParams);
      }
      if (HasDeviceName) {
        output.WriteRawTag(34);
        output.WriteString(DeviceName);
      }
      if (HasKind) {
        output.WriteRawTag(42);
        output.WriteString(Kind);
      }
      if (HasDiskTypeDeprecated) {
        output.WriteRawTag(48);
        output.WriteEnum((int) DiskTypeDeprecated);
      }
      if (HasMode) {
        output.WriteRawTag(56);
        output.WriteEnum((int) Mode);
      }
      if (HasSource) {
        output.WriteRawTag(66);
        output.WriteString(Source);
      }
      if (HasIndex) {
        output.WriteRawTag(72);
        output.WriteInt64(Index);
      }
      if (HasBoot) {
        output.WriteRawTag(80);
        output.WriteBool(Boot);
      }
      if (HasAutoDelete) {
        output.WriteRawTag(88);
        output.WriteBool(AutoDelete);
      }
      license_.WriteTo(output, _repeated_license_codec);
      if (HasDiskInterface) {
        output.WriteRawTag(104);
        output.WriteEnum((int) DiskInterface);
      }
      guestOsFeature_.WriteTo(output, _repeated_guestOsFeature_codec);
      if (diskEncryptionKey_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(DiskEncryptionKey);
      }
      if (HasDiskSizeGb) {
        output.WriteRawTag(128, 1);
        output.WriteInt64(DiskSizeGb);
      }
      if (HasSavedState) {
        output.WriteRawTag(136, 1);
        output.WriteEnum((int) SavedState);
      }
      if (HasDiskType) {
        output.WriteRawTag(146, 1);
        output.WriteString(DiskType);
      }
      if (HasType) {
        output.WriteRawTag(152, 1);
        output.WriteEnum((int) Type);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (initializeParams_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(InitializeParams);
      }
      if (HasDeviceName) {
        output.WriteRawTag(34);
        output.WriteString(DeviceName);
      }
      if (HasKind) {
        output.WriteRawTag(42);
        output.WriteString(Kind);
      }
      if (HasDiskTypeDeprecated) {
        output.WriteRawTag(48);
        output.WriteEnum((int) DiskTypeDeprecated);
      }
      if (HasMode) {
        output.WriteRawTag(56);
        output.WriteEnum((int) Mode);
      }
      if (HasSource) {
        output.WriteRawTag(66);
        output.WriteString(Source);
      }
      if (HasIndex) {
        output.WriteRawTag(72);
        output.WriteInt64(Index);
      }
      if (HasBoot) {
        output.WriteRawTag(80);
        output.WriteBool(Boot);
      }
      if (HasAutoDelete) {
        output.WriteRawTag(88);
        output.WriteBool(AutoDelete);
      }
      license_.WriteTo(ref output, _repeated_license_codec);
      if (HasDiskInterface) {
        output.WriteRawTag(104);
        output.WriteEnum((int) DiskInterface);
      }
      guestOsFeature_.WriteTo(ref output, _repeated_guestOsFeature_codec);
      if (diskEncryptionKey_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(DiskEncryptionKey);
      }
      if (HasDiskSizeGb) {
        output.WriteRawTag(128, 1);
        output.WriteInt64(DiskSizeGb);
      }
      if (HasSavedState) {
        output.WriteRawTag(136, 1);
        output.WriteEnum((int) SavedState);
      }
      if (HasDiskType) {
        output.WriteRawTag(146, 1);
        output.WriteString(DiskType);
      }
      if (HasType) {
        output.WriteRawTag(152, 1);
        output.WriteEnum((int) Type);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (initializeParams_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(InitializeParams);
      }
      if (HasDeviceName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DeviceName);
      }
      if (HasKind) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Kind);
      }
      if (HasDiskTypeDeprecated) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DiskTypeDeprecated);
      }
      if (HasMode) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Mode);
      }
      if (HasSource) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Source);
      }
      if (HasIndex) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Index);
      }
      if (HasBoot) {
        size += 1 + 1;
      }
      if (HasAutoDelete) {
        size += 1 + 1;
      }
      size += license_.CalculateSize(_repeated_license_codec);
      if (HasDiskInterface) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DiskInterface);
      }
      size += guestOsFeature_.CalculateSize(_repeated_guestOsFeature_codec);
      if (diskEncryptionKey_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DiskEncryptionKey);
      }
      if (HasDiskSizeGb) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(DiskSizeGb);
      }
      if (HasSavedState) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) SavedState);
      }
      if (HasDiskType) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(DiskType);
      }
      if (HasType) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AttachedDisk other) {
      if (other == null) {
        return;
      }
      if (other.initializeParams_ != null) {
        if (initializeParams_ == null) {
          InitializeParams = new global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.InitializeParams();
        }
        InitializeParams.MergeFrom(other.InitializeParams);
      }
      if (other.HasDeviceName) {
        DeviceName = other.DeviceName;
      }
      if (other.HasKind) {
        Kind = other.Kind;
      }
      if (other.HasDiskTypeDeprecated) {
        DiskTypeDeprecated = other.DiskTypeDeprecated;
      }
      if (other.HasMode) {
        Mode = other.Mode;
      }
      if (other.HasSource) {
        Source = other.Source;
      }
      if (other.HasIndex) {
        Index = other.Index;
      }
      if (other.HasBoot) {
        Boot = other.Boot;
      }
      if (other.HasAutoDelete) {
        AutoDelete = other.AutoDelete;
      }
      license_.Add(other.license_);
      if (other.HasDiskInterface) {
        DiskInterface = other.DiskInterface;
      }
      guestOsFeature_.Add(other.guestOsFeature_);
      if (other.diskEncryptionKey_ != null) {
        if (diskEncryptionKey_ == null) {
          DiskEncryptionKey = new global::Google.Cloud.BackupDR.V1.CustomerEncryptionKey();
        }
        DiskEncryptionKey.MergeFrom(other.DiskEncryptionKey);
      }
      if (other.HasDiskSizeGb) {
        DiskSizeGb = other.DiskSizeGb;
      }
      if (other.HasSavedState) {
        SavedState = other.SavedState;
      }
      if (other.HasDiskType) {
        DiskType = other.DiskType;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (initializeParams_ == null) {
              InitializeParams = new global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.InitializeParams();
            }
            input.ReadMessage(InitializeParams);
            break;
          }
          case 34: {
            DeviceName = input.ReadString();
            break;
          }
          case 42: {
            Kind = input.ReadString();
            break;
          }
          case 48: {
            DiskTypeDeprecated = (global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskType) input.ReadEnum();
            break;
          }
          case 56: {
            Mode = (global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskMode) input.ReadEnum();
            break;
          }
          case 66: {
            Source = input.ReadString();
            break;
          }
          case 72: {
            Index = input.ReadInt64();
            break;
          }
          case 80: {
            Boot = input.ReadBool();
            break;
          }
          case 88: {
            AutoDelete = input.ReadBool();
            break;
          }
          case 98: {
            license_.AddEntriesFrom(input, _repeated_license_codec);
            break;
          }
          case 104: {
            DiskInterface = (global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskInterface) input.ReadEnum();
            break;
          }
          case 114: {
            guestOsFeature_.AddEntriesFrom(input, _repeated_guestOsFeature_codec);
            break;
          }
          case 122: {
            if (diskEncryptionKey_ == null) {
              DiskEncryptionKey = new global::Google.Cloud.BackupDR.V1.CustomerEncryptionKey();
            }
            input.ReadMessage(DiskEncryptionKey);
            break;
          }
          case 128: {
            DiskSizeGb = input.ReadInt64();
            break;
          }
          case 136: {
            SavedState = (global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskSavedState) input.ReadEnum();
            break;
          }
          case 146: {
            DiskType = input.ReadString();
            break;
          }
          case 152: {
            Type = (global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskType) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (initializeParams_ == null) {
              InitializeParams = new global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.InitializeParams();
            }
            input.ReadMessage(InitializeParams);
            break;
          }
          case 34: {
            DeviceName = input.ReadString();
            break;
          }
          case 42: {
            Kind = input.ReadString();
            break;
          }
          case 48: {
            DiskTypeDeprecated = (global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskType) input.ReadEnum();
            break;
          }
          case 56: {
            Mode = (global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskMode) input.ReadEnum();
            break;
          }
          case 66: {
            Source = input.ReadString();
            break;
          }
          case 72: {
            Index = input.ReadInt64();
            break;
          }
          case 80: {
            Boot = input.ReadBool();
            break;
          }
          case 88: {
            AutoDelete = input.ReadBool();
            break;
          }
          case 98: {
            license_.AddEntriesFrom(ref input, _repeated_license_codec);
            break;
          }
          case 104: {
            DiskInterface = (global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskInterface) input.ReadEnum();
            break;
          }
          case 114: {
            guestOsFeature_.AddEntriesFrom(ref input, _repeated_guestOsFeature_codec);
            break;
          }
          case 122: {
            if (diskEncryptionKey_ == null) {
              DiskEncryptionKey = new global::Google.Cloud.BackupDR.V1.CustomerEncryptionKey();
            }
            input.ReadMessage(DiskEncryptionKey);
            break;
          }
          case 128: {
            DiskSizeGb = input.ReadInt64();
            break;
          }
          case 136: {
            SavedState = (global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskSavedState) input.ReadEnum();
            break;
          }
          case 146: {
            DiskType = input.ReadString();
            break;
          }
          case 152: {
            Type = (global::Google.Cloud.BackupDR.V1.AttachedDisk.Types.DiskType) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the AttachedDisk message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// List of the Disk Types.
      /// </summary>
      public enum DiskType {
        /// <summary>
        /// Default value, which is unused.
        /// </summary>
        [pbr::OriginalName("DISK_TYPE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// A scratch disk type.
        /// </summary>
        [pbr::OriginalName("SCRATCH")] Scratch = 1,
        /// <summary>
        /// A persistent disk type.
        /// </summary>
        [pbr::OriginalName("PERSISTENT")] Persistent = 2,
      }

      /// <summary>
      /// List of the Disk Modes.
      /// </summary>
      public enum DiskMode {
        /// <summary>
        /// Default value, which is unused.
        /// </summary>
        [pbr::OriginalName("DISK_MODE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Attaches this disk in read-write mode. Only one
        /// virtual machine at a time can be attached to a disk in read-write mode.
        /// </summary>
        [pbr::OriginalName("READ_WRITE")] ReadWrite = 1,
        /// <summary>
        /// Attaches this disk in read-only mode. Multiple virtual machines can use
        /// a disk in read-only mode at a time.
        /// </summary>
        [pbr::OriginalName("READ_ONLY")] ReadOnly = 2,
        /// <summary>
        /// The disk is locked for administrative reasons. Nobody else
        /// can use the disk. This mode is used (for example) when taking
        /// a snapshot of a disk to prevent mounting the disk while it is
        /// being snapshotted.
        /// </summary>
        [pbr::OriginalName("LOCKED")] Locked = 3,
      }

      /// <summary>
      /// List of the Disk Interfaces.
      /// </summary>
      public enum DiskInterface {
        /// <summary>
        /// Default value, which is unused.
        /// </summary>
        [pbr::OriginalName("DISK_INTERFACE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// SCSI Disk Interface.
        /// </summary>
        [pbr::OriginalName("SCSI")] Scsi = 1,
        /// <summary>
        /// NVME Disk Interface.
        /// </summary>
        [pbr::OriginalName("NVME")] Nvme = 2,
        /// <summary>
        /// NVDIMM Disk Interface.
        /// </summary>
        [pbr::OriginalName("NVDIMM")] Nvdimm = 3,
        /// <summary>
        /// ISCSI Disk Interface.
        /// </summary>
        [pbr::OriginalName("ISCSI")] Iscsi = 4,
      }

      /// <summary>
      /// List of the states of the Disk.
      /// </summary>
      public enum DiskSavedState {
        /// <summary>
        /// Default Disk state has not been preserved.
        /// </summary>
        [pbr::OriginalName("DISK_SAVED_STATE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Disk state has been preserved.
        /// </summary>
        [pbr::OriginalName("PRESERVED")] Preserved = 1,
      }

      /// <summary>
      /// Specifies the parameters to initialize this disk.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class InitializeParams : pb::IMessage<InitializeParams>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<InitializeParams> _parser = new pb::MessageParser<InitializeParams>(() => new InitializeParams());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<InitializeParams> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.BackupDR.V1.AttachedDisk.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public InitializeParams() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public InitializeParams(InitializeParams other) : this() {
          diskName_ = other.diskName_;
          replicaZones_ = other.replicaZones_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public InitializeParams Clone() {
          return new InitializeParams(this);
        }

        /// <summary>Field number for the "disk_name" field.</summary>
        public const int DiskNameFieldNumber = 1;
        private readonly static string DiskNameDefaultValue = "";

        private string diskName_;
        /// <summary>
        /// Optional. Specifies the disk name. If not specified, the default is to
        /// use the name of the instance.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string DiskName {
          get { return diskName_ ?? DiskNameDefaultValue; }
          set {
            diskName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "disk_name" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasDiskName {
          get { return diskName_ != null; }
        }
        /// <summary>Clears the value of the "disk_name" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearDiskName() {
          diskName_ = null;
        }

        /// <summary>Field number for the "replica_zones" field.</summary>
        public const int ReplicaZonesFieldNumber = 2;
        private static readonly pb::FieldCodec<string> _repeated_replicaZones_codec
            = pb::FieldCodec.ForString(18);
        private readonly pbc::RepeatedField<string> replicaZones_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// Optional. URL of the zone where the disk should be created.
        /// Required for each regional disk associated with the instance.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<string> ReplicaZones {
          get { return replicaZones_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as InitializeParams);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(InitializeParams other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (DiskName != other.DiskName) return false;
          if(!replicaZones_.Equals(other.replicaZones_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasDiskName) hash ^= DiskName.GetHashCode();
          hash ^= replicaZones_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasDiskName) {
            output.WriteRawTag(10);
            output.WriteString(DiskName);
          }
          replicaZones_.WriteTo(output, _repeated_replicaZones_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasDiskName) {
            output.WriteRawTag(10);
            output.WriteString(DiskName);
          }
          replicaZones_.WriteTo(ref output, _repeated_replicaZones_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasDiskName) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(DiskName);
          }
          size += replicaZones_.CalculateSize(_repeated_replicaZones_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(InitializeParams other) {
          if (other == null) {
            return;
          }
          if (other.HasDiskName) {
            DiskName = other.DiskName;
          }
          replicaZones_.Add(other.replicaZones_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                DiskName = input.ReadString();
                break;
              }
              case 18: {
                replicaZones_.AddEntriesFrom(input, _repeated_replicaZones_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                DiskName = input.ReadString();
                break;
              }
              case 18: {
                replicaZones_.AddEntriesFrom(ref input, _repeated_replicaZones_codec);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// Feature type of the Guest OS.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class GuestOsFeature : pb::IMessage<GuestOsFeature>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GuestOsFeature> _parser = new pb::MessageParser<GuestOsFeature>(() => new GuestOsFeature());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<GuestOsFeature> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.BackupDR.V1.BackupvaultGceReflection.Descriptor.MessageTypes[22]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GuestOsFeature() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GuestOsFeature(GuestOsFeature other) : this() {
      _hasBits0 = other._hasBits0;
      type_ = other.type_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GuestOsFeature Clone() {
      return new GuestOsFeature(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private readonly static global::Google.Cloud.BackupDR.V1.GuestOsFeature.Types.FeatureType TypeDefaultValue = global::Google.Cloud.BackupDR.V1.GuestOsFeature.Types.FeatureType.Unspecified;

    private global::Google.Cloud.BackupDR.V1.GuestOsFeature.Types.FeatureType type_;
    /// <summary>
    /// The ID of a supported feature.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Cloud.BackupDR.V1.GuestOsFeature.Types.FeatureType Type {
      get { if ((_hasBits0 & 1) != 0) { return type_; } else { return TypeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        type_ = value;
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as GuestOsFeature);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(GuestOsFeature other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasType) hash ^= Type.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(GuestOsFeature other) {
      if (other == null) {
        return;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Type = (global::Google.Cloud.BackupDR.V1.GuestOsFeature.Types.FeatureType) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Type = (global::Google.Cloud.BackupDR.V1.GuestOsFeature.Types.FeatureType) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the GuestOsFeature message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// List of the Feature Types.
      /// </summary>
      public enum FeatureType {
        /// <summary>
        /// Default value, which is unused.
        /// </summary>
        [pbr::OriginalName("FEATURE_TYPE_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// VIRTIO_SCSI_MULTIQUEUE feature type.
        /// </summary>
        [pbr::OriginalName("VIRTIO_SCSI_MULTIQUEUE")] VirtioScsiMultiqueue = 1,
        /// <summary>
        /// WINDOWS feature type.
        /// </summary>
        [pbr::OriginalName("WINDOWS")] Windows = 2,
        /// <summary>
        /// MULTI_IP_SUBNET feature type.
        /// </summary>
        [pbr::OriginalName("MULTI_IP_SUBNET")] MultiIpSubnet = 3,
        /// <summary>
        /// UEFI_COMPATIBLE feature type.
        /// </summary>
        [pbr::OriginalName("UEFI_COMPATIBLE")] UefiCompatible = 4,
        /// <summary>
        /// SECURE_BOOT feature type.
        /// </summary>
        [pbr::OriginalName("SECURE_BOOT")] SecureBoot = 5,
        /// <summary>
        /// GVNIC feature type.
        /// </summary>
        [pbr::OriginalName("GVNIC")] Gvnic = 6,
        /// <summary>
        /// SEV_CAPABLE feature type.
        /// </summary>
        [pbr::OriginalName("SEV_CAPABLE")] SevCapable = 7,
        /// <summary>
        /// BARE_METAL_LINUX_COMPATIBLE feature type.
        /// </summary>
        [pbr::OriginalName("BARE_METAL_LINUX_COMPATIBLE")] BareMetalLinuxCompatible = 8,
        /// <summary>
        /// SUSPEND_RESUME_COMPATIBLE feature type.
        /// </summary>
        [pbr::OriginalName("SUSPEND_RESUME_COMPATIBLE")] SuspendResumeCompatible = 9,
        /// <summary>
        /// SEV_LIVE_MIGRATABLE feature type.
        /// </summary>
        [pbr::OriginalName("SEV_LIVE_MIGRATABLE")] SevLiveMigratable = 10,
        /// <summary>
        /// SEV_SNP_CAPABLE feature type.
        /// </summary>
        [pbr::OriginalName("SEV_SNP_CAPABLE")] SevSnpCapable = 11,
        /// <summary>
        /// TDX_CAPABLE feature type.
        /// </summary>
        [pbr::OriginalName("TDX_CAPABLE")] TdxCapable = 12,
        /// <summary>
        /// IDPF feature type.
        /// </summary>
        [pbr::OriginalName("IDPF")] Idpf = 13,
        /// <summary>
        /// SEV_LIVE_MIGRATABLE_V2 feature type.
        /// </summary>
        [pbr::OriginalName("SEV_LIVE_MIGRATABLE_V2")] SevLiveMigratableV2 = 14,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
