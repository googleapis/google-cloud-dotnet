// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/cloud/aiplatform/v1/explanation_metadata.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Cloud.AIPlatform.V1 {

  /// <summary>Holder for reflection information generated from google/cloud/aiplatform/v1/explanation_metadata.proto</summary>
  public static partial class ExplanationMetadataReflection {

    #region Descriptor
    /// <summary>File descriptor for google/cloud/aiplatform/v1/explanation_metadata.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ExplanationMetadataReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CjVnb29nbGUvY2xvdWQvYWlwbGF0Zm9ybS92MS9leHBsYW5hdGlvbl9tZXRh",
            "ZGF0YS5wcm90bxIaZ29vZ2xlLmNsb3VkLmFpcGxhdGZvcm0udjEaH2dvb2ds",
            "ZS9hcGkvZmllbGRfYmVoYXZpb3IucHJvdG8aHGdvb2dsZS9wcm90b2J1Zi9z",
            "dHJ1Y3QucHJvdG8izxIKE0V4cGxhbmF0aW9uTWV0YWRhdGESUAoGaW5wdXRz",
            "GAEgAygLMjsuZ29vZ2xlLmNsb3VkLmFpcGxhdGZvcm0udjEuRXhwbGFuYXRp",
            "b25NZXRhZGF0YS5JbnB1dHNFbnRyeUID4EECElIKB291dHB1dHMYAiADKAsy",
            "PC5nb29nbGUuY2xvdWQuYWlwbGF0Zm9ybS52MS5FeHBsYW5hdGlvbk1ldGFk",
            "YXRhLk91dHB1dHNFbnRyeUID4EECEicKH2ZlYXR1cmVfYXR0cmlidXRpb25z",
            "X3NjaGVtYV91cmkYAyABKAkSGwoTbGF0ZW50X3NwYWNlX3NvdXJjZRgFIAEo",
            "CRrEDQoNSW5wdXRNZXRhZGF0YRIvCg9pbnB1dF9iYXNlbGluZXMYASADKAsy",
            "Fi5nb29nbGUucHJvdG9idWYuVmFsdWUSGQoRaW5wdXRfdGVuc29yX25hbWUY",
            "AiABKAkSWAoIZW5jb2RpbmcYAyABKA4yRi5nb29nbGUuY2xvdWQuYWlwbGF0",
            "Zm9ybS52MS5FeHBsYW5hdGlvbk1ldGFkYXRhLklucHV0TWV0YWRhdGEuRW5j",
            "b2RpbmcSEAoIbW9kYWxpdHkYBCABKAkSbgoUZmVhdHVyZV92YWx1ZV9kb21h",
            "aW4YBSABKAsyUC5nb29nbGUuY2xvdWQuYWlwbGF0Zm9ybS52MS5FeHBsYW5h",
            "dGlvbk1ldGFkYXRhLklucHV0TWV0YWRhdGEuRmVhdHVyZVZhbHVlRG9tYWlu",
            "EhsKE2luZGljZXNfdGVuc29yX25hbWUYBiABKAkSHwoXZGVuc2Vfc2hhcGVf",
            "dGVuc29yX25hbWUYByABKAkSHQoVaW5kZXhfZmVhdHVyZV9tYXBwaW5nGAgg",
            "AygJEhsKE2VuY29kZWRfdGVuc29yX25hbWUYCSABKAkSMQoRZW5jb2RlZF9i",
            "YXNlbGluZXMYCiADKAsyFi5nb29nbGUucHJvdG9idWYuVmFsdWUSYgoNdmlz",
            "dWFsaXphdGlvbhgLIAEoCzJLLmdvb2dsZS5jbG91ZC5haXBsYXRmb3JtLnYx",
            "LkV4cGxhbmF0aW9uTWV0YWRhdGEuSW5wdXRNZXRhZGF0YS5WaXN1YWxpemF0",
            "aW9uEhIKCmdyb3VwX25hbWUYDCABKAkaagoSRmVhdHVyZVZhbHVlRG9tYWlu",
            "EhEKCW1pbl92YWx1ZRgBIAEoAhIRCgltYXhfdmFsdWUYAiABKAISFQoNb3Jp",
            "Z2luYWxfbWVhbhgDIAEoAhIXCg9vcmlnaW5hbF9zdGRkZXYYBCABKAIa1gYK",
            "DVZpc3VhbGl6YXRpb24SXgoEdHlwZRgBIAEoDjJQLmdvb2dsZS5jbG91ZC5h",
            "aXBsYXRmb3JtLnYxLkV4cGxhbmF0aW9uTWV0YWRhdGEuSW5wdXRNZXRhZGF0",
            "YS5WaXN1YWxpemF0aW9uLlR5cGUSZgoIcG9sYXJpdHkYAiABKA4yVC5nb29n",
            "bGUuY2xvdWQuYWlwbGF0Zm9ybS52MS5FeHBsYW5hdGlvbk1ldGFkYXRhLklu",
            "cHV0TWV0YWRhdGEuVmlzdWFsaXphdGlvbi5Qb2xhcml0eRJnCgljb2xvcl9t",
            "YXAYAyABKA4yVC5nb29nbGUuY2xvdWQuYWlwbGF0Zm9ybS52MS5FeHBsYW5h",
            "dGlvbk1ldGFkYXRhLklucHV0TWV0YWRhdGEuVmlzdWFsaXphdGlvbi5Db2xv",
            "ck1hcBIfChdjbGlwX3BlcmNlbnRfdXBwZXJib3VuZBgEIAEoAhIfChdjbGlw",
            "X3BlcmNlbnRfbG93ZXJib3VuZBgFIAEoAhJtCgxvdmVybGF5X3R5cGUYBiAB",
            "KA4yVy5nb29nbGUuY2xvdWQuYWlwbGF0Zm9ybS52MS5FeHBsYW5hdGlvbk1l",
            "dGFkYXRhLklucHV0TWV0YWRhdGEuVmlzdWFsaXphdGlvbi5PdmVybGF5VHlw",
            "ZSI2CgRUeXBlEhQKEFRZUEVfVU5TUEVDSUZJRUQQABIKCgZQSVhFTFMQARIM",
            "CghPVVRMSU5FUxACIkoKCFBvbGFyaXR5EhgKFFBPTEFSSVRZX1VOU1BFQ0lG",
            "SUVEEAASDAoIUE9TSVRJVkUQARIMCghORUdBVElWRRACEggKBEJPVEgQAyJ7",
            "CghDb2xvck1hcBIZChVDT0xPUl9NQVBfVU5TUEVDSUZJRUQQABIOCgpQSU5L",
            "X0dSRUVOEAESCwoHVklSSURJUxACEgcKA1JFRBADEgkKBUdSRUVOEAQSDQoJ",
            "UkVEX0dSRUVOEAYSFAoQUElOS19XSElURV9HUkVFThAFImIKC092ZXJsYXlU",
            "eXBlEhwKGE9WRVJMQVlfVFlQRV9VTlNQRUNJRklFRBAAEggKBE5PTkUQARIM",
            "CghPUklHSU5BTBACEg0KCUdSQVlTQ0FMRRADEg4KCk1BU0tfQkxBQ0sQBCKg",
            "AQoIRW5jb2RpbmcSGAoURU5DT0RJTkdfVU5TUEVDSUZJRUQQABIMCghJREVO",
            "VElUWRABEhMKD0JBR19PRl9GRUFUVVJFUxACEhoKFkJBR19PRl9GRUFUVVJF",
            "U19TUEFSU0UQAxINCglJTkRJQ0FUT1IQBBIWChJDT01CSU5FRF9FTUJFRERJ",
            "TkcQBRIUChBDT05DQVRfRU1CRURESU5HEAYapgEKDk91dHB1dE1ldGFkYXRh",
            "EjwKGmluZGV4X2Rpc3BsYXlfbmFtZV9tYXBwaW5nGAEgASgLMhYuZ29vZ2xl",
            "LnByb3RvYnVmLlZhbHVlSAASIgoYZGlzcGxheV9uYW1lX21hcHBpbmdfa2V5",
            "GAIgASgJSAASGgoSb3V0cHV0X3RlbnNvcl9uYW1lGAMgASgJQhYKFGRpc3Bs",
            "YXlfbmFtZV9tYXBwaW5nGmwKC0lucHV0c0VudHJ5EgsKA2tleRgBIAEoCRJM",
            "CgV2YWx1ZRgCIAEoCzI9Lmdvb2dsZS5jbG91ZC5haXBsYXRmb3JtLnYxLkV4",
            "cGxhbmF0aW9uTWV0YWRhdGEuSW5wdXRNZXRhZGF0YToCOAEabgoMT3V0cHV0",
            "c0VudHJ5EgsKA2tleRgBIAEoCRJNCgV2YWx1ZRgCIAEoCzI+Lmdvb2dsZS5j",
            "bG91ZC5haXBsYXRmb3JtLnYxLkV4cGxhbmF0aW9uTWV0YWRhdGEuT3V0cHV0",
            "TWV0YWRhdGE6AjgBQtYBCh5jb20uZ29vZ2xlLmNsb3VkLmFpcGxhdGZvcm0u",
            "djFCGEV4cGxhbmF0aW9uTWV0YWRhdGFQcm90b1ABWj5jbG91ZC5nb29nbGUu",
            "Y29tL2dvL2FpcGxhdGZvcm0vYXBpdjEvYWlwbGF0Zm9ybXBiO2FpcGxhdGZv",
            "cm1wYqoCGkdvb2dsZS5DbG91ZC5BSVBsYXRmb3JtLlYxygIaR29vZ2xlXENs",
            "b3VkXEFJUGxhdGZvcm1cVjHqAh1Hb29nbGU6OkNsb3VkOjpBSVBsYXRmb3Jt",
            "OjpWMWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.FieldBehaviorReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.StructReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.AIPlatform.V1.ExplanationMetadata), global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Parser, new[]{ "Inputs", "Outputs", "FeatureAttributionsSchemaUri", "LatentSpaceSource" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata), global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Parser, new[]{ "InputBaselines", "InputTensorName", "Encoding", "Modality", "FeatureValueDomain", "IndicesTensorName", "DenseShapeTensorName", "IndexFeatureMapping", "EncodedTensorName", "EncodedBaselines", "Visualization", "GroupName" }, null, new[]{ typeof(global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Encoding) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.FeatureValueDomain), global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.FeatureValueDomain.Parser, new[]{ "MinValue", "MaxValue", "OriginalMean", "OriginalStddev" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization), global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Parser, new[]{ "Type", "Polarity", "ColorMap", "ClipPercentUpperbound", "ClipPercentLowerbound", "OverlayType" }, null, new[]{ typeof(global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.Type), typeof(global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.Polarity), typeof(global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.ColorMap), typeof(global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.OverlayType) }, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.OutputMetadata), global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.OutputMetadata.Parser, new[]{ "IndexDisplayNameMapping", "DisplayNameMappingKey", "OutputTensorName" }, new[]{ "DisplayNameMapping" }, null, null, null),
            null, null, })
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Metadata describing the Model's input and output for explanation.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ExplanationMetadata : pb::IMessage<ExplanationMetadata>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ExplanationMetadata> _parser = new pb::MessageParser<ExplanationMetadata>(() => new ExplanationMetadata());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ExplanationMetadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.AIPlatform.V1.ExplanationMetadataReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExplanationMetadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExplanationMetadata(ExplanationMetadata other) : this() {
      inputs_ = other.inputs_.Clone();
      outputs_ = other.outputs_.Clone();
      featureAttributionsSchemaUri_ = other.featureAttributionsSchemaUri_;
      latentSpaceSource_ = other.latentSpaceSource_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExplanationMetadata Clone() {
      return new ExplanationMetadata(this);
    }

    /// <summary>Field number for the "inputs" field.</summary>
    public const int InputsFieldNumber = 1;
    private static readonly pbc::MapField<string, global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata>.Codec _map_inputs_codec
        = new pbc::MapField<string, global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Parser), 10);
    private readonly pbc::MapField<string, global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata> inputs_ = new pbc::MapField<string, global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata>();
    /// <summary>
    /// Required. Map from feature names to feature input metadata. Keys are the
    /// name of the features. Values are the specification of the feature.
    ///
    /// An empty InputMetadata is valid. It describes a text feature which has the
    /// name specified as the key in
    /// [ExplanationMetadata.inputs][google.cloud.aiplatform.v1.ExplanationMetadata.inputs].
    /// The baseline of the empty feature is chosen by Vertex AI.
    ///
    /// For Vertex AI-provided Tensorflow images, the key can be any friendly
    /// name of the feature. Once specified,
    /// [featureAttributions][google.cloud.aiplatform.v1.Attribution.feature_attributions]
    /// are keyed by this key (if not grouped with another feature).
    ///
    /// For custom images, the key must match with the key in
    /// [instance][google.cloud.aiplatform.v1.ExplainRequest.instances].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata> Inputs {
      get { return inputs_; }
    }

    /// <summary>Field number for the "outputs" field.</summary>
    public const int OutputsFieldNumber = 2;
    private static readonly pbc::MapField<string, global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.OutputMetadata>.Codec _map_outputs_codec
        = new pbc::MapField<string, global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.OutputMetadata>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.OutputMetadata.Parser), 18);
    private readonly pbc::MapField<string, global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.OutputMetadata> outputs_ = new pbc::MapField<string, global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.OutputMetadata>();
    /// <summary>
    /// Required. Map from output names to output metadata.
    ///
    /// For Vertex AI-provided Tensorflow images, keys can be any user defined
    /// string that consists of any UTF-8 characters.
    ///
    /// For custom images, keys are the name of the output field in the prediction
    /// to be explained.
    ///
    /// Currently only one key is allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.OutputMetadata> Outputs {
      get { return outputs_; }
    }

    /// <summary>Field number for the "feature_attributions_schema_uri" field.</summary>
    public const int FeatureAttributionsSchemaUriFieldNumber = 3;
    private string featureAttributionsSchemaUri_ = "";
    /// <summary>
    /// Points to a YAML file stored on Google Cloud Storage describing the format
    /// of the [feature
    /// attributions][google.cloud.aiplatform.v1.Attribution.feature_attributions].
    /// The schema is defined as an OpenAPI 3.0.2 [Schema
    /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
    /// AutoML tabular Models always have this field populated by Vertex AI.
    /// Note: The URI given on output may be different, including the URI scheme,
    /// than the one given on input. The output URI will point to a location where
    /// the user only has a read access.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FeatureAttributionsSchemaUri {
      get { return featureAttributionsSchemaUri_; }
      set {
        featureAttributionsSchemaUri_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "latent_space_source" field.</summary>
    public const int LatentSpaceSourceFieldNumber = 5;
    private string latentSpaceSource_ = "";
    /// <summary>
    /// Name of the source to generate embeddings for example based explanations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string LatentSpaceSource {
      get { return latentSpaceSource_; }
      set {
        latentSpaceSource_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ExplanationMetadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ExplanationMetadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!Inputs.Equals(other.Inputs)) return false;
      if (!Outputs.Equals(other.Outputs)) return false;
      if (FeatureAttributionsSchemaUri != other.FeatureAttributionsSchemaUri) return false;
      if (LatentSpaceSource != other.LatentSpaceSource) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= Inputs.GetHashCode();
      hash ^= Outputs.GetHashCode();
      if (FeatureAttributionsSchemaUri.Length != 0) hash ^= FeatureAttributionsSchemaUri.GetHashCode();
      if (LatentSpaceSource.Length != 0) hash ^= LatentSpaceSource.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      inputs_.WriteTo(output, _map_inputs_codec);
      outputs_.WriteTo(output, _map_outputs_codec);
      if (FeatureAttributionsSchemaUri.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(FeatureAttributionsSchemaUri);
      }
      if (LatentSpaceSource.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(LatentSpaceSource);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      inputs_.WriteTo(ref output, _map_inputs_codec);
      outputs_.WriteTo(ref output, _map_outputs_codec);
      if (FeatureAttributionsSchemaUri.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(FeatureAttributionsSchemaUri);
      }
      if (LatentSpaceSource.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(LatentSpaceSource);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += inputs_.CalculateSize(_map_inputs_codec);
      size += outputs_.CalculateSize(_map_outputs_codec);
      if (FeatureAttributionsSchemaUri.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FeatureAttributionsSchemaUri);
      }
      if (LatentSpaceSource.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LatentSpaceSource);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ExplanationMetadata other) {
      if (other == null) {
        return;
      }
      inputs_.MergeFrom(other.inputs_);
      outputs_.MergeFrom(other.outputs_);
      if (other.FeatureAttributionsSchemaUri.Length != 0) {
        FeatureAttributionsSchemaUri = other.FeatureAttributionsSchemaUri;
      }
      if (other.LatentSpaceSource.Length != 0) {
        LatentSpaceSource = other.LatentSpaceSource;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            inputs_.AddEntriesFrom(input, _map_inputs_codec);
            break;
          }
          case 18: {
            outputs_.AddEntriesFrom(input, _map_outputs_codec);
            break;
          }
          case 26: {
            FeatureAttributionsSchemaUri = input.ReadString();
            break;
          }
          case 42: {
            LatentSpaceSource = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            inputs_.AddEntriesFrom(ref input, _map_inputs_codec);
            break;
          }
          case 18: {
            outputs_.AddEntriesFrom(ref input, _map_outputs_codec);
            break;
          }
          case 26: {
            FeatureAttributionsSchemaUri = input.ReadString();
            break;
          }
          case 42: {
            LatentSpaceSource = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ExplanationMetadata message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Metadata of the input of a feature.
      ///
      /// Fields other than
      /// [InputMetadata.input_baselines][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.input_baselines]
      /// are applicable only for Models that are using Vertex AI-provided images for
      /// Tensorflow.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class InputMetadata : pb::IMessage<InputMetadata>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<InputMetadata> _parser = new pb::MessageParser<InputMetadata>(() => new InputMetadata());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<InputMetadata> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public InputMetadata() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public InputMetadata(InputMetadata other) : this() {
          inputBaselines_ = other.inputBaselines_.Clone();
          inputTensorName_ = other.inputTensorName_;
          encoding_ = other.encoding_;
          modality_ = other.modality_;
          featureValueDomain_ = other.featureValueDomain_ != null ? other.featureValueDomain_.Clone() : null;
          indicesTensorName_ = other.indicesTensorName_;
          denseShapeTensorName_ = other.denseShapeTensorName_;
          indexFeatureMapping_ = other.indexFeatureMapping_.Clone();
          encodedTensorName_ = other.encodedTensorName_;
          encodedBaselines_ = other.encodedBaselines_.Clone();
          visualization_ = other.visualization_ != null ? other.visualization_.Clone() : null;
          groupName_ = other.groupName_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public InputMetadata Clone() {
          return new InputMetadata(this);
        }

        /// <summary>Field number for the "input_baselines" field.</summary>
        public const int InputBaselinesFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Google.Protobuf.WellKnownTypes.Value> _repeated_inputBaselines_codec
            = pb::FieldCodec.ForMessage(10, global::Google.Protobuf.WellKnownTypes.Value.Parser);
        private readonly pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Value> inputBaselines_ = new pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Value>();
        /// <summary>
        /// Baseline inputs for this feature.
        ///
        /// If no baseline is specified, Vertex AI chooses the baseline for this
        /// feature. If multiple baselines are specified, Vertex AI returns the
        /// average attributions across them in
        /// [Attribution.feature_attributions][google.cloud.aiplatform.v1.Attribution.feature_attributions].
        ///
        /// For Vertex AI-provided Tensorflow images (both 1.x and 2.x), the shape
        /// of each baseline must match the shape of the input tensor. If a scalar is
        /// provided, we broadcast to the same shape as the input tensor.
        ///
        /// For custom images, the element of the baselines must be in the same
        /// format as the feature's input in the
        /// [instance][google.cloud.aiplatform.v1.ExplainRequest.instances][]. The
        /// schema of any single instance may be specified via Endpoint's
        /// DeployedModels' [Model's][google.cloud.aiplatform.v1.DeployedModel.model]
        /// [PredictSchemata's][google.cloud.aiplatform.v1.Model.predict_schemata]
        /// [instance_schema_uri][google.cloud.aiplatform.v1.PredictSchemata.instance_schema_uri].
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Value> InputBaselines {
          get { return inputBaselines_; }
        }

        /// <summary>Field number for the "input_tensor_name" field.</summary>
        public const int InputTensorNameFieldNumber = 2;
        private string inputTensorName_ = "";
        /// <summary>
        /// Name of the input tensor for this feature. Required and is only
        /// applicable to Vertex AI-provided images for Tensorflow.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string InputTensorName {
          get { return inputTensorName_; }
          set {
            inputTensorName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "encoding" field.</summary>
        public const int EncodingFieldNumber = 3;
        private global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Encoding encoding_ = global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Encoding.Unspecified;
        /// <summary>
        /// Defines how the feature is encoded into the input tensor. Defaults to
        /// IDENTITY.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Encoding Encoding {
          get { return encoding_; }
          set {
            encoding_ = value;
          }
        }

        /// <summary>Field number for the "modality" field.</summary>
        public const int ModalityFieldNumber = 4;
        private string modality_ = "";
        /// <summary>
        /// Modality of the feature. Valid values are: numeric, image. Defaults to
        /// numeric.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Modality {
          get { return modality_; }
          set {
            modality_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "feature_value_domain" field.</summary>
        public const int FeatureValueDomainFieldNumber = 5;
        private global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.FeatureValueDomain featureValueDomain_;
        /// <summary>
        /// The domain details of the input feature value. Like min/max, original
        /// mean or standard deviation if normalized.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.FeatureValueDomain FeatureValueDomain {
          get { return featureValueDomain_; }
          set {
            featureValueDomain_ = value;
          }
        }

        /// <summary>Field number for the "indices_tensor_name" field.</summary>
        public const int IndicesTensorNameFieldNumber = 6;
        private string indicesTensorName_ = "";
        /// <summary>
        /// Specifies the index of the values of the input tensor.
        /// Required when the input tensor is a sparse representation. Refer to
        /// Tensorflow documentation for more details:
        /// https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string IndicesTensorName {
          get { return indicesTensorName_; }
          set {
            indicesTensorName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "dense_shape_tensor_name" field.</summary>
        public const int DenseShapeTensorNameFieldNumber = 7;
        private string denseShapeTensorName_ = "";
        /// <summary>
        /// Specifies the shape of the values of the input if the input is a sparse
        /// representation. Refer to Tensorflow documentation for more details:
        /// https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string DenseShapeTensorName {
          get { return denseShapeTensorName_; }
          set {
            denseShapeTensorName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "index_feature_mapping" field.</summary>
        public const int IndexFeatureMappingFieldNumber = 8;
        private static readonly pb::FieldCodec<string> _repeated_indexFeatureMapping_codec
            = pb::FieldCodec.ForString(66);
        private readonly pbc::RepeatedField<string> indexFeatureMapping_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// A list of feature names for each index in the input tensor.
        /// Required when the input
        /// [InputMetadata.encoding][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.encoding]
        /// is BAG_OF_FEATURES, BAG_OF_FEATURES_SPARSE, INDICATOR.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<string> IndexFeatureMapping {
          get { return indexFeatureMapping_; }
        }

        /// <summary>Field number for the "encoded_tensor_name" field.</summary>
        public const int EncodedTensorNameFieldNumber = 9;
        private string encodedTensorName_ = "";
        /// <summary>
        /// Encoded tensor is a transformation of the input tensor. Must be provided
        /// if choosing
        /// [Integrated Gradients
        /// attribution][google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution]
        /// or [XRAI
        /// attribution][google.cloud.aiplatform.v1.ExplanationParameters.xrai_attribution]
        /// and the input tensor is not differentiable.
        ///
        /// An encoded tensor is generated if the input tensor is encoded by a lookup
        /// table.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string EncodedTensorName {
          get { return encodedTensorName_; }
          set {
            encodedTensorName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "encoded_baselines" field.</summary>
        public const int EncodedBaselinesFieldNumber = 10;
        private static readonly pb::FieldCodec<global::Google.Protobuf.WellKnownTypes.Value> _repeated_encodedBaselines_codec
            = pb::FieldCodec.ForMessage(82, global::Google.Protobuf.WellKnownTypes.Value.Parser);
        private readonly pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Value> encodedBaselines_ = new pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Value>();
        /// <summary>
        /// A list of baselines for the encoded tensor.
        ///
        /// The shape of each baseline should match the shape of the encoded tensor.
        /// If a scalar is provided, Vertex AI broadcasts to the same shape as the
        /// encoded tensor.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Google.Protobuf.WellKnownTypes.Value> EncodedBaselines {
          get { return encodedBaselines_; }
        }

        /// <summary>Field number for the "visualization" field.</summary>
        public const int VisualizationFieldNumber = 11;
        private global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization visualization_;
        /// <summary>
        /// Visualization configurations for image explanation.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization Visualization {
          get { return visualization_; }
          set {
            visualization_ = value;
          }
        }

        /// <summary>Field number for the "group_name" field.</summary>
        public const int GroupNameFieldNumber = 12;
        private string groupName_ = "";
        /// <summary>
        /// Name of the group that the input belongs to. Features with the same group
        /// name will be treated as one feature when computing attributions. Features
        /// grouped together can have different shapes in value. If provided, there
        /// will be one single attribution generated in
        /// [Attribution.feature_attributions][google.cloud.aiplatform.v1.Attribution.feature_attributions],
        /// keyed by the group name.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string GroupName {
          get { return groupName_; }
          set {
            groupName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as InputMetadata);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(InputMetadata other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!inputBaselines_.Equals(other.inputBaselines_)) return false;
          if (InputTensorName != other.InputTensorName) return false;
          if (Encoding != other.Encoding) return false;
          if (Modality != other.Modality) return false;
          if (!object.Equals(FeatureValueDomain, other.FeatureValueDomain)) return false;
          if (IndicesTensorName != other.IndicesTensorName) return false;
          if (DenseShapeTensorName != other.DenseShapeTensorName) return false;
          if(!indexFeatureMapping_.Equals(other.indexFeatureMapping_)) return false;
          if (EncodedTensorName != other.EncodedTensorName) return false;
          if(!encodedBaselines_.Equals(other.encodedBaselines_)) return false;
          if (!object.Equals(Visualization, other.Visualization)) return false;
          if (GroupName != other.GroupName) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= inputBaselines_.GetHashCode();
          if (InputTensorName.Length != 0) hash ^= InputTensorName.GetHashCode();
          if (Encoding != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Encoding.Unspecified) hash ^= Encoding.GetHashCode();
          if (Modality.Length != 0) hash ^= Modality.GetHashCode();
          if (featureValueDomain_ != null) hash ^= FeatureValueDomain.GetHashCode();
          if (IndicesTensorName.Length != 0) hash ^= IndicesTensorName.GetHashCode();
          if (DenseShapeTensorName.Length != 0) hash ^= DenseShapeTensorName.GetHashCode();
          hash ^= indexFeatureMapping_.GetHashCode();
          if (EncodedTensorName.Length != 0) hash ^= EncodedTensorName.GetHashCode();
          hash ^= encodedBaselines_.GetHashCode();
          if (visualization_ != null) hash ^= Visualization.GetHashCode();
          if (GroupName.Length != 0) hash ^= GroupName.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          inputBaselines_.WriteTo(output, _repeated_inputBaselines_codec);
          if (InputTensorName.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(InputTensorName);
          }
          if (Encoding != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Encoding.Unspecified) {
            output.WriteRawTag(24);
            output.WriteEnum((int) Encoding);
          }
          if (Modality.Length != 0) {
            output.WriteRawTag(34);
            output.WriteString(Modality);
          }
          if (featureValueDomain_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(FeatureValueDomain);
          }
          if (IndicesTensorName.Length != 0) {
            output.WriteRawTag(50);
            output.WriteString(IndicesTensorName);
          }
          if (DenseShapeTensorName.Length != 0) {
            output.WriteRawTag(58);
            output.WriteString(DenseShapeTensorName);
          }
          indexFeatureMapping_.WriteTo(output, _repeated_indexFeatureMapping_codec);
          if (EncodedTensorName.Length != 0) {
            output.WriteRawTag(74);
            output.WriteString(EncodedTensorName);
          }
          encodedBaselines_.WriteTo(output, _repeated_encodedBaselines_codec);
          if (visualization_ != null) {
            output.WriteRawTag(90);
            output.WriteMessage(Visualization);
          }
          if (GroupName.Length != 0) {
            output.WriteRawTag(98);
            output.WriteString(GroupName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          inputBaselines_.WriteTo(ref output, _repeated_inputBaselines_codec);
          if (InputTensorName.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(InputTensorName);
          }
          if (Encoding != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Encoding.Unspecified) {
            output.WriteRawTag(24);
            output.WriteEnum((int) Encoding);
          }
          if (Modality.Length != 0) {
            output.WriteRawTag(34);
            output.WriteString(Modality);
          }
          if (featureValueDomain_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(FeatureValueDomain);
          }
          if (IndicesTensorName.Length != 0) {
            output.WriteRawTag(50);
            output.WriteString(IndicesTensorName);
          }
          if (DenseShapeTensorName.Length != 0) {
            output.WriteRawTag(58);
            output.WriteString(DenseShapeTensorName);
          }
          indexFeatureMapping_.WriteTo(ref output, _repeated_indexFeatureMapping_codec);
          if (EncodedTensorName.Length != 0) {
            output.WriteRawTag(74);
            output.WriteString(EncodedTensorName);
          }
          encodedBaselines_.WriteTo(ref output, _repeated_encodedBaselines_codec);
          if (visualization_ != null) {
            output.WriteRawTag(90);
            output.WriteMessage(Visualization);
          }
          if (GroupName.Length != 0) {
            output.WriteRawTag(98);
            output.WriteString(GroupName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          size += inputBaselines_.CalculateSize(_repeated_inputBaselines_codec);
          if (InputTensorName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(InputTensorName);
          }
          if (Encoding != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Encoding.Unspecified) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Encoding);
          }
          if (Modality.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Modality);
          }
          if (featureValueDomain_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(FeatureValueDomain);
          }
          if (IndicesTensorName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(IndicesTensorName);
          }
          if (DenseShapeTensorName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(DenseShapeTensorName);
          }
          size += indexFeatureMapping_.CalculateSize(_repeated_indexFeatureMapping_codec);
          if (EncodedTensorName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(EncodedTensorName);
          }
          size += encodedBaselines_.CalculateSize(_repeated_encodedBaselines_codec);
          if (visualization_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Visualization);
          }
          if (GroupName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(GroupName);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(InputMetadata other) {
          if (other == null) {
            return;
          }
          inputBaselines_.Add(other.inputBaselines_);
          if (other.InputTensorName.Length != 0) {
            InputTensorName = other.InputTensorName;
          }
          if (other.Encoding != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Encoding.Unspecified) {
            Encoding = other.Encoding;
          }
          if (other.Modality.Length != 0) {
            Modality = other.Modality;
          }
          if (other.featureValueDomain_ != null) {
            if (featureValueDomain_ == null) {
              FeatureValueDomain = new global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.FeatureValueDomain();
            }
            FeatureValueDomain.MergeFrom(other.FeatureValueDomain);
          }
          if (other.IndicesTensorName.Length != 0) {
            IndicesTensorName = other.IndicesTensorName;
          }
          if (other.DenseShapeTensorName.Length != 0) {
            DenseShapeTensorName = other.DenseShapeTensorName;
          }
          indexFeatureMapping_.Add(other.indexFeatureMapping_);
          if (other.EncodedTensorName.Length != 0) {
            EncodedTensorName = other.EncodedTensorName;
          }
          encodedBaselines_.Add(other.encodedBaselines_);
          if (other.visualization_ != null) {
            if (visualization_ == null) {
              Visualization = new global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization();
            }
            Visualization.MergeFrom(other.Visualization);
          }
          if (other.GroupName.Length != 0) {
            GroupName = other.GroupName;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                inputBaselines_.AddEntriesFrom(input, _repeated_inputBaselines_codec);
                break;
              }
              case 18: {
                InputTensorName = input.ReadString();
                break;
              }
              case 24: {
                Encoding = (global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Encoding) input.ReadEnum();
                break;
              }
              case 34: {
                Modality = input.ReadString();
                break;
              }
              case 42: {
                if (featureValueDomain_ == null) {
                  FeatureValueDomain = new global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.FeatureValueDomain();
                }
                input.ReadMessage(FeatureValueDomain);
                break;
              }
              case 50: {
                IndicesTensorName = input.ReadString();
                break;
              }
              case 58: {
                DenseShapeTensorName = input.ReadString();
                break;
              }
              case 66: {
                indexFeatureMapping_.AddEntriesFrom(input, _repeated_indexFeatureMapping_codec);
                break;
              }
              case 74: {
                EncodedTensorName = input.ReadString();
                break;
              }
              case 82: {
                encodedBaselines_.AddEntriesFrom(input, _repeated_encodedBaselines_codec);
                break;
              }
              case 90: {
                if (visualization_ == null) {
                  Visualization = new global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization();
                }
                input.ReadMessage(Visualization);
                break;
              }
              case 98: {
                GroupName = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                inputBaselines_.AddEntriesFrom(ref input, _repeated_inputBaselines_codec);
                break;
              }
              case 18: {
                InputTensorName = input.ReadString();
                break;
              }
              case 24: {
                Encoding = (global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Encoding) input.ReadEnum();
                break;
              }
              case 34: {
                Modality = input.ReadString();
                break;
              }
              case 42: {
                if (featureValueDomain_ == null) {
                  FeatureValueDomain = new global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.FeatureValueDomain();
                }
                input.ReadMessage(FeatureValueDomain);
                break;
              }
              case 50: {
                IndicesTensorName = input.ReadString();
                break;
              }
              case 58: {
                DenseShapeTensorName = input.ReadString();
                break;
              }
              case 66: {
                indexFeatureMapping_.AddEntriesFrom(ref input, _repeated_indexFeatureMapping_codec);
                break;
              }
              case 74: {
                EncodedTensorName = input.ReadString();
                break;
              }
              case 82: {
                encodedBaselines_.AddEntriesFrom(ref input, _repeated_encodedBaselines_codec);
                break;
              }
              case 90: {
                if (visualization_ == null) {
                  Visualization = new global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization();
                }
                input.ReadMessage(Visualization);
                break;
              }
              case 98: {
                GroupName = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the InputMetadata message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          /// Defines how a feature is encoded. Defaults to IDENTITY.
          /// </summary>
          public enum Encoding {
            /// <summary>
            /// Default value. This is the same as IDENTITY.
            /// </summary>
            [pbr::OriginalName("ENCODING_UNSPECIFIED")] Unspecified = 0,
            /// <summary>
            /// The tensor represents one feature.
            /// </summary>
            [pbr::OriginalName("IDENTITY")] Identity = 1,
            /// <summary>
            /// The tensor represents a bag of features where each index maps to
            /// a feature.
            /// [InputMetadata.index_feature_mapping][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.index_feature_mapping]
            /// must be provided for this encoding. For example:
            /// ```
            /// input = [27, 6.0, 150]
            /// index_feature_mapping = ["age", "height", "weight"]
            /// ```
            /// </summary>
            [pbr::OriginalName("BAG_OF_FEATURES")] BagOfFeatures = 2,
            /// <summary>
            /// The tensor represents a bag of features where each index maps to a
            /// feature. Zero values in the tensor indicates feature being
            /// non-existent.
            /// [InputMetadata.index_feature_mapping][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.index_feature_mapping]
            /// must be provided for this encoding. For example:
            /// ```
            /// input = [2, 0, 5, 0, 1]
            /// index_feature_mapping = ["a", "b", "c", "d", "e"]
            /// ```
            /// </summary>
            [pbr::OriginalName("BAG_OF_FEATURES_SPARSE")] BagOfFeaturesSparse = 3,
            /// <summary>
            /// The tensor is a list of binaries representing whether a feature exists
            /// or not (1 indicates existence).
            /// [InputMetadata.index_feature_mapping][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.index_feature_mapping]
            /// must be provided for this encoding. For example:
            /// ```
            /// input = [1, 0, 1, 0, 1]
            /// index_feature_mapping = ["a", "b", "c", "d", "e"]
            /// ```
            /// </summary>
            [pbr::OriginalName("INDICATOR")] Indicator = 4,
            /// <summary>
            /// The tensor is encoded into a 1-dimensional array represented by an
            /// encoded tensor.
            /// [InputMetadata.encoded_tensor_name][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.encoded_tensor_name]
            /// must be provided for this encoding. For example:
            /// ```
            /// input = ["This", "is", "a", "test", "."]
            /// encoded = [0.1, 0.2, 0.3, 0.4, 0.5]
            /// ```
            /// </summary>
            [pbr::OriginalName("COMBINED_EMBEDDING")] CombinedEmbedding = 5,
            /// <summary>
            /// Select this encoding when the input tensor is encoded into a
            /// 2-dimensional array represented by an encoded tensor.
            /// [InputMetadata.encoded_tensor_name][google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.encoded_tensor_name]
            /// must be provided for this encoding. The first dimension of the encoded
            /// tensor's shape is the same as the input tensor's shape. For example:
            /// ```
            /// input = ["This", "is", "a", "test", "."]
            /// encoded = [[0.1, 0.2, 0.3, 0.4, 0.5],
            ///            [0.2, 0.1, 0.4, 0.3, 0.5],
            ///            [0.5, 0.1, 0.3, 0.5, 0.4],
            ///            [0.5, 0.3, 0.1, 0.2, 0.4],
            ///            [0.4, 0.3, 0.2, 0.5, 0.1]]
            /// ```
            /// </summary>
            [pbr::OriginalName("CONCAT_EMBEDDING")] ConcatEmbedding = 6,
          }

          /// <summary>
          /// Domain details of the input feature value. Provides numeric information
          /// about the feature, such as its range (min, max). If the feature has been
          /// pre-processed, for example with z-scoring, then it provides information
          /// about how to recover the original feature. For example, if the input
          /// feature is an image and it has been pre-processed to obtain 0-mean and
          /// stddev = 1 values, then original_mean, and original_stddev refer to the
          /// mean and stddev of the original feature (e.g. image tensor) from which
          /// input feature (with mean = 0 and stddev = 1) was obtained.
          /// </summary>
          [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
          public sealed partial class FeatureValueDomain : pb::IMessage<FeatureValueDomain>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<FeatureValueDomain> _parser = new pb::MessageParser<FeatureValueDomain>(() => new FeatureValueDomain());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<FeatureValueDomain> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public FeatureValueDomain() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public FeatureValueDomain(FeatureValueDomain other) : this() {
              minValue_ = other.minValue_;
              maxValue_ = other.maxValue_;
              originalMean_ = other.originalMean_;
              originalStddev_ = other.originalStddev_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public FeatureValueDomain Clone() {
              return new FeatureValueDomain(this);
            }

            /// <summary>Field number for the "min_value" field.</summary>
            public const int MinValueFieldNumber = 1;
            private float minValue_;
            /// <summary>
            /// The minimum permissible value for this feature.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public float MinValue {
              get { return minValue_; }
              set {
                minValue_ = value;
              }
            }

            /// <summary>Field number for the "max_value" field.</summary>
            public const int MaxValueFieldNumber = 2;
            private float maxValue_;
            /// <summary>
            /// The maximum permissible value for this feature.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public float MaxValue {
              get { return maxValue_; }
              set {
                maxValue_ = value;
              }
            }

            /// <summary>Field number for the "original_mean" field.</summary>
            public const int OriginalMeanFieldNumber = 3;
            private float originalMean_;
            /// <summary>
            /// If this input feature has been normalized to a mean value of 0,
            /// the original_mean specifies the mean value of the domain prior to
            /// normalization.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public float OriginalMean {
              get { return originalMean_; }
              set {
                originalMean_ = value;
              }
            }

            /// <summary>Field number for the "original_stddev" field.</summary>
            public const int OriginalStddevFieldNumber = 4;
            private float originalStddev_;
            /// <summary>
            /// If this input feature has been normalized to a standard deviation of
            /// 1.0, the original_stddev specifies the standard deviation of the domain
            /// prior to normalization.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public float OriginalStddev {
              get { return originalStddev_; }
              set {
                originalStddev_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as FeatureValueDomain);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(FeatureValueDomain other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinValue, other.MinValue)) return false;
              if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxValue, other.MaxValue)) return false;
              if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(OriginalMean, other.OriginalMean)) return false;
              if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(OriginalStddev, other.OriginalStddev)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (MinValue != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinValue);
              if (MaxValue != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxValue);
              if (OriginalMean != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(OriginalMean);
              if (OriginalStddev != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(OriginalStddev);
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (MinValue != 0F) {
                output.WriteRawTag(13);
                output.WriteFloat(MinValue);
              }
              if (MaxValue != 0F) {
                output.WriteRawTag(21);
                output.WriteFloat(MaxValue);
              }
              if (OriginalMean != 0F) {
                output.WriteRawTag(29);
                output.WriteFloat(OriginalMean);
              }
              if (OriginalStddev != 0F) {
                output.WriteRawTag(37);
                output.WriteFloat(OriginalStddev);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (MinValue != 0F) {
                output.WriteRawTag(13);
                output.WriteFloat(MinValue);
              }
              if (MaxValue != 0F) {
                output.WriteRawTag(21);
                output.WriteFloat(MaxValue);
              }
              if (OriginalMean != 0F) {
                output.WriteRawTag(29);
                output.WriteFloat(OriginalMean);
              }
              if (OriginalStddev != 0F) {
                output.WriteRawTag(37);
                output.WriteFloat(OriginalStddev);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (MinValue != 0F) {
                size += 1 + 4;
              }
              if (MaxValue != 0F) {
                size += 1 + 4;
              }
              if (OriginalMean != 0F) {
                size += 1 + 4;
              }
              if (OriginalStddev != 0F) {
                size += 1 + 4;
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(FeatureValueDomain other) {
              if (other == null) {
                return;
              }
              if (other.MinValue != 0F) {
                MinValue = other.MinValue;
              }
              if (other.MaxValue != 0F) {
                MaxValue = other.MaxValue;
              }
              if (other.OriginalMean != 0F) {
                OriginalMean = other.OriginalMean;
              }
              if (other.OriginalStddev != 0F) {
                OriginalStddev = other.OriginalStddev;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 13: {
                    MinValue = input.ReadFloat();
                    break;
                  }
                  case 21: {
                    MaxValue = input.ReadFloat();
                    break;
                  }
                  case 29: {
                    OriginalMean = input.ReadFloat();
                    break;
                  }
                  case 37: {
                    OriginalStddev = input.ReadFloat();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 13: {
                    MinValue = input.ReadFloat();
                    break;
                  }
                  case 21: {
                    MaxValue = input.ReadFloat();
                    break;
                  }
                  case 29: {
                    OriginalMean = input.ReadFloat();
                    break;
                  }
                  case 37: {
                    OriginalStddev = input.ReadFloat();
                    break;
                  }
                }
              }
            }
            #endif

          }

          /// <summary>
          /// Visualization configurations for image explanation.
          /// </summary>
          [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
          public sealed partial class Visualization : pb::IMessage<Visualization>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<Visualization> _parser = new pb::MessageParser<Visualization>(() => new Visualization());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<Visualization> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Descriptor.NestedTypes[1]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Visualization() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Visualization(Visualization other) : this() {
              type_ = other.type_;
              polarity_ = other.polarity_;
              colorMap_ = other.colorMap_;
              clipPercentUpperbound_ = other.clipPercentUpperbound_;
              clipPercentLowerbound_ = other.clipPercentLowerbound_;
              overlayType_ = other.overlayType_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Visualization Clone() {
              return new Visualization(this);
            }

            /// <summary>Field number for the "type" field.</summary>
            public const int TypeFieldNumber = 1;
            private global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.Type type_ = global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.Type.Unspecified;
            /// <summary>
            /// Type of the image visualization. Only applicable to
            /// [Integrated Gradients
            /// attribution][google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution].
            /// OUTLINES shows regions of attribution, while PIXELS shows per-pixel
            /// attribution. Defaults to OUTLINES.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.Type Type {
              get { return type_; }
              set {
                type_ = value;
              }
            }

            /// <summary>Field number for the "polarity" field.</summary>
            public const int PolarityFieldNumber = 2;
            private global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.Polarity polarity_ = global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.Polarity.Unspecified;
            /// <summary>
            /// Whether to only highlight pixels with positive contributions, negative
            /// or both. Defaults to POSITIVE.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.Polarity Polarity {
              get { return polarity_; }
              set {
                polarity_ = value;
              }
            }

            /// <summary>Field number for the "color_map" field.</summary>
            public const int ColorMapFieldNumber = 3;
            private global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.ColorMap colorMap_ = global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.ColorMap.Unspecified;
            /// <summary>
            /// The color scheme used for the highlighted areas.
            ///
            /// Defaults to PINK_GREEN for
            /// [Integrated Gradients
            /// attribution][google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution],
            /// which shows positive attributions in green and negative in pink.
            ///
            /// Defaults to VIRIDIS for
            /// [XRAI
            /// attribution][google.cloud.aiplatform.v1.ExplanationParameters.xrai_attribution],
            /// which highlights the most influential regions in yellow and the least
            /// influential in blue.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.ColorMap ColorMap {
              get { return colorMap_; }
              set {
                colorMap_ = value;
              }
            }

            /// <summary>Field number for the "clip_percent_upperbound" field.</summary>
            public const int ClipPercentUpperboundFieldNumber = 4;
            private float clipPercentUpperbound_;
            /// <summary>
            /// Excludes attributions above the specified percentile from the
            /// highlighted areas. Using the clip_percent_upperbound and
            /// clip_percent_lowerbound together can be useful for filtering out noise
            /// and making it easier to see areas of strong attribution. Defaults to
            /// 99.9.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public float ClipPercentUpperbound {
              get { return clipPercentUpperbound_; }
              set {
                clipPercentUpperbound_ = value;
              }
            }

            /// <summary>Field number for the "clip_percent_lowerbound" field.</summary>
            public const int ClipPercentLowerboundFieldNumber = 5;
            private float clipPercentLowerbound_;
            /// <summary>
            /// Excludes attributions below the specified percentile, from the
            /// highlighted areas. Defaults to 62.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public float ClipPercentLowerbound {
              get { return clipPercentLowerbound_; }
              set {
                clipPercentLowerbound_ = value;
              }
            }

            /// <summary>Field number for the "overlay_type" field.</summary>
            public const int OverlayTypeFieldNumber = 6;
            private global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.OverlayType overlayType_ = global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.OverlayType.Unspecified;
            /// <summary>
            /// How the original image is displayed in the visualization.
            /// Adjusting the overlay can help increase visual clarity if the original
            /// image makes it difficult to view the visualization. Defaults to NONE.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.OverlayType OverlayType {
              get { return overlayType_; }
              set {
                overlayType_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as Visualization);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(Visualization other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Type != other.Type) return false;
              if (Polarity != other.Polarity) return false;
              if (ColorMap != other.ColorMap) return false;
              if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(ClipPercentUpperbound, other.ClipPercentUpperbound)) return false;
              if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(ClipPercentLowerbound, other.ClipPercentLowerbound)) return false;
              if (OverlayType != other.OverlayType) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (Type != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.Type.Unspecified) hash ^= Type.GetHashCode();
              if (Polarity != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.Polarity.Unspecified) hash ^= Polarity.GetHashCode();
              if (ColorMap != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.ColorMap.Unspecified) hash ^= ColorMap.GetHashCode();
              if (ClipPercentUpperbound != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(ClipPercentUpperbound);
              if (ClipPercentLowerbound != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(ClipPercentLowerbound);
              if (OverlayType != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.OverlayType.Unspecified) hash ^= OverlayType.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (Type != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.Type.Unspecified) {
                output.WriteRawTag(8);
                output.WriteEnum((int) Type);
              }
              if (Polarity != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.Polarity.Unspecified) {
                output.WriteRawTag(16);
                output.WriteEnum((int) Polarity);
              }
              if (ColorMap != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.ColorMap.Unspecified) {
                output.WriteRawTag(24);
                output.WriteEnum((int) ColorMap);
              }
              if (ClipPercentUpperbound != 0F) {
                output.WriteRawTag(37);
                output.WriteFloat(ClipPercentUpperbound);
              }
              if (ClipPercentLowerbound != 0F) {
                output.WriteRawTag(45);
                output.WriteFloat(ClipPercentLowerbound);
              }
              if (OverlayType != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.OverlayType.Unspecified) {
                output.WriteRawTag(48);
                output.WriteEnum((int) OverlayType);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (Type != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.Type.Unspecified) {
                output.WriteRawTag(8);
                output.WriteEnum((int) Type);
              }
              if (Polarity != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.Polarity.Unspecified) {
                output.WriteRawTag(16);
                output.WriteEnum((int) Polarity);
              }
              if (ColorMap != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.ColorMap.Unspecified) {
                output.WriteRawTag(24);
                output.WriteEnum((int) ColorMap);
              }
              if (ClipPercentUpperbound != 0F) {
                output.WriteRawTag(37);
                output.WriteFloat(ClipPercentUpperbound);
              }
              if (ClipPercentLowerbound != 0F) {
                output.WriteRawTag(45);
                output.WriteFloat(ClipPercentLowerbound);
              }
              if (OverlayType != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.OverlayType.Unspecified) {
                output.WriteRawTag(48);
                output.WriteEnum((int) OverlayType);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (Type != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.Type.Unspecified) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
              }
              if (Polarity != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.Polarity.Unspecified) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Polarity);
              }
              if (ColorMap != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.ColorMap.Unspecified) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ColorMap);
              }
              if (ClipPercentUpperbound != 0F) {
                size += 1 + 4;
              }
              if (ClipPercentLowerbound != 0F) {
                size += 1 + 4;
              }
              if (OverlayType != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.OverlayType.Unspecified) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) OverlayType);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(Visualization other) {
              if (other == null) {
                return;
              }
              if (other.Type != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.Type.Unspecified) {
                Type = other.Type;
              }
              if (other.Polarity != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.Polarity.Unspecified) {
                Polarity = other.Polarity;
              }
              if (other.ColorMap != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.ColorMap.Unspecified) {
                ColorMap = other.ColorMap;
              }
              if (other.ClipPercentUpperbound != 0F) {
                ClipPercentUpperbound = other.ClipPercentUpperbound;
              }
              if (other.ClipPercentLowerbound != 0F) {
                ClipPercentLowerbound = other.ClipPercentLowerbound;
              }
              if (other.OverlayType != global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.OverlayType.Unspecified) {
                OverlayType = other.OverlayType;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 8: {
                    Type = (global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.Type) input.ReadEnum();
                    break;
                  }
                  case 16: {
                    Polarity = (global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.Polarity) input.ReadEnum();
                    break;
                  }
                  case 24: {
                    ColorMap = (global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.ColorMap) input.ReadEnum();
                    break;
                  }
                  case 37: {
                    ClipPercentUpperbound = input.ReadFloat();
                    break;
                  }
                  case 45: {
                    ClipPercentLowerbound = input.ReadFloat();
                    break;
                  }
                  case 48: {
                    OverlayType = (global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.OverlayType) input.ReadEnum();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 8: {
                    Type = (global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.Type) input.ReadEnum();
                    break;
                  }
                  case 16: {
                    Polarity = (global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.Polarity) input.ReadEnum();
                    break;
                  }
                  case 24: {
                    ColorMap = (global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.ColorMap) input.ReadEnum();
                    break;
                  }
                  case 37: {
                    ClipPercentUpperbound = input.ReadFloat();
                    break;
                  }
                  case 45: {
                    ClipPercentLowerbound = input.ReadFloat();
                    break;
                  }
                  case 48: {
                    OverlayType = (global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Types.InputMetadata.Types.Visualization.Types.OverlayType) input.ReadEnum();
                    break;
                  }
                }
              }
            }
            #endif

            #region Nested types
            /// <summary>Container for nested types declared in the Visualization message type.</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static partial class Types {
              /// <summary>
              /// Type of the image visualization. Only applicable to
              /// [Integrated Gradients
              /// attribution][google.cloud.aiplatform.v1.ExplanationParameters.integrated_gradients_attribution].
              /// </summary>
              public enum Type {
                /// <summary>
                /// Should not be used.
                /// </summary>
                [pbr::OriginalName("TYPE_UNSPECIFIED")] Unspecified = 0,
                /// <summary>
                /// Shows which pixel contributed to the image prediction.
                /// </summary>
                [pbr::OriginalName("PIXELS")] Pixels = 1,
                /// <summary>
                /// Shows which region contributed to the image prediction by outlining
                /// the region.
                /// </summary>
                [pbr::OriginalName("OUTLINES")] Outlines = 2,
              }

              /// <summary>
              /// Whether to only highlight pixels with positive contributions, negative
              /// or both. Defaults to POSITIVE.
              /// </summary>
              public enum Polarity {
                /// <summary>
                /// Default value. This is the same as POSITIVE.
                /// </summary>
                [pbr::OriginalName("POLARITY_UNSPECIFIED")] Unspecified = 0,
                /// <summary>
                /// Highlights the pixels/outlines that were most influential to the
                /// model's prediction.
                /// </summary>
                [pbr::OriginalName("POSITIVE")] Positive = 1,
                /// <summary>
                /// Setting polarity to negative highlights areas that does not lead to
                /// the models's current prediction.
                /// </summary>
                [pbr::OriginalName("NEGATIVE")] Negative = 2,
                /// <summary>
                /// Shows both positive and negative attributions.
                /// </summary>
                [pbr::OriginalName("BOTH")] Both = 3,
              }

              /// <summary>
              /// The color scheme used for highlighting areas.
              /// </summary>
              public enum ColorMap {
                /// <summary>
                /// Should not be used.
                /// </summary>
                [pbr::OriginalName("COLOR_MAP_UNSPECIFIED")] Unspecified = 0,
                /// <summary>
                /// Positive: green. Negative: pink.
                /// </summary>
                [pbr::OriginalName("PINK_GREEN")] PinkGreen = 1,
                /// <summary>
                /// Viridis color map: A perceptually uniform color mapping which is
                /// easier to see by those with colorblindness and progresses from yellow
                /// to green to blue. Positive: yellow. Negative: blue.
                /// </summary>
                [pbr::OriginalName("VIRIDIS")] Viridis = 2,
                /// <summary>
                /// Positive: red. Negative: red.
                /// </summary>
                [pbr::OriginalName("RED")] Red = 3,
                /// <summary>
                /// Positive: green. Negative: green.
                /// </summary>
                [pbr::OriginalName("GREEN")] Green = 4,
                /// <summary>
                /// Positive: green. Negative: red.
                /// </summary>
                [pbr::OriginalName("RED_GREEN")] RedGreen = 6,
                /// <summary>
                /// PiYG palette.
                /// </summary>
                [pbr::OriginalName("PINK_WHITE_GREEN")] PinkWhiteGreen = 5,
              }

              /// <summary>
              /// How the original image is displayed in the visualization.
              /// </summary>
              public enum OverlayType {
                /// <summary>
                /// Default value. This is the same as NONE.
                /// </summary>
                [pbr::OriginalName("OVERLAY_TYPE_UNSPECIFIED")] Unspecified = 0,
                /// <summary>
                /// No overlay.
                /// </summary>
                [pbr::OriginalName("NONE")] None = 1,
                /// <summary>
                /// The attributions are shown on top of the original image.
                /// </summary>
                [pbr::OriginalName("ORIGINAL")] Original = 2,
                /// <summary>
                /// The attributions are shown on top of grayscaled version of the
                /// original image.
                /// </summary>
                [pbr::OriginalName("GRAYSCALE")] Grayscale = 3,
                /// <summary>
                /// The attributions are used as a mask to reveal predictive parts of
                /// the image and hide the un-predictive parts.
                /// </summary>
                [pbr::OriginalName("MASK_BLACK")] MaskBlack = 4,
              }

            }
            #endregion

          }

        }
        #endregion

      }

      /// <summary>
      /// Metadata of the prediction output to be explained.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class OutputMetadata : pb::IMessage<OutputMetadata>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<OutputMetadata> _parser = new pb::MessageParser<OutputMetadata>(() => new OutputMetadata());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<OutputMetadata> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Google.Cloud.AIPlatform.V1.ExplanationMetadata.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public OutputMetadata() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public OutputMetadata(OutputMetadata other) : this() {
          outputTensorName_ = other.outputTensorName_;
          switch (other.DisplayNameMappingCase) {
            case DisplayNameMappingOneofCase.IndexDisplayNameMapping:
              IndexDisplayNameMapping = other.IndexDisplayNameMapping.Clone();
              break;
            case DisplayNameMappingOneofCase.DisplayNameMappingKey:
              DisplayNameMappingKey = other.DisplayNameMappingKey;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public OutputMetadata Clone() {
          return new OutputMetadata(this);
        }

        /// <summary>Field number for the "index_display_name_mapping" field.</summary>
        public const int IndexDisplayNameMappingFieldNumber = 1;
        /// <summary>
        /// Static mapping between the index and display name.
        ///
        /// Use this if the outputs are a deterministic n-dimensional array, e.g. a
        /// list of scores of all the classes in a pre-defined order for a
        /// multi-classification Model. It's not feasible if the outputs are
        /// non-deterministic, e.g. the Model produces top-k classes or sort the
        /// outputs by their values.
        ///
        /// The shape of the value must be an n-dimensional array of strings. The
        /// number of dimensions must match that of the outputs to be explained.
        /// The
        /// [Attribution.output_display_name][google.cloud.aiplatform.v1.Attribution.output_display_name]
        /// is populated by locating in the mapping with
        /// [Attribution.output_index][google.cloud.aiplatform.v1.Attribution.output_index].
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Google.Protobuf.WellKnownTypes.Value IndexDisplayNameMapping {
          get { return displayNameMappingCase_ == DisplayNameMappingOneofCase.IndexDisplayNameMapping ? (global::Google.Protobuf.WellKnownTypes.Value) displayNameMapping_ : null; }
          set {
            displayNameMapping_ = value;
            displayNameMappingCase_ = value == null ? DisplayNameMappingOneofCase.None : DisplayNameMappingOneofCase.IndexDisplayNameMapping;
          }
        }

        /// <summary>Field number for the "display_name_mapping_key" field.</summary>
        public const int DisplayNameMappingKeyFieldNumber = 2;
        /// <summary>
        /// Specify a field name in the prediction to look for the display name.
        ///
        /// Use this if the prediction contains the display names for the outputs.
        ///
        /// The display names in the prediction must have the same shape of the
        /// outputs, so that it can be located by
        /// [Attribution.output_index][google.cloud.aiplatform.v1.Attribution.output_index]
        /// for a specific output.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string DisplayNameMappingKey {
          get { return HasDisplayNameMappingKey ? (string) displayNameMapping_ : ""; }
          set {
            displayNameMapping_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            displayNameMappingCase_ = DisplayNameMappingOneofCase.DisplayNameMappingKey;
          }
        }
        /// <summary>Gets whether the "display_name_mapping_key" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasDisplayNameMappingKey {
          get { return displayNameMappingCase_ == DisplayNameMappingOneofCase.DisplayNameMappingKey; }
        }
        /// <summary> Clears the value of the oneof if it's currently set to "display_name_mapping_key" </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearDisplayNameMappingKey() {
          if (HasDisplayNameMappingKey) {
            ClearDisplayNameMapping();
          }
        }

        /// <summary>Field number for the "output_tensor_name" field.</summary>
        public const int OutputTensorNameFieldNumber = 3;
        private string outputTensorName_ = "";
        /// <summary>
        /// Name of the output tensor. Required and is only applicable to Vertex
        /// AI provided images for Tensorflow.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string OutputTensorName {
          get { return outputTensorName_; }
          set {
            outputTensorName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        private object displayNameMapping_;
        /// <summary>Enum of possible cases for the "display_name_mapping" oneof.</summary>
        public enum DisplayNameMappingOneofCase {
          None = 0,
          IndexDisplayNameMapping = 1,
          DisplayNameMappingKey = 2,
        }
        private DisplayNameMappingOneofCase displayNameMappingCase_ = DisplayNameMappingOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public DisplayNameMappingOneofCase DisplayNameMappingCase {
          get { return displayNameMappingCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearDisplayNameMapping() {
          displayNameMappingCase_ = DisplayNameMappingOneofCase.None;
          displayNameMapping_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as OutputMetadata);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(OutputMetadata other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(IndexDisplayNameMapping, other.IndexDisplayNameMapping)) return false;
          if (DisplayNameMappingKey != other.DisplayNameMappingKey) return false;
          if (OutputTensorName != other.OutputTensorName) return false;
          if (DisplayNameMappingCase != other.DisplayNameMappingCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (displayNameMappingCase_ == DisplayNameMappingOneofCase.IndexDisplayNameMapping) hash ^= IndexDisplayNameMapping.GetHashCode();
          if (HasDisplayNameMappingKey) hash ^= DisplayNameMappingKey.GetHashCode();
          if (OutputTensorName.Length != 0) hash ^= OutputTensorName.GetHashCode();
          hash ^= (int) displayNameMappingCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (displayNameMappingCase_ == DisplayNameMappingOneofCase.IndexDisplayNameMapping) {
            output.WriteRawTag(10);
            output.WriteMessage(IndexDisplayNameMapping);
          }
          if (HasDisplayNameMappingKey) {
            output.WriteRawTag(18);
            output.WriteString(DisplayNameMappingKey);
          }
          if (OutputTensorName.Length != 0) {
            output.WriteRawTag(26);
            output.WriteString(OutputTensorName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (displayNameMappingCase_ == DisplayNameMappingOneofCase.IndexDisplayNameMapping) {
            output.WriteRawTag(10);
            output.WriteMessage(IndexDisplayNameMapping);
          }
          if (HasDisplayNameMappingKey) {
            output.WriteRawTag(18);
            output.WriteString(DisplayNameMappingKey);
          }
          if (OutputTensorName.Length != 0) {
            output.WriteRawTag(26);
            output.WriteString(OutputTensorName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (displayNameMappingCase_ == DisplayNameMappingOneofCase.IndexDisplayNameMapping) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(IndexDisplayNameMapping);
          }
          if (HasDisplayNameMappingKey) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(DisplayNameMappingKey);
          }
          if (OutputTensorName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(OutputTensorName);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(OutputMetadata other) {
          if (other == null) {
            return;
          }
          if (other.OutputTensorName.Length != 0) {
            OutputTensorName = other.OutputTensorName;
          }
          switch (other.DisplayNameMappingCase) {
            case DisplayNameMappingOneofCase.IndexDisplayNameMapping:
              if (IndexDisplayNameMapping == null) {
                IndexDisplayNameMapping = new global::Google.Protobuf.WellKnownTypes.Value();
              }
              IndexDisplayNameMapping.MergeFrom(other.IndexDisplayNameMapping);
              break;
            case DisplayNameMappingOneofCase.DisplayNameMappingKey:
              DisplayNameMappingKey = other.DisplayNameMappingKey;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Google.Protobuf.WellKnownTypes.Value subBuilder = new global::Google.Protobuf.WellKnownTypes.Value();
                if (displayNameMappingCase_ == DisplayNameMappingOneofCase.IndexDisplayNameMapping) {
                  subBuilder.MergeFrom(IndexDisplayNameMapping);
                }
                input.ReadMessage(subBuilder);
                IndexDisplayNameMapping = subBuilder;
                break;
              }
              case 18: {
                DisplayNameMappingKey = input.ReadString();
                break;
              }
              case 26: {
                OutputTensorName = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                global::Google.Protobuf.WellKnownTypes.Value subBuilder = new global::Google.Protobuf.WellKnownTypes.Value();
                if (displayNameMappingCase_ == DisplayNameMappingOneofCase.IndexDisplayNameMapping) {
                  subBuilder.MergeFrom(IndexDisplayNameMapping);
                }
                input.ReadMessage(subBuilder);
                IndexDisplayNameMapping = subBuilder;
                break;
              }
              case 18: {
                DisplayNameMappingKey = input.ReadString();
                break;
              }
              case 26: {
                OutputTensorName = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
