// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: google/maps/fleetengine/v1/vehicle_api.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Maps.FleetEngine.V1 {

  /// <summary>Holder for reflection information generated from google/maps/fleetengine/v1/vehicle_api.proto</summary>
  public static partial class VehicleApiReflection {

    #region Descriptor
    /// <summary>File descriptor for google/maps/fleetengine/v1/vehicle_api.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static VehicleApiReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cixnb29nbGUvbWFwcy9mbGVldGVuZ2luZS92MS92ZWhpY2xlX2FwaS5wcm90",
            "bxITbWFwcy5mbGVldGVuZ2luZS52MRocZ29vZ2xlL2FwaS9hbm5vdGF0aW9u",
            "cy5wcm90bxoXZ29vZ2xlL2FwaS9jbGllbnQucHJvdG8aH2dvb2dsZS9hcGkv",
            "ZmllbGRfYmVoYXZpb3IucHJvdG8aGWdvb2dsZS9hcGkvcmVzb3VyY2UucHJv",
            "dG8aGGdvb2dsZS9hcGkvcm91dGluZy5wcm90bxoeZ29vZ2xlL2dlby90eXBl",
            "L3ZpZXdwb3J0LnByb3RvGixnb29nbGUvbWFwcy9mbGVldGVuZ2luZS92MS9m",
            "bGVldGVuZ2luZS5wcm90bxonZ29vZ2xlL21hcHMvZmxlZXRlbmdpbmUvdjEv",
            "aGVhZGVyLnByb3RvGilnb29nbGUvbWFwcy9mbGVldGVuZ2luZS92MS92ZWhp",
            "Y2xlcy5wcm90bxoeZ29vZ2xlL3Byb3RvYnVmL2R1cmF0aW9uLnByb3RvGiBn",
            "b29nbGUvcHJvdG9idWYvZmllbGRfbWFzay5wcm90bxofZ29vZ2xlL3Byb3Rv",
            "YnVmL3RpbWVzdGFtcC5wcm90bxoeZ29vZ2xlL3Byb3RvYnVmL3dyYXBwZXJz",
            "LnByb3RvGhhnb29nbGUvdHlwZS9sYXRsbmcucHJvdG8irAEKFENyZWF0ZVZl",
            "aGljbGVSZXF1ZXN0EjIKBmhlYWRlchgBIAEoCzIiLm1hcHMuZmxlZXRlbmdp",
            "bmUudjEuUmVxdWVzdEhlYWRlchITCgZwYXJlbnQYAyABKAlCA+BBAhIXCgp2",
            "ZWhpY2xlX2lkGAQgASgJQgPgQQISMgoHdmVoaWNsZRgFIAEoCzIcLm1hcHMu",
            "ZmxlZXRlbmdpbmUudjEuVmVoaWNsZUID4EECIvsBChFHZXRWZWhpY2xlUmVx",
            "dWVzdBIyCgZoZWFkZXIYASABKAsyIi5tYXBzLmZsZWV0ZW5naW5lLnYxLlJl",
            "cXVlc3RIZWFkZXISOAoEbmFtZRgDIAEoCUIq4EEC+kEkCiJmbGVldGVuZ2lu",
            "ZS5nb29nbGVhcGlzLmNvbS9WZWhpY2xlEkEKHWN1cnJlbnRfcm91dGVfc2Vn",
            "bWVudF92ZXJzaW9uGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFt",
            "cBI1ChF3YXlwb2ludHNfdmVyc2lvbhgFIAEoCzIaLmdvb2dsZS5wcm90b2J1",
            "Zi5UaW1lc3RhbXAixwEKFFVwZGF0ZVZlaGljbGVSZXF1ZXN0EjIKBmhlYWRl",
            "chgBIAEoCzIiLm1hcHMuZmxlZXRlbmdpbmUudjEuUmVxdWVzdEhlYWRlchIR",
            "CgRuYW1lGAMgASgJQgPgQQISMgoHdmVoaWNsZRgEIAEoCzIcLm1hcHMuZmxl",
            "ZXRlbmdpbmUudjEuVmVoaWNsZUID4EECEjQKC3VwZGF0ZV9tYXNrGAUgASgL",
            "MhouZ29vZ2xlLnByb3RvYnVmLkZpZWxkTWFza0ID4EECIqcBCh5VcGRhdGVW",
            "ZWhpY2xlQXR0cmlidXRlc1JlcXVlc3QSMgoGaGVhZGVyGAEgASgLMiIubWFw",
            "cy5mbGVldGVuZ2luZS52MS5SZXF1ZXN0SGVhZGVyEhEKBG5hbWUYAyABKAlC",
            "A+BBAhI+CgphdHRyaWJ1dGVzGAQgAygLMiUubWFwcy5mbGVldGVuZ2luZS52",
            "MS5WZWhpY2xlQXR0cmlidXRlQgPgQQIiYQofVXBkYXRlVmVoaWNsZUF0dHJp",
            "YnV0ZXNSZXNwb25zZRI+CgphdHRyaWJ1dGVzGAEgAygLMiUubWFwcy5mbGVl",
            "dGVuZ2luZS52MS5WZWhpY2xlQXR0cmlidXRlQgPgQQIixgkKFVNlYXJjaFZl",
            "aGljbGVzUmVxdWVzdBIyCgZoZWFkZXIYASABKAsyIi5tYXBzLmZsZWV0ZW5n",
            "aW5lLnYxLlJlcXVlc3RIZWFkZXISEwoGcGFyZW50GAMgASgJQgPgQQISQAoM",
            "cGlja3VwX3BvaW50GAQgASgLMiUubWFwcy5mbGVldGVuZ2luZS52MS5UZXJt",
            "aW5hbExvY2F0aW9uQgPgQQISPAoNZHJvcG9mZl9wb2ludBgFIAEoCzIlLm1h",
            "cHMuZmxlZXRlbmdpbmUudjEuVGVybWluYWxMb2NhdGlvbhIhChRwaWNrdXBf",
            "cmFkaXVzX21ldGVycxgGIAEoBUID4EECEhIKBWNvdW50GAcgASgFQgPgQQIS",
            "HQoQbWluaW11bV9jYXBhY2l0eRgIIAEoBUID4EECEjYKCnRyaXBfdHlwZXMY",
            "CSADKA4yHS5tYXBzLmZsZWV0ZW5naW5lLnYxLlRyaXBUeXBlQgPgQQISNAoR",
            "bWF4aW11bV9zdGFsZW5lc3MYCiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVy",
            "YXRpb24SRAoNdmVoaWNsZV90eXBlcxgOIAMoCzIoLm1hcHMuZmxlZXRlbmdp",
            "bmUudjEuVmVoaWNsZS5WZWhpY2xlVHlwZUID4EECEkIKE3JlcXVpcmVkX2F0",
            "dHJpYnV0ZXMYDCADKAsyJS5tYXBzLmZsZWV0ZW5naW5lLnYxLlZlaGljbGVB",
            "dHRyaWJ1dGUSTQoacmVxdWlyZWRfb25lX29mX2F0dHJpYnV0ZXMYDyADKAsy",
            "KS5tYXBzLmZsZWV0ZW5naW5lLnYxLlZlaGljbGVBdHRyaWJ1dGVMaXN0ElEK",
            "HnJlcXVpcmVkX29uZV9vZl9hdHRyaWJ1dGVfc2V0cxgUIAMoCzIpLm1hcHMu",
            "ZmxlZXRlbmdpbmUudjEuVmVoaWNsZUF0dHJpYnV0ZUxpc3QSUwoIb3JkZXJf",
            "YnkYDSABKA4yPC5tYXBzLmZsZWV0ZW5naW5lLnYxLlNlYXJjaFZlaGljbGVz",
            "UmVxdWVzdC5WZWhpY2xlTWF0Y2hPcmRlckID4EECEhwKFGluY2x1ZGVfYmFj",
            "a190b19iYWNrGBIgASgIEg8KB3RyaXBfaWQYEyABKAkSXQoVY3VycmVudF90",
            "cmlwc19wcmVzZW50GBUgASgOMj4ubWFwcy5mbGVldGVuZ2luZS52MS5TZWFy",
            "Y2hWZWhpY2xlc1JlcXVlc3QuQ3VycmVudFRyaXBzUHJlc2VudBITCgZmaWx0",
            "ZXIYFiABKAlCA+BBASKqAQoRVmVoaWNsZU1hdGNoT3JkZXISHwobVU5LTk9X",
            "Tl9WRUhJQ0xFX01BVENIX09SREVSEAASFAoQUElDS1VQX1BPSU5UX0VUQRAB",
            "EhkKFVBJQ0tVUF9QT0lOVF9ESVNUQU5DRRACEhUKEURST1BPRkZfUE9JTlRf",
            "RVRBEAMSIgoeUElDS1VQX1BPSU5UX1NUUkFJR0hUX0RJU1RBTkNFEAQSCAoE",
            "Q09TVBAFIk8KE0N1cnJlbnRUcmlwc1ByZXNlbnQSJQohQ1VSUkVOVF9UUklQ",
            "U19QUkVTRU5UX1VOU1BFQ0lGSUVEEAASCAoETk9ORRABEgcKA0FOWRACIkwK",
            "FlNlYXJjaFZlaGljbGVzUmVzcG9uc2USMgoHbWF0Y2hlcxgBIAMoCzIhLm1h",
            "cHMuZmxlZXRlbmdpbmUudjEuVmVoaWNsZU1hdGNoIv4EChNMaXN0VmVoaWNs",
            "ZXNSZXF1ZXN0EjIKBmhlYWRlchgMIAEoCzIiLm1hcHMuZmxlZXRlbmdpbmUu",
            "djEuUmVxdWVzdEhlYWRlchITCgZwYXJlbnQYASABKAlCA+BBAhIRCglwYWdl",
            "X3NpemUYAyABKAUSEgoKcGFnZV90b2tlbhgEIAEoCRI1ChBtaW5pbXVtX2Nh",
            "cGFjaXR5GAYgASgLMhsuZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWUSMQoK",
            "dHJpcF90eXBlcxgHIAMoDjIdLm1hcHMuZmxlZXRlbmdpbmUudjEuVHJpcFR5",
            "cGUSNAoRbWF4aW11bV9zdGFsZW5lc3MYCCABKAsyGS5nb29nbGUucHJvdG9i",
            "dWYuRHVyYXRpb24SVwoXdmVoaWNsZV90eXBlX2NhdGVnb3JpZXMYCSADKA4y",
            "MS5tYXBzLmZsZWV0ZW5naW5lLnYxLlZlaGljbGUuVmVoaWNsZVR5cGUuQ2F0",
            "ZWdvcnlCA+BBAhIbChNyZXF1aXJlZF9hdHRyaWJ1dGVzGAogAygJEiIKGnJl",
            "cXVpcmVkX29uZV9vZl9hdHRyaWJ1dGVzGA0gAygJEiYKHnJlcXVpcmVkX29u",
            "ZV9vZl9hdHRyaWJ1dGVfc2V0cxgPIAMoCRI4Cg12ZWhpY2xlX3N0YXRlGAsg",
            "ASgOMiEubWFwcy5mbGVldGVuZ2luZS52MS5WZWhpY2xlU3RhdGUSFAoMb25f",
            "dHJpcF9vbmx5GA4gASgIEhMKBmZpbHRlchgQIAEoCUID4EEBEjAKCHZpZXdw",
            "b3J0GBEgASgLMhkuZ29vZ2xlLmdlby50eXBlLlZpZXdwb3J0QgPgQQEieAoU",
            "TGlzdFZlaGljbGVzUmVzcG9uc2USLgoIdmVoaWNsZXMYASADKAsyHC5tYXBz",
            "LmZsZWV0ZW5naW5lLnYxLlZlaGljbGUSFwoPbmV4dF9wYWdlX3Rva2VuGAIg",
            "ASgJEhcKCnRvdGFsX3NpemUYAyABKANCA+BBAiJZCghXYXlwb2ludBIkCgds",
            "YXRfbG5nGAEgASgLMhMuZ29vZ2xlLnR5cGUuTGF0TG5nEicKA2V0YRgCIAEo",
            "CzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAi/gYKDFZlaGljbGVNYXRj",
            "aBIyCgd2ZWhpY2xlGAEgASgLMhwubWFwcy5mbGVldGVuZ2luZS52MS5WZWhp",
            "Y2xlQgPgQQISNgoSdmVoaWNsZV9waWNrdXBfZXRhGAIgASgLMhouZ29vZ2xl",
            "LnByb3RvYnVmLlRpbWVzdGFtcBJDCh52ZWhpY2xlX3BpY2t1cF9kaXN0YW5j",
            "ZV9tZXRlcnMYAyABKAsyGy5nb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZRJW",
            "Cix2ZWhpY2xlX3BpY2t1cF9zdHJhaWdodF9saW5lX2Rpc3RhbmNlX21ldGVy",
            "cxgLIAEoCzIbLmdvb2dsZS5wcm90b2J1Zi5JbnQzMlZhbHVlQgPgQQISNwoT",
            "dmVoaWNsZV9kcm9wb2ZmX2V0YRgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5U",
            "aW1lc3RhbXASTgopdmVoaWNsZV9waWNrdXBfdG9fZHJvcG9mZl9kaXN0YW5j",
            "ZV9tZXRlcnMYBSABKAsyGy5nb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZRI1",
            "Cgl0cmlwX3R5cGUYBiABKA4yHS5tYXBzLmZsZWV0ZW5naW5lLnYxLlRyaXBU",
            "eXBlQgPgQQISPgoXdmVoaWNsZV90cmlwc193YXlwb2ludHMYByADKAsyHS5t",
            "YXBzLmZsZWV0ZW5naW5lLnYxLldheXBvaW50Ek4KEnZlaGljbGVfbWF0Y2hf",
            "dHlwZRgIIAEoDjIyLm1hcHMuZmxlZXRlbmdpbmUudjEuVmVoaWNsZU1hdGNo",
            "LlZlaGljbGVNYXRjaFR5cGUSWgoUcmVxdWVzdGVkX29yZGVyZWRfYnkYCSAB",
            "KA4yPC5tYXBzLmZsZWV0ZW5naW5lLnYxLlNlYXJjaFZlaGljbGVzUmVxdWVz",
            "dC5WZWhpY2xlTWF0Y2hPcmRlchJQCgpvcmRlcmVkX2J5GAogASgOMjwubWFw",
            "cy5mbGVldGVuZ2luZS52MS5TZWFyY2hWZWhpY2xlc1JlcXVlc3QuVmVoaWNs",
            "ZU1hdGNoT3JkZXIiZwoQVmVoaWNsZU1hdGNoVHlwZRILCgdVTktOT1dOEAAS",
            "DQoJRVhDTFVTSVZFEAESEAoMQkFDS19UT19CQUNLEAISCwoHQ0FSUE9PTBAD",
            "EhgKFENBUlBPT0xfQkFDS19UT19CQUNLEAQiUQoUVmVoaWNsZUF0dHJpYnV0",
            "ZUxpc3QSOQoKYXR0cmlidXRlcxgBIAMoCzIlLm1hcHMuZmxlZXRlbmdpbmUu",
            "djEuVmVoaWNsZUF0dHJpYnV0ZTLyCQoOVmVoaWNsZVNlcnZpY2UStwEKDUNy",
            "ZWF0ZVZlaGljbGUSKS5tYXBzLmZsZWV0ZW5naW5lLnYxLkNyZWF0ZVZlaGlj",
            "bGVSZXF1ZXN0GhwubWFwcy5mbGVldGVuZ2luZS52MS5WZWhpY2xlIl2C0+ST",
            "AiwiIS92MS97cGFyZW50PXByb3ZpZGVycy8qfS92ZWhpY2xlczoHdmVoaWNs",
            "ZYrT5JMCJRIjCgZwYXJlbnQSGXtwcm92aWRlcl9pZD1wcm92aWRlcnMvKn0S",
            "pgEKCkdldFZlaGljbGUSJi5tYXBzLmZsZWV0ZW5naW5lLnYxLkdldFZlaGlj",
            "bGVSZXF1ZXN0GhwubWFwcy5mbGVldGVuZ2luZS52MS5WZWhpY2xlIlKC0+ST",
            "AiMSIS92MS97bmFtZT1wcm92aWRlcnMvKi92ZWhpY2xlcy8qfYrT5JMCIxIh",
            "CgRuYW1lEhl7cHJvdmlkZXJfaWQ9cHJvdmlkZXJzLyp9ErUBCg1VcGRhdGVW",
            "ZWhpY2xlEikubWFwcy5mbGVldGVuZ2luZS52MS5VcGRhdGVWZWhpY2xlUmVx",
            "dWVzdBocLm1hcHMuZmxlZXRlbmdpbmUudjEuVmVoaWNsZSJbgtPkkwIsGiEv",
            "djEve25hbWU9cHJvdmlkZXJzLyovdmVoaWNsZXMvKn06B3ZlaGljbGWK0+ST",
            "AiMSIQoEbmFtZRIZe3Byb3ZpZGVyX2lkPXByb3ZpZGVycy8qfRLsAQoXVXBk",
            "YXRlVmVoaWNsZUF0dHJpYnV0ZXMSMy5tYXBzLmZsZWV0ZW5naW5lLnYxLlVw",
            "ZGF0ZVZlaGljbGVBdHRyaWJ1dGVzUmVxdWVzdBo0Lm1hcHMuZmxlZXRlbmdp",
            "bmUudjEuVXBkYXRlVmVoaWNsZUF0dHJpYnV0ZXNSZXNwb25zZSJmgtPkkwI3",
            "IjIvdjEve25hbWU9cHJvdmlkZXJzLyovdmVoaWNsZXMvKn06dXBkYXRlQXR0",
            "cmlidXRlczoBKorT5JMCIxIhCgRuYW1lEhl7cHJvdmlkZXJfaWQ9cHJvdmlk",
            "ZXJzLyp9ErkBCgxMaXN0VmVoaWNsZXMSKC5tYXBzLmZsZWV0ZW5naW5lLnYx",
            "Lkxpc3RWZWhpY2xlc1JlcXVlc3QaKS5tYXBzLmZsZWV0ZW5naW5lLnYxLkxp",
            "c3RWZWhpY2xlc1Jlc3BvbnNlIlSC0+STAiMSIS92MS97cGFyZW50PXByb3Zp",
            "ZGVycy8qfS92ZWhpY2xlc4rT5JMCJRIjCgZwYXJlbnQSGXtwcm92aWRlcl9p",
            "ZD1wcm92aWRlcnMvKn0SyQEKDlNlYXJjaFZlaGljbGVzEioubWFwcy5mbGVl",
            "dGVuZ2luZS52MS5TZWFyY2hWZWhpY2xlc1JlcXVlc3QaKy5tYXBzLmZsZWV0",
            "ZW5naW5lLnYxLlNlYXJjaFZlaGljbGVzUmVzcG9uc2UiXoLT5JMCLSIoL3Yx",
            "L3twYXJlbnQ9cHJvdmlkZXJzLyp9L3ZlaGljbGVzOnNlYXJjaDoBKorT5JMC",
            "JRIjCgZwYXJlbnQSGXtwcm92aWRlcl9pZD1wcm92aWRlcnMvKn0aTspBGmZs",
            "ZWV0ZW5naW5lLmdvb2dsZWFwaXMuY29t0kEuaHR0cHM6Ly93d3cuZ29vZ2xl",
            "YXBpcy5jb20vYXV0aC9jbG91ZC1wbGF0Zm9ybULWAQoeY29tLmdvb2dsZS5t",
            "YXBzLmZsZWV0ZW5naW5lLnYxQgpWZWhpY2xlQXBpUAFaRmNsb3VkLmdvb2ds",
            "ZS5jb20vZ28vbWFwcy9mbGVldGVuZ2luZS9hcGl2MS9mbGVldGVuZ2luZXBi",
            "O2ZsZWV0ZW5naW5lcGKiAgNDRkWqAhpHb29nbGUuTWFwcy5GbGVldEVuZ2lu",
            "ZS5WMcoCGkdvb2dsZVxNYXBzXEZsZWV0RW5naW5lXFYx6gIdR29vZ2xlOjpN",
            "YXBzOjpGbGVldEVuZ2luZTo6VjFiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.AnnotationsReflection.Descriptor, global::Google.Api.ClientReflection.Descriptor, global::Google.Api.FieldBehaviorReflection.Descriptor, global::Google.Api.ResourceReflection.Descriptor, global::Google.Api.RoutingReflection.Descriptor, global::Google.Geo.Type.ViewportReflection.Descriptor, global::Google.Maps.FleetEngine.V1.FleetengineReflection.Descriptor, global::Google.Maps.FleetEngine.V1.HeaderReflection.Descriptor, global::Google.Maps.FleetEngine.V1.VehiclesReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.FieldMaskReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Google.Type.LatlngReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.FleetEngine.V1.CreateVehicleRequest), global::Google.Maps.FleetEngine.V1.CreateVehicleRequest.Parser, new[]{ "Header", "Parent", "VehicleId", "Vehicle" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.FleetEngine.V1.GetVehicleRequest), global::Google.Maps.FleetEngine.V1.GetVehicleRequest.Parser, new[]{ "Header", "Name", "CurrentRouteSegmentVersion", "WaypointsVersion" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.FleetEngine.V1.UpdateVehicleRequest), global::Google.Maps.FleetEngine.V1.UpdateVehicleRequest.Parser, new[]{ "Header", "Name", "Vehicle", "UpdateMask" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.FleetEngine.V1.UpdateVehicleAttributesRequest), global::Google.Maps.FleetEngine.V1.UpdateVehicleAttributesRequest.Parser, new[]{ "Header", "Name", "Attributes" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.FleetEngine.V1.UpdateVehicleAttributesResponse), global::Google.Maps.FleetEngine.V1.UpdateVehicleAttributesResponse.Parser, new[]{ "Attributes" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest), global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Parser, new[]{ "Header", "Parent", "PickupPoint", "DropoffPoint", "PickupRadiusMeters", "Count", "MinimumCapacity", "TripTypes", "MaximumStaleness", "VehicleTypes", "RequiredAttributes", "RequiredOneOfAttributes", "RequiredOneOfAttributeSets", "OrderBy", "IncludeBackToBack", "TripId", "CurrentTripsPresent", "Filter" }, null, new[]{ typeof(global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder), typeof(global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.CurrentTripsPresent) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.FleetEngine.V1.SearchVehiclesResponse), global::Google.Maps.FleetEngine.V1.SearchVehiclesResponse.Parser, new[]{ "Matches" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.FleetEngine.V1.ListVehiclesRequest), global::Google.Maps.FleetEngine.V1.ListVehiclesRequest.Parser, new[]{ "Header", "Parent", "PageSize", "PageToken", "MinimumCapacity", "TripTypes", "MaximumStaleness", "VehicleTypeCategories", "RequiredAttributes", "RequiredOneOfAttributes", "RequiredOneOfAttributeSets", "VehicleState", "OnTripOnly", "Filter", "Viewport" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.FleetEngine.V1.ListVehiclesResponse), global::Google.Maps.FleetEngine.V1.ListVehiclesResponse.Parser, new[]{ "Vehicles", "NextPageToken", "TotalSize" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.FleetEngine.V1.Waypoint), global::Google.Maps.FleetEngine.V1.Waypoint.Parser, new[]{ "LatLng", "Eta" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.FleetEngine.V1.VehicleMatch), global::Google.Maps.FleetEngine.V1.VehicleMatch.Parser, new[]{ "Vehicle", "VehiclePickupEta", "VehiclePickupDistanceMeters", "VehiclePickupStraightLineDistanceMeters", "VehicleDropoffEta", "VehiclePickupToDropoffDistanceMeters", "TripType", "VehicleTripsWaypoints", "VehicleMatchType", "RequestedOrderedBy", "OrderedBy" }, null, new[]{ typeof(global::Google.Maps.FleetEngine.V1.VehicleMatch.Types.VehicleMatchType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Maps.FleetEngine.V1.VehicleAttributeList), global::Google.Maps.FleetEngine.V1.VehicleAttributeList.Parser, new[]{ "Attributes" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// `CreateVehicle` request message.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class CreateVehicleRequest : pb::IMessage<CreateVehicleRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CreateVehicleRequest> _parser = new pb::MessageParser<CreateVehicleRequest>(() => new CreateVehicleRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CreateVehicleRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.FleetEngine.V1.VehicleApiReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CreateVehicleRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CreateVehicleRequest(CreateVehicleRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      parent_ = other.parent_;
      vehicleId_ = other.vehicleId_;
      vehicle_ = other.vehicle_ != null ? other.vehicle_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CreateVehicleRequest Clone() {
      return new CreateVehicleRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Google.Maps.FleetEngine.V1.RequestHeader header_;
    /// <summary>
    /// The standard Fleet Engine request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "parent" field.</summary>
    public const int ParentFieldNumber = 3;
    private string parent_ = "";
    /// <summary>
    /// Required. Must be in the format `providers/{provider}`.
    /// The provider must be the Project ID (for example, `sample-cloud-project`)
    /// of the Google Cloud Project of which the service account making
    /// this call is a member.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Parent {
      get { return parent_; }
      set {
        parent_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "vehicle_id" field.</summary>
    public const int VehicleIdFieldNumber = 4;
    private string vehicleId_ = "";
    /// <summary>
    /// Required. Unique Vehicle ID.
    /// Subject to the following restrictions:
    ///
    /// * Must be a valid Unicode string.
    /// * Limited to a maximum length of 64 characters.
    /// * Normalized according to [Unicode Normalization Form C]
    /// (http://www.unicode.org/reports/tr15/).
    /// * May not contain any of the following ASCII characters: '/', ':', '?',
    /// ',', or '#'.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string VehicleId {
      get { return vehicleId_; }
      set {
        vehicleId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "vehicle" field.</summary>
    public const int VehicleFieldNumber = 5;
    private global::Google.Maps.FleetEngine.V1.Vehicle vehicle_;
    /// <summary>
    /// Required. The Vehicle entity to create. When creating a Vehicle, the
    /// following fields are required:
    ///
    /// * `vehicleState`
    /// * `supportedTripTypes`
    /// * `maximumCapacity`
    /// * `vehicleType`
    ///
    /// When creating a Vehicle, the following fields are ignored:
    ///
    /// * `name`
    /// * `currentTrips`
    /// * `availableCapacity`
    /// * `current_route_segment`
    /// * `current_route_segment_end_point`
    /// * `current_route_segment_version`
    /// * `current_route_segment_traffic`
    /// * `route`
    /// * `waypoints`
    /// * `waypoints_version`
    /// * `remaining_distance_meters`
    /// * `remaining_time_seconds`
    /// * `eta_to_next_waypoint`
    /// * `navigation_status`
    ///
    /// All other fields are optional and used if provided.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.Vehicle Vehicle {
      get { return vehicle_; }
      set {
        vehicle_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CreateVehicleRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CreateVehicleRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (Parent != other.Parent) return false;
      if (VehicleId != other.VehicleId) return false;
      if (!object.Equals(Vehicle, other.Vehicle)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (Parent.Length != 0) hash ^= Parent.GetHashCode();
      if (VehicleId.Length != 0) hash ^= VehicleId.GetHashCode();
      if (vehicle_ != null) hash ^= Vehicle.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Parent.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Parent);
      }
      if (VehicleId.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(VehicleId);
      }
      if (vehicle_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Vehicle);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Parent.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Parent);
      }
      if (VehicleId.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(VehicleId);
      }
      if (vehicle_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Vehicle);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (Parent.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Parent);
      }
      if (VehicleId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VehicleId);
      }
      if (vehicle_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Vehicle);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CreateVehicleRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Google.Maps.FleetEngine.V1.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.Parent.Length != 0) {
        Parent = other.Parent;
      }
      if (other.VehicleId.Length != 0) {
        VehicleId = other.VehicleId;
      }
      if (other.vehicle_ != null) {
        if (vehicle_ == null) {
          Vehicle = new global::Google.Maps.FleetEngine.V1.Vehicle();
        }
        Vehicle.MergeFrom(other.Vehicle);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Google.Maps.FleetEngine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Parent = input.ReadString();
            break;
          }
          case 34: {
            VehicleId = input.ReadString();
            break;
          }
          case 42: {
            if (vehicle_ == null) {
              Vehicle = new global::Google.Maps.FleetEngine.V1.Vehicle();
            }
            input.ReadMessage(Vehicle);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Google.Maps.FleetEngine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Parent = input.ReadString();
            break;
          }
          case 34: {
            VehicleId = input.ReadString();
            break;
          }
          case 42: {
            if (vehicle_ == null) {
              Vehicle = new global::Google.Maps.FleetEngine.V1.Vehicle();
            }
            input.ReadMessage(Vehicle);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// `GetVehicle` request message.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class GetVehicleRequest : pb::IMessage<GetVehicleRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GetVehicleRequest> _parser = new pb::MessageParser<GetVehicleRequest>(() => new GetVehicleRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<GetVehicleRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.FleetEngine.V1.VehicleApiReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GetVehicleRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GetVehicleRequest(GetVehicleRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      name_ = other.name_;
      currentRouteSegmentVersion_ = other.currentRouteSegmentVersion_ != null ? other.currentRouteSegmentVersion_.Clone() : null;
      waypointsVersion_ = other.waypointsVersion_ != null ? other.waypointsVersion_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GetVehicleRequest Clone() {
      return new GetVehicleRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Google.Maps.FleetEngine.V1.RequestHeader header_;
    /// <summary>
    /// The standard Fleet Engine request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 3;
    private string name_ = "";
    /// <summary>
    /// Required. Must be in the format
    /// `providers/{provider}/vehicles/{vehicle}`.
    /// The provider must be the Project ID (for example, `sample-cloud-project`)
    /// of the Google Cloud Project of which the service account making
    /// this call is a member.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "current_route_segment_version" field.</summary>
    public const int CurrentRouteSegmentVersionFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Timestamp currentRouteSegmentVersion_;
    /// <summary>
    /// Indicates the minimum timestamp (exclusive) for which
    /// `Vehicle.current_route_segment` is retrieved.
    /// If the route is unchanged since this timestamp, the `current_route_segment`
    /// field is not set in the response. If a minimum is unspecified, the
    /// `current_route_segment` is always retrieved.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp CurrentRouteSegmentVersion {
      get { return currentRouteSegmentVersion_; }
      set {
        currentRouteSegmentVersion_ = value;
      }
    }

    /// <summary>Field number for the "waypoints_version" field.</summary>
    public const int WaypointsVersionFieldNumber = 5;
    private global::Google.Protobuf.WellKnownTypes.Timestamp waypointsVersion_;
    /// <summary>
    /// Indicates the minimum timestamp (exclusive) for which `Vehicle.waypoints`
    /// data is retrieved. If the waypoints are unchanged since this timestamp, the
    /// `vehicle.waypoints` data is not set in the response. If this field is
    /// unspecified, `vehicle.waypoints` is always retrieved.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp WaypointsVersion {
      get { return waypointsVersion_; }
      set {
        waypointsVersion_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as GetVehicleRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(GetVehicleRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (Name != other.Name) return false;
      if (!object.Equals(CurrentRouteSegmentVersion, other.CurrentRouteSegmentVersion)) return false;
      if (!object.Equals(WaypointsVersion, other.WaypointsVersion)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (currentRouteSegmentVersion_ != null) hash ^= CurrentRouteSegmentVersion.GetHashCode();
      if (waypointsVersion_ != null) hash ^= WaypointsVersion.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (currentRouteSegmentVersion_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(CurrentRouteSegmentVersion);
      }
      if (waypointsVersion_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(WaypointsVersion);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (currentRouteSegmentVersion_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(CurrentRouteSegmentVersion);
      }
      if (waypointsVersion_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(WaypointsVersion);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (currentRouteSegmentVersion_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CurrentRouteSegmentVersion);
      }
      if (waypointsVersion_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WaypointsVersion);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(GetVehicleRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Google.Maps.FleetEngine.V1.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.currentRouteSegmentVersion_ != null) {
        if (currentRouteSegmentVersion_ == null) {
          CurrentRouteSegmentVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        CurrentRouteSegmentVersion.MergeFrom(other.CurrentRouteSegmentVersion);
      }
      if (other.waypointsVersion_ != null) {
        if (waypointsVersion_ == null) {
          WaypointsVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        WaypointsVersion.MergeFrom(other.WaypointsVersion);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Google.Maps.FleetEngine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            if (currentRouteSegmentVersion_ == null) {
              CurrentRouteSegmentVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CurrentRouteSegmentVersion);
            break;
          }
          case 42: {
            if (waypointsVersion_ == null) {
              WaypointsVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(WaypointsVersion);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Google.Maps.FleetEngine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            if (currentRouteSegmentVersion_ == null) {
              CurrentRouteSegmentVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(CurrentRouteSegmentVersion);
            break;
          }
          case 42: {
            if (waypointsVersion_ == null) {
              WaypointsVersion = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(WaypointsVersion);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// `UpdateVehicle request message.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class UpdateVehicleRequest : pb::IMessage<UpdateVehicleRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<UpdateVehicleRequest> _parser = new pb::MessageParser<UpdateVehicleRequest>(() => new UpdateVehicleRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<UpdateVehicleRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.FleetEngine.V1.VehicleApiReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpdateVehicleRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpdateVehicleRequest(UpdateVehicleRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      name_ = other.name_;
      vehicle_ = other.vehicle_ != null ? other.vehicle_.Clone() : null;
      updateMask_ = other.updateMask_ != null ? other.updateMask_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpdateVehicleRequest Clone() {
      return new UpdateVehicleRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Google.Maps.FleetEngine.V1.RequestHeader header_;
    /// <summary>
    /// The standard Fleet Engine request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 3;
    private string name_ = "";
    /// <summary>
    /// Required. Must be in the format
    /// `providers/{provider}/vehicles/{vehicle}`.
    /// The {provider} must be the Project ID (for example, `sample-cloud-project`)
    /// of the Google Cloud Project of which the service account making
    /// this call is a member.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "vehicle" field.</summary>
    public const int VehicleFieldNumber = 4;
    private global::Google.Maps.FleetEngine.V1.Vehicle vehicle_;
    /// <summary>
    /// Required. The `Vehicle` entity values to apply.  When updating a `Vehicle`,
    /// the following fields may not be updated as they are managed by the
    /// server.
    ///
    /// * `available_capacity`
    /// * `current_route_segment_version`
    /// * `current_trips`
    /// * `name`
    /// * `waypoints_version`
    ///
    /// If the `attributes` field is updated, **all** the vehicle's attributes are
    /// replaced with the attributes provided in the request. If you want to update
    /// only some attributes, see the `UpdateVehicleAttributes` method.
    ///
    /// Likewise, the `waypoints` field can be updated, but must contain all the
    /// waypoints currently on the vehicle, and no other waypoints.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.Vehicle Vehicle {
      get { return vehicle_; }
      set {
        vehicle_ = value;
      }
    }

    /// <summary>Field number for the "update_mask" field.</summary>
    public const int UpdateMaskFieldNumber = 5;
    private global::Google.Protobuf.WellKnownTypes.FieldMask updateMask_;
    /// <summary>
    /// Required. A field mask indicating which fields of the `Vehicle` to update.
    /// At least one field name must be provided.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.FieldMask UpdateMask {
      get { return updateMask_; }
      set {
        updateMask_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as UpdateVehicleRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(UpdateVehicleRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (Name != other.Name) return false;
      if (!object.Equals(Vehicle, other.Vehicle)) return false;
      if (!object.Equals(UpdateMask, other.UpdateMask)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (vehicle_ != null) hash ^= Vehicle.GetHashCode();
      if (updateMask_ != null) hash ^= UpdateMask.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (vehicle_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Vehicle);
      }
      if (updateMask_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(UpdateMask);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (vehicle_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Vehicle);
      }
      if (updateMask_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(UpdateMask);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (vehicle_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Vehicle);
      }
      if (updateMask_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(UpdateMask);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(UpdateVehicleRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Google.Maps.FleetEngine.V1.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.vehicle_ != null) {
        if (vehicle_ == null) {
          Vehicle = new global::Google.Maps.FleetEngine.V1.Vehicle();
        }
        Vehicle.MergeFrom(other.Vehicle);
      }
      if (other.updateMask_ != null) {
        if (updateMask_ == null) {
          UpdateMask = new global::Google.Protobuf.WellKnownTypes.FieldMask();
        }
        UpdateMask.MergeFrom(other.UpdateMask);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Google.Maps.FleetEngine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            if (vehicle_ == null) {
              Vehicle = new global::Google.Maps.FleetEngine.V1.Vehicle();
            }
            input.ReadMessage(Vehicle);
            break;
          }
          case 42: {
            if (updateMask_ == null) {
              UpdateMask = new global::Google.Protobuf.WellKnownTypes.FieldMask();
            }
            input.ReadMessage(UpdateMask);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Google.Maps.FleetEngine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            if (vehicle_ == null) {
              Vehicle = new global::Google.Maps.FleetEngine.V1.Vehicle();
            }
            input.ReadMessage(Vehicle);
            break;
          }
          case 42: {
            if (updateMask_ == null) {
              UpdateMask = new global::Google.Protobuf.WellKnownTypes.FieldMask();
            }
            input.ReadMessage(UpdateMask);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// `UpdateVehicleAttributes` request message.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class UpdateVehicleAttributesRequest : pb::IMessage<UpdateVehicleAttributesRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<UpdateVehicleAttributesRequest> _parser = new pb::MessageParser<UpdateVehicleAttributesRequest>(() => new UpdateVehicleAttributesRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<UpdateVehicleAttributesRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.FleetEngine.V1.VehicleApiReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpdateVehicleAttributesRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpdateVehicleAttributesRequest(UpdateVehicleAttributesRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      name_ = other.name_;
      attributes_ = other.attributes_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpdateVehicleAttributesRequest Clone() {
      return new UpdateVehicleAttributesRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Google.Maps.FleetEngine.V1.RequestHeader header_;
    /// <summary>
    /// The standard Fleet Engine request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 3;
    private string name_ = "";
    /// <summary>
    /// Required. Must be in the format `providers/{provider}/vehicles/{vehicle}`.
    /// The provider must be the Project ID (for example, `sample-cloud-project`)
    /// of the Google Cloud Project of which the service account making
    /// this call is a member.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "attributes" field.</summary>
    public const int AttributesFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Google.Maps.FleetEngine.V1.VehicleAttribute> _repeated_attributes_codec
        = pb::FieldCodec.ForMessage(34, global::Google.Maps.FleetEngine.V1.VehicleAttribute.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleAttribute> attributes_ = new pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleAttribute>();
    /// <summary>
    /// Required. The vehicle attributes to update. Unmentioned attributes are not
    /// altered or removed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleAttribute> Attributes {
      get { return attributes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as UpdateVehicleAttributesRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(UpdateVehicleAttributesRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (Name != other.Name) return false;
      if(!attributes_.Equals(other.attributes_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      hash ^= attributes_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      attributes_.WriteTo(output, _repeated_attributes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      attributes_.WriteTo(ref output, _repeated_attributes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      size += attributes_.CalculateSize(_repeated_attributes_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(UpdateVehicleAttributesRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Google.Maps.FleetEngine.V1.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      attributes_.Add(other.attributes_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Google.Maps.FleetEngine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            attributes_.AddEntriesFrom(input, _repeated_attributes_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Google.Maps.FleetEngine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            attributes_.AddEntriesFrom(ref input, _repeated_attributes_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// `UpdateVehicleAttributes` response message.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class UpdateVehicleAttributesResponse : pb::IMessage<UpdateVehicleAttributesResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<UpdateVehicleAttributesResponse> _parser = new pb::MessageParser<UpdateVehicleAttributesResponse>(() => new UpdateVehicleAttributesResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<UpdateVehicleAttributesResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.FleetEngine.V1.VehicleApiReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpdateVehicleAttributesResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpdateVehicleAttributesResponse(UpdateVehicleAttributesResponse other) : this() {
      attributes_ = other.attributes_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public UpdateVehicleAttributesResponse Clone() {
      return new UpdateVehicleAttributesResponse(this);
    }

    /// <summary>Field number for the "attributes" field.</summary>
    public const int AttributesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Maps.FleetEngine.V1.VehicleAttribute> _repeated_attributes_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Maps.FleetEngine.V1.VehicleAttribute.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleAttribute> attributes_ = new pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleAttribute>();
    /// <summary>
    /// Required. The updated full list of vehicle attributes, including new,
    /// altered, and untouched attributes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleAttribute> Attributes {
      get { return attributes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as UpdateVehicleAttributesResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(UpdateVehicleAttributesResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!attributes_.Equals(other.attributes_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= attributes_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      attributes_.WriteTo(output, _repeated_attributes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      attributes_.WriteTo(ref output, _repeated_attributes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += attributes_.CalculateSize(_repeated_attributes_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(UpdateVehicleAttributesResponse other) {
      if (other == null) {
        return;
      }
      attributes_.Add(other.attributes_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            attributes_.AddEntriesFrom(input, _repeated_attributes_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            attributes_.AddEntriesFrom(ref input, _repeated_attributes_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// `SearchVehicles` request message.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SearchVehiclesRequest : pb::IMessage<SearchVehiclesRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SearchVehiclesRequest> _parser = new pb::MessageParser<SearchVehiclesRequest>(() => new SearchVehiclesRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SearchVehiclesRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.FleetEngine.V1.VehicleApiReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchVehiclesRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchVehiclesRequest(SearchVehiclesRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      parent_ = other.parent_;
      pickupPoint_ = other.pickupPoint_ != null ? other.pickupPoint_.Clone() : null;
      dropoffPoint_ = other.dropoffPoint_ != null ? other.dropoffPoint_.Clone() : null;
      pickupRadiusMeters_ = other.pickupRadiusMeters_;
      count_ = other.count_;
      minimumCapacity_ = other.minimumCapacity_;
      tripTypes_ = other.tripTypes_.Clone();
      maximumStaleness_ = other.maximumStaleness_ != null ? other.maximumStaleness_.Clone() : null;
      vehicleTypes_ = other.vehicleTypes_.Clone();
      requiredAttributes_ = other.requiredAttributes_.Clone();
      requiredOneOfAttributes_ = other.requiredOneOfAttributes_.Clone();
      requiredOneOfAttributeSets_ = other.requiredOneOfAttributeSets_.Clone();
      orderBy_ = other.orderBy_;
      includeBackToBack_ = other.includeBackToBack_;
      tripId_ = other.tripId_;
      currentTripsPresent_ = other.currentTripsPresent_;
      filter_ = other.filter_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchVehiclesRequest Clone() {
      return new SearchVehiclesRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 1;
    private global::Google.Maps.FleetEngine.V1.RequestHeader header_;
    /// <summary>
    /// The standard Fleet Engine request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "parent" field.</summary>
    public const int ParentFieldNumber = 3;
    private string parent_ = "";
    /// <summary>
    /// Required. Must be in the format `providers/{provider}`.
    /// The provider must be the Project ID (for example, `sample-cloud-project`)
    /// of the Google Cloud Project of which the service account making
    /// this call is a member.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Parent {
      get { return parent_; }
      set {
        parent_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "pickup_point" field.</summary>
    public const int PickupPointFieldNumber = 4;
    private global::Google.Maps.FleetEngine.V1.TerminalLocation pickupPoint_;
    /// <summary>
    /// Required. The pickup point to search near.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.TerminalLocation PickupPoint {
      get { return pickupPoint_; }
      set {
        pickupPoint_ = value;
      }
    }

    /// <summary>Field number for the "dropoff_point" field.</summary>
    public const int DropoffPointFieldNumber = 5;
    private global::Google.Maps.FleetEngine.V1.TerminalLocation dropoffPoint_;
    /// <summary>
    /// The customer's intended dropoff location. The field is required if
    /// `trip_types` contains `TripType.SHARED`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.TerminalLocation DropoffPoint {
      get { return dropoffPoint_; }
      set {
        dropoffPoint_ = value;
      }
    }

    /// <summary>Field number for the "pickup_radius_meters" field.</summary>
    public const int PickupRadiusMetersFieldNumber = 6;
    private int pickupRadiusMeters_;
    /// <summary>
    /// Required. Defines the vehicle search radius around the pickup point. Only
    /// vehicles within the search radius will be returned. Value must be between
    /// 400 and 10000 meters (inclusive).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int PickupRadiusMeters {
      get { return pickupRadiusMeters_; }
      set {
        pickupRadiusMeters_ = value;
      }
    }

    /// <summary>Field number for the "count" field.</summary>
    public const int CountFieldNumber = 7;
    private int count_;
    /// <summary>
    /// Required. Specifies the maximum number of vehicles to return. The value
    /// must be between 1 and 50 (inclusive).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Count {
      get { return count_; }
      set {
        count_ = value;
      }
    }

    /// <summary>Field number for the "minimum_capacity" field.</summary>
    public const int MinimumCapacityFieldNumber = 8;
    private int minimumCapacity_;
    /// <summary>
    /// Required. Specifies the number of passengers being considered for a trip.
    /// The value must be greater than or equal to one. The driver is not
    /// considered in the capacity value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MinimumCapacity {
      get { return minimumCapacity_; }
      set {
        minimumCapacity_ = value;
      }
    }

    /// <summary>Field number for the "trip_types" field.</summary>
    public const int TripTypesFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Google.Maps.FleetEngine.V1.TripType> _repeated_tripTypes_codec
        = pb::FieldCodec.ForEnum(74, x => (int) x, x => (global::Google.Maps.FleetEngine.V1.TripType) x);
    private readonly pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.TripType> tripTypes_ = new pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.TripType>();
    /// <summary>
    /// Required. Represents the type of proposed trip. Must include exactly one
    /// type. `UNKNOWN_TRIP_TYPE` is not allowed. Restricts the search to only
    /// those vehicles that can support that trip type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.TripType> TripTypes {
      get { return tripTypes_; }
    }

    /// <summary>Field number for the "maximum_staleness" field.</summary>
    public const int MaximumStalenessFieldNumber = 10;
    private global::Google.Protobuf.WellKnownTypes.Duration maximumStaleness_;
    /// <summary>
    /// Restricts the search to only those vehicles that have sent location updates
    /// to Fleet Engine within the specified duration. Stationary vehicles still
    /// transmitting their locations are not considered stale. If this field is not
    /// set, the server uses five minutes as the default value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration MaximumStaleness {
      get { return maximumStaleness_; }
      set {
        maximumStaleness_ = value;
      }
    }

    /// <summary>Field number for the "vehicle_types" field.</summary>
    public const int VehicleTypesFieldNumber = 14;
    private static readonly pb::FieldCodec<global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType> _repeated_vehicleTypes_codec
        = pb::FieldCodec.ForMessage(114, global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType> vehicleTypes_ = new pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType>();
    /// <summary>
    /// Required. Restricts the search to vehicles with one of the specified types.
    /// At least one vehicle type must be specified. VehicleTypes with a category
    /// of `UNKNOWN` are not allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType> VehicleTypes {
      get { return vehicleTypes_; }
    }

    /// <summary>Field number for the "required_attributes" field.</summary>
    public const int RequiredAttributesFieldNumber = 12;
    private static readonly pb::FieldCodec<global::Google.Maps.FleetEngine.V1.VehicleAttribute> _repeated_requiredAttributes_codec
        = pb::FieldCodec.ForMessage(98, global::Google.Maps.FleetEngine.V1.VehicleAttribute.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleAttribute> requiredAttributes_ = new pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleAttribute>();
    /// <summary>
    /// Callers can form complex logical operations using any combination of the
    /// `required_attributes`, `required_one_of_attributes`, and
    /// `required_one_of_attribute_sets` fields.
    ///
    /// `required_attributes` is a list; `required_one_of_attributes` uses a
    /// message which allows a list of lists. In combination, the two fields allow
    /// the composition of this expression:
    ///
    /// ```
    /// (required_attributes[0] AND required_attributes[1] AND ...)
    /// AND
    /// (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
    /// ...)
    /// AND
    /// (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
    /// ...)
    /// ```
    ///
    /// Restricts the search to only those vehicles with the specified attributes.
    /// This field is a conjunction/AND operation. A max of 50 required_attributes
    /// is allowed. This matches the maximum number of attributes allowed on a
    /// vehicle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleAttribute> RequiredAttributes {
      get { return requiredAttributes_; }
    }

    /// <summary>Field number for the "required_one_of_attributes" field.</summary>
    public const int RequiredOneOfAttributesFieldNumber = 15;
    private static readonly pb::FieldCodec<global::Google.Maps.FleetEngine.V1.VehicleAttributeList> _repeated_requiredOneOfAttributes_codec
        = pb::FieldCodec.ForMessage(122, global::Google.Maps.FleetEngine.V1.VehicleAttributeList.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleAttributeList> requiredOneOfAttributes_ = new pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleAttributeList>();
    /// <summary>
    /// Restricts the search to only those vehicles with at least one of
    /// the specified attributes in each `VehicleAttributeList`. Within each
    /// list, a vehicle must match at least one of the attributes. This field is an
    /// inclusive disjunction/OR operation in each `VehicleAttributeList` and a
    /// conjunction/AND operation across the collection of `VehicleAttributeList`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleAttributeList> RequiredOneOfAttributes {
      get { return requiredOneOfAttributes_; }
    }

    /// <summary>Field number for the "required_one_of_attribute_sets" field.</summary>
    public const int RequiredOneOfAttributeSetsFieldNumber = 20;
    private static readonly pb::FieldCodec<global::Google.Maps.FleetEngine.V1.VehicleAttributeList> _repeated_requiredOneOfAttributeSets_codec
        = pb::FieldCodec.ForMessage(162, global::Google.Maps.FleetEngine.V1.VehicleAttributeList.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleAttributeList> requiredOneOfAttributeSets_ = new pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleAttributeList>();
    /// <summary>
    /// `required_one_of_attribute_sets` provides additional functionality.
    ///
    /// Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
    /// uses a message which allows a list of lists, allowing expressions such as
    /// this one:
    ///
    /// ```
    /// (required_attributes[0] AND required_attributes[1] AND ...)
    /// AND
    /// (
    ///   (required_one_of_attribute_sets[0][0] AND
    ///   required_one_of_attribute_sets[0][1] AND
    ///   ...)
    ///   OR
    ///   (required_one_of_attribute_sets[1][0] AND
    ///   required_one_of_attribute_sets[1][1] AND
    ///   ...)
    /// )
    /// ```
    ///
    /// Restricts the search to only those vehicles with all the attributes in a
    /// `VehicleAttributeList`. Within each list, a
    /// vehicle must match all of the attributes. This field is a conjunction/AND
    /// operation in each `VehicleAttributeList` and inclusive disjunction/OR
    /// operation across the collection of `VehicleAttributeList`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleAttributeList> RequiredOneOfAttributeSets {
      get { return requiredOneOfAttributeSets_; }
    }

    /// <summary>Field number for the "order_by" field.</summary>
    public const int OrderByFieldNumber = 13;
    private global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder orderBy_ = global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder;
    /// <summary>
    /// Required. Specifies the desired ordering criterion for results.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder OrderBy {
      get { return orderBy_; }
      set {
        orderBy_ = value;
      }
    }

    /// <summary>Field number for the "include_back_to_back" field.</summary>
    public const int IncludeBackToBackFieldNumber = 18;
    private bool includeBackToBack_;
    /// <summary>
    /// This indicates if vehicles with a single active trip are eligible for this
    /// search. This field is only used when `current_trips_present` is
    /// unspecified. When `current_trips_present` is unspecified  and  this field
    /// is `false`, vehicles with assigned trips are excluded from the search
    /// results. When `current_trips_present` is unspecified and this field is
    /// `true`, search results can include vehicles with one active trip that has a
    /// status of `ENROUTE_TO_DROPOFF`. When `current_trips_present` is specified,
    /// this field cannot be set to true.
    ///
    /// The default value is `false`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IncludeBackToBack {
      get { return includeBackToBack_; }
      set {
        includeBackToBack_ = value;
      }
    }

    /// <summary>Field number for the "trip_id" field.</summary>
    public const int TripIdFieldNumber = 19;
    private string tripId_ = "";
    /// <summary>
    /// Indicates the trip associated with this `SearchVehicleRequest`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string TripId {
      get { return tripId_; }
      set {
        tripId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "current_trips_present" field.</summary>
    public const int CurrentTripsPresentFieldNumber = 21;
    private global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.CurrentTripsPresent currentTripsPresent_ = global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.CurrentTripsPresent.Unspecified;
    /// <summary>
    /// This indicates if vehicles with active trips are eligible for this search.
    /// This must be set to something other than
    /// `CURRENT_TRIPS_PRESENT_UNSPECIFIED` if `trip_type` includes `SHARED`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.CurrentTripsPresent CurrentTripsPresent {
      get { return currentTripsPresent_; }
      set {
        currentTripsPresent_ = value;
      }
    }

    /// <summary>Field number for the "filter" field.</summary>
    public const int FilterFieldNumber = 22;
    private string filter_ = "";
    /// <summary>
    /// Optional. A filter query to apply when searching vehicles. See
    /// http://aip.dev/160 for examples of the filter syntax.
    ///
    /// This field is designed to replace the `required_attributes`,
    /// `required_one_of_attributes`, and `required_one_of_attributes_sets` fields.
    /// If a non-empty value is specified here, the following fields must be empty:
    /// `required_attributes`, `required_one_of_attributes`, and
    /// `required_one_of_attributes_sets`.
    ///
    /// This filter functions as an AND clause with other constraints,
    /// such as `minimum_capacity` or `vehicle_types`.
    ///
    /// Note that the only queries supported are on vehicle attributes (for
    /// example, `attributes.&lt;key> = &lt;value>` or `attributes.&lt;key1> = &lt;value1> AND
    /// attributes.&lt;key2> = &lt;value2>`). The maximum number of restrictions allowed
    /// in a filter query is 50.
    ///
    /// Also, all attributes are stored as strings, so the only supported
    /// comparisons against attributes are string comparisons. In order to compare
    /// against number or boolean values, the values must be explicitly quoted to
    /// be treated as strings (for example, `attributes.&lt;key> = "10"` or
    /// `attributes.&lt;key> = "true"`).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Filter {
      get { return filter_; }
      set {
        filter_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SearchVehiclesRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SearchVehiclesRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (Parent != other.Parent) return false;
      if (!object.Equals(PickupPoint, other.PickupPoint)) return false;
      if (!object.Equals(DropoffPoint, other.DropoffPoint)) return false;
      if (PickupRadiusMeters != other.PickupRadiusMeters) return false;
      if (Count != other.Count) return false;
      if (MinimumCapacity != other.MinimumCapacity) return false;
      if(!tripTypes_.Equals(other.tripTypes_)) return false;
      if (!object.Equals(MaximumStaleness, other.MaximumStaleness)) return false;
      if(!vehicleTypes_.Equals(other.vehicleTypes_)) return false;
      if(!requiredAttributes_.Equals(other.requiredAttributes_)) return false;
      if(!requiredOneOfAttributes_.Equals(other.requiredOneOfAttributes_)) return false;
      if(!requiredOneOfAttributeSets_.Equals(other.requiredOneOfAttributeSets_)) return false;
      if (OrderBy != other.OrderBy) return false;
      if (IncludeBackToBack != other.IncludeBackToBack) return false;
      if (TripId != other.TripId) return false;
      if (CurrentTripsPresent != other.CurrentTripsPresent) return false;
      if (Filter != other.Filter) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (Parent.Length != 0) hash ^= Parent.GetHashCode();
      if (pickupPoint_ != null) hash ^= PickupPoint.GetHashCode();
      if (dropoffPoint_ != null) hash ^= DropoffPoint.GetHashCode();
      if (PickupRadiusMeters != 0) hash ^= PickupRadiusMeters.GetHashCode();
      if (Count != 0) hash ^= Count.GetHashCode();
      if (MinimumCapacity != 0) hash ^= MinimumCapacity.GetHashCode();
      hash ^= tripTypes_.GetHashCode();
      if (maximumStaleness_ != null) hash ^= MaximumStaleness.GetHashCode();
      hash ^= vehicleTypes_.GetHashCode();
      hash ^= requiredAttributes_.GetHashCode();
      hash ^= requiredOneOfAttributes_.GetHashCode();
      hash ^= requiredOneOfAttributeSets_.GetHashCode();
      if (OrderBy != global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) hash ^= OrderBy.GetHashCode();
      if (IncludeBackToBack != false) hash ^= IncludeBackToBack.GetHashCode();
      if (TripId.Length != 0) hash ^= TripId.GetHashCode();
      if (CurrentTripsPresent != global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.CurrentTripsPresent.Unspecified) hash ^= CurrentTripsPresent.GetHashCode();
      if (Filter.Length != 0) hash ^= Filter.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Parent.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Parent);
      }
      if (pickupPoint_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(PickupPoint);
      }
      if (dropoffPoint_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(DropoffPoint);
      }
      if (PickupRadiusMeters != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(PickupRadiusMeters);
      }
      if (Count != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(Count);
      }
      if (MinimumCapacity != 0) {
        output.WriteRawTag(64);
        output.WriteInt32(MinimumCapacity);
      }
      tripTypes_.WriteTo(output, _repeated_tripTypes_codec);
      if (maximumStaleness_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(MaximumStaleness);
      }
      requiredAttributes_.WriteTo(output, _repeated_requiredAttributes_codec);
      if (OrderBy != global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        output.WriteRawTag(104);
        output.WriteEnum((int) OrderBy);
      }
      vehicleTypes_.WriteTo(output, _repeated_vehicleTypes_codec);
      requiredOneOfAttributes_.WriteTo(output, _repeated_requiredOneOfAttributes_codec);
      if (IncludeBackToBack != false) {
        output.WriteRawTag(144, 1);
        output.WriteBool(IncludeBackToBack);
      }
      if (TripId.Length != 0) {
        output.WriteRawTag(154, 1);
        output.WriteString(TripId);
      }
      requiredOneOfAttributeSets_.WriteTo(output, _repeated_requiredOneOfAttributeSets_codec);
      if (CurrentTripsPresent != global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.CurrentTripsPresent.Unspecified) {
        output.WriteRawTag(168, 1);
        output.WriteEnum((int) CurrentTripsPresent);
      }
      if (Filter.Length != 0) {
        output.WriteRawTag(178, 1);
        output.WriteString(Filter);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (header_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Header);
      }
      if (Parent.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Parent);
      }
      if (pickupPoint_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(PickupPoint);
      }
      if (dropoffPoint_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(DropoffPoint);
      }
      if (PickupRadiusMeters != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(PickupRadiusMeters);
      }
      if (Count != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(Count);
      }
      if (MinimumCapacity != 0) {
        output.WriteRawTag(64);
        output.WriteInt32(MinimumCapacity);
      }
      tripTypes_.WriteTo(ref output, _repeated_tripTypes_codec);
      if (maximumStaleness_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(MaximumStaleness);
      }
      requiredAttributes_.WriteTo(ref output, _repeated_requiredAttributes_codec);
      if (OrderBy != global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        output.WriteRawTag(104);
        output.WriteEnum((int) OrderBy);
      }
      vehicleTypes_.WriteTo(ref output, _repeated_vehicleTypes_codec);
      requiredOneOfAttributes_.WriteTo(ref output, _repeated_requiredOneOfAttributes_codec);
      if (IncludeBackToBack != false) {
        output.WriteRawTag(144, 1);
        output.WriteBool(IncludeBackToBack);
      }
      if (TripId.Length != 0) {
        output.WriteRawTag(154, 1);
        output.WriteString(TripId);
      }
      requiredOneOfAttributeSets_.WriteTo(ref output, _repeated_requiredOneOfAttributeSets_codec);
      if (CurrentTripsPresent != global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.CurrentTripsPresent.Unspecified) {
        output.WriteRawTag(168, 1);
        output.WriteEnum((int) CurrentTripsPresent);
      }
      if (Filter.Length != 0) {
        output.WriteRawTag(178, 1);
        output.WriteString(Filter);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (Parent.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Parent);
      }
      if (pickupPoint_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PickupPoint);
      }
      if (dropoffPoint_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DropoffPoint);
      }
      if (PickupRadiusMeters != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(PickupRadiusMeters);
      }
      if (Count != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Count);
      }
      if (MinimumCapacity != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MinimumCapacity);
      }
      size += tripTypes_.CalculateSize(_repeated_tripTypes_codec);
      if (maximumStaleness_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaximumStaleness);
      }
      size += vehicleTypes_.CalculateSize(_repeated_vehicleTypes_codec);
      size += requiredAttributes_.CalculateSize(_repeated_requiredAttributes_codec);
      size += requiredOneOfAttributes_.CalculateSize(_repeated_requiredOneOfAttributes_codec);
      size += requiredOneOfAttributeSets_.CalculateSize(_repeated_requiredOneOfAttributeSets_codec);
      if (OrderBy != global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) OrderBy);
      }
      if (IncludeBackToBack != false) {
        size += 2 + 1;
      }
      if (TripId.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(TripId);
      }
      if (CurrentTripsPresent != global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.CurrentTripsPresent.Unspecified) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) CurrentTripsPresent);
      }
      if (Filter.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Filter);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SearchVehiclesRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Google.Maps.FleetEngine.V1.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.Parent.Length != 0) {
        Parent = other.Parent;
      }
      if (other.pickupPoint_ != null) {
        if (pickupPoint_ == null) {
          PickupPoint = new global::Google.Maps.FleetEngine.V1.TerminalLocation();
        }
        PickupPoint.MergeFrom(other.PickupPoint);
      }
      if (other.dropoffPoint_ != null) {
        if (dropoffPoint_ == null) {
          DropoffPoint = new global::Google.Maps.FleetEngine.V1.TerminalLocation();
        }
        DropoffPoint.MergeFrom(other.DropoffPoint);
      }
      if (other.PickupRadiusMeters != 0) {
        PickupRadiusMeters = other.PickupRadiusMeters;
      }
      if (other.Count != 0) {
        Count = other.Count;
      }
      if (other.MinimumCapacity != 0) {
        MinimumCapacity = other.MinimumCapacity;
      }
      tripTypes_.Add(other.tripTypes_);
      if (other.maximumStaleness_ != null) {
        if (maximumStaleness_ == null) {
          MaximumStaleness = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        MaximumStaleness.MergeFrom(other.MaximumStaleness);
      }
      vehicleTypes_.Add(other.vehicleTypes_);
      requiredAttributes_.Add(other.requiredAttributes_);
      requiredOneOfAttributes_.Add(other.requiredOneOfAttributes_);
      requiredOneOfAttributeSets_.Add(other.requiredOneOfAttributeSets_);
      if (other.OrderBy != global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        OrderBy = other.OrderBy;
      }
      if (other.IncludeBackToBack != false) {
        IncludeBackToBack = other.IncludeBackToBack;
      }
      if (other.TripId.Length != 0) {
        TripId = other.TripId;
      }
      if (other.CurrentTripsPresent != global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.CurrentTripsPresent.Unspecified) {
        CurrentTripsPresent = other.CurrentTripsPresent;
      }
      if (other.Filter.Length != 0) {
        Filter = other.Filter;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Google.Maps.FleetEngine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Parent = input.ReadString();
            break;
          }
          case 34: {
            if (pickupPoint_ == null) {
              PickupPoint = new global::Google.Maps.FleetEngine.V1.TerminalLocation();
            }
            input.ReadMessage(PickupPoint);
            break;
          }
          case 42: {
            if (dropoffPoint_ == null) {
              DropoffPoint = new global::Google.Maps.FleetEngine.V1.TerminalLocation();
            }
            input.ReadMessage(DropoffPoint);
            break;
          }
          case 48: {
            PickupRadiusMeters = input.ReadInt32();
            break;
          }
          case 56: {
            Count = input.ReadInt32();
            break;
          }
          case 64: {
            MinimumCapacity = input.ReadInt32();
            break;
          }
          case 74:
          case 72: {
            tripTypes_.AddEntriesFrom(input, _repeated_tripTypes_codec);
            break;
          }
          case 82: {
            if (maximumStaleness_ == null) {
              MaximumStaleness = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(MaximumStaleness);
            break;
          }
          case 98: {
            requiredAttributes_.AddEntriesFrom(input, _repeated_requiredAttributes_codec);
            break;
          }
          case 104: {
            OrderBy = (global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder) input.ReadEnum();
            break;
          }
          case 114: {
            vehicleTypes_.AddEntriesFrom(input, _repeated_vehicleTypes_codec);
            break;
          }
          case 122: {
            requiredOneOfAttributes_.AddEntriesFrom(input, _repeated_requiredOneOfAttributes_codec);
            break;
          }
          case 144: {
            IncludeBackToBack = input.ReadBool();
            break;
          }
          case 154: {
            TripId = input.ReadString();
            break;
          }
          case 162: {
            requiredOneOfAttributeSets_.AddEntriesFrom(input, _repeated_requiredOneOfAttributeSets_codec);
            break;
          }
          case 168: {
            CurrentTripsPresent = (global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.CurrentTripsPresent) input.ReadEnum();
            break;
          }
          case 178: {
            Filter = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (header_ == null) {
              Header = new global::Google.Maps.FleetEngine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 26: {
            Parent = input.ReadString();
            break;
          }
          case 34: {
            if (pickupPoint_ == null) {
              PickupPoint = new global::Google.Maps.FleetEngine.V1.TerminalLocation();
            }
            input.ReadMessage(PickupPoint);
            break;
          }
          case 42: {
            if (dropoffPoint_ == null) {
              DropoffPoint = new global::Google.Maps.FleetEngine.V1.TerminalLocation();
            }
            input.ReadMessage(DropoffPoint);
            break;
          }
          case 48: {
            PickupRadiusMeters = input.ReadInt32();
            break;
          }
          case 56: {
            Count = input.ReadInt32();
            break;
          }
          case 64: {
            MinimumCapacity = input.ReadInt32();
            break;
          }
          case 74:
          case 72: {
            tripTypes_.AddEntriesFrom(ref input, _repeated_tripTypes_codec);
            break;
          }
          case 82: {
            if (maximumStaleness_ == null) {
              MaximumStaleness = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(MaximumStaleness);
            break;
          }
          case 98: {
            requiredAttributes_.AddEntriesFrom(ref input, _repeated_requiredAttributes_codec);
            break;
          }
          case 104: {
            OrderBy = (global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder) input.ReadEnum();
            break;
          }
          case 114: {
            vehicleTypes_.AddEntriesFrom(ref input, _repeated_vehicleTypes_codec);
            break;
          }
          case 122: {
            requiredOneOfAttributes_.AddEntriesFrom(ref input, _repeated_requiredOneOfAttributes_codec);
            break;
          }
          case 144: {
            IncludeBackToBack = input.ReadBool();
            break;
          }
          case 154: {
            TripId = input.ReadString();
            break;
          }
          case 162: {
            requiredOneOfAttributeSets_.AddEntriesFrom(ref input, _repeated_requiredOneOfAttributeSets_codec);
            break;
          }
          case 168: {
            CurrentTripsPresent = (global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.CurrentTripsPresent) input.ReadEnum();
            break;
          }
          case 178: {
            Filter = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the SearchVehiclesRequest message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Specifies the order of the vehicle matches in the response.
      /// </summary>
      public enum VehicleMatchOrder {
        /// <summary>
        /// Default, used for unspecified or unrecognized vehicle matches order.
        /// </summary>
        [pbr::OriginalName("UNKNOWN_VEHICLE_MATCH_ORDER")] UnknownVehicleMatchOrder = 0,
        /// <summary>
        /// Ascending order by vehicle driving time to the pickup point.
        /// </summary>
        [pbr::OriginalName("PICKUP_POINT_ETA")] PickupPointEta = 1,
        /// <summary>
        /// Ascending order by vehicle driving distance to the pickup point.
        /// </summary>
        [pbr::OriginalName("PICKUP_POINT_DISTANCE")] PickupPointDistance = 2,
        /// <summary>
        /// Ascending order by vehicle driving time to the dropoff point. This order
        /// can only be used if the dropoff point is specified in the request.
        /// </summary>
        [pbr::OriginalName("DROPOFF_POINT_ETA")] DropoffPointEta = 3,
        /// <summary>
        /// Ascending order by straight-line distance from the vehicle's last
        /// reported location to the pickup point.
        /// </summary>
        [pbr::OriginalName("PICKUP_POINT_STRAIGHT_DISTANCE")] PickupPointStraightDistance = 4,
        /// <summary>
        /// Ascending order by the configured match cost. Match cost is defined as a
        /// weighted calculation between straight-line distance and ETA. Weights are
        /// set with default values and can be modified per customer. Please contact
        /// Google support if these weights need to be modified for your project.
        /// </summary>
        [pbr::OriginalName("COST")] Cost = 5,
      }

      /// <summary>
      /// Specifies the types of restrictions on a vehicle's current trips.
      /// </summary>
      public enum CurrentTripsPresent {
        /// <summary>
        /// The availability of vehicles with trips present is governed by the
        /// `include_back_to_back` field.
        /// </summary>
        [pbr::OriginalName("CURRENT_TRIPS_PRESENT_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Vehicles without trips can appear in search results. When this value is
        /// used, `include_back_to_back` cannot be `true`.
        /// </summary>
        [pbr::OriginalName("NONE")] None = 1,
        /// <summary>
        /// Vehicles with at most 5 current trips and 10 waypoints are included
        /// in the search results. When this value is used, `include_back_to_back`
        /// cannot be `true`.
        /// </summary>
        [pbr::OriginalName("ANY")] Any = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// `SearchVehicles` response message.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SearchVehiclesResponse : pb::IMessage<SearchVehiclesResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SearchVehiclesResponse> _parser = new pb::MessageParser<SearchVehiclesResponse>(() => new SearchVehiclesResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SearchVehiclesResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.FleetEngine.V1.VehicleApiReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchVehiclesResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchVehiclesResponse(SearchVehiclesResponse other) : this() {
      matches_ = other.matches_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SearchVehiclesResponse Clone() {
      return new SearchVehiclesResponse(this);
    }

    /// <summary>Field number for the "matches" field.</summary>
    public const int MatchesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Maps.FleetEngine.V1.VehicleMatch> _repeated_matches_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Maps.FleetEngine.V1.VehicleMatch.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleMatch> matches_ = new pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleMatch>();
    /// <summary>
    /// List of vehicles that match the `SearchVehiclesRequest` criteria, ordered
    /// according to `SearchVehiclesRequest.order_by` field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleMatch> Matches {
      get { return matches_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SearchVehiclesResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SearchVehiclesResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!matches_.Equals(other.matches_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= matches_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      matches_.WriteTo(output, _repeated_matches_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      matches_.WriteTo(ref output, _repeated_matches_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += matches_.CalculateSize(_repeated_matches_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SearchVehiclesResponse other) {
      if (other == null) {
        return;
      }
      matches_.Add(other.matches_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            matches_.AddEntriesFrom(input, _repeated_matches_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            matches_.AddEntriesFrom(ref input, _repeated_matches_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// `ListVehicles` request message.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ListVehiclesRequest : pb::IMessage<ListVehiclesRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ListVehiclesRequest> _parser = new pb::MessageParser<ListVehiclesRequest>(() => new ListVehiclesRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ListVehiclesRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.FleetEngine.V1.VehicleApiReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ListVehiclesRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ListVehiclesRequest(ListVehiclesRequest other) : this() {
      header_ = other.header_ != null ? other.header_.Clone() : null;
      parent_ = other.parent_;
      pageSize_ = other.pageSize_;
      pageToken_ = other.pageToken_;
      MinimumCapacity = other.MinimumCapacity;
      tripTypes_ = other.tripTypes_.Clone();
      maximumStaleness_ = other.maximumStaleness_ != null ? other.maximumStaleness_.Clone() : null;
      vehicleTypeCategories_ = other.vehicleTypeCategories_.Clone();
      requiredAttributes_ = other.requiredAttributes_.Clone();
      requiredOneOfAttributes_ = other.requiredOneOfAttributes_.Clone();
      requiredOneOfAttributeSets_ = other.requiredOneOfAttributeSets_.Clone();
      vehicleState_ = other.vehicleState_;
      onTripOnly_ = other.onTripOnly_;
      filter_ = other.filter_;
      viewport_ = other.viewport_ != null ? other.viewport_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ListVehiclesRequest Clone() {
      return new ListVehiclesRequest(this);
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 12;
    private global::Google.Maps.FleetEngine.V1.RequestHeader header_;
    /// <summary>
    /// The standard Fleet Engine request header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.RequestHeader Header {
      get { return header_; }
      set {
        header_ = value;
      }
    }

    /// <summary>Field number for the "parent" field.</summary>
    public const int ParentFieldNumber = 1;
    private string parent_ = "";
    /// <summary>
    /// Required. Must be in the format `providers/{provider}`.
    /// The provider must be the Project ID (for example, `sample-cloud-project`)
    /// of the Google Cloud Project of which the service account making
    /// this call is a member.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Parent {
      get { return parent_; }
      set {
        parent_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "page_size" field.</summary>
    public const int PageSizeFieldNumber = 3;
    private int pageSize_;
    /// <summary>
    /// The maximum number of vehicles to return.
    /// Default value: 100.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int PageSize {
      get { return pageSize_; }
      set {
        pageSize_ = value;
      }
    }

    /// <summary>Field number for the "page_token" field.</summary>
    public const int PageTokenFieldNumber = 4;
    private string pageToken_ = "";
    /// <summary>
    /// The value of the `next_page_token` provided by a previous call to
    /// `ListVehicles` so that you can paginate through groups of vehicles. The
    /// value is undefined if the filter criteria of the request is not the same as
    /// the filter criteria for the previous call to `ListVehicles`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string PageToken {
      get { return pageToken_; }
      set {
        pageToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "minimum_capacity" field.</summary>
    public const int MinimumCapacityFieldNumber = 6;
    private static readonly pb::FieldCodec<int?> _single_minimumCapacity_codec = pb::FieldCodec.ForStructWrapper<int>(50);
    private int? minimumCapacity_;
    /// <summary>
    /// Specifies the required minimum capacity of the vehicle. All vehicles
    /// returned will have a `maximum_capacity` greater than or equal to this
    /// value. If set, must be greater or equal to 0.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int? MinimumCapacity {
      get { return minimumCapacity_; }
      set {
        minimumCapacity_ = value;
      }
    }


    /// <summary>Field number for the "trip_types" field.</summary>
    public const int TripTypesFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Google.Maps.FleetEngine.V1.TripType> _repeated_tripTypes_codec
        = pb::FieldCodec.ForEnum(58, x => (int) x, x => (global::Google.Maps.FleetEngine.V1.TripType) x);
    private readonly pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.TripType> tripTypes_ = new pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.TripType>();
    /// <summary>
    /// Restricts the response to vehicles that support at least one of the
    /// specified trip types.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.TripType> TripTypes {
      get { return tripTypes_; }
    }

    /// <summary>Field number for the "maximum_staleness" field.</summary>
    public const int MaximumStalenessFieldNumber = 8;
    private global::Google.Protobuf.WellKnownTypes.Duration maximumStaleness_;
    /// <summary>
    /// Restricts the response to vehicles that have sent location updates to Fleet
    /// Engine within the specified duration. Stationary vehicles still
    /// transmitting their locations are not considered stale. If present, must be
    /// a valid positive duration.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Duration MaximumStaleness {
      get { return maximumStaleness_; }
      set {
        maximumStaleness_ = value;
      }
    }

    /// <summary>Field number for the "vehicle_type_categories" field.</summary>
    public const int VehicleTypeCategoriesFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType.Types.Category> _repeated_vehicleTypeCategories_codec
        = pb::FieldCodec.ForEnum(74, x => (int) x, x => (global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType.Types.Category) x);
    private readonly pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType.Types.Category> vehicleTypeCategories_ = new pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType.Types.Category>();
    /// <summary>
    /// Required. Restricts the response to vehicles with one of the specified type
    /// categories. `UNKNOWN` is not allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.Vehicle.Types.VehicleType.Types.Category> VehicleTypeCategories {
      get { return vehicleTypeCategories_; }
    }

    /// <summary>Field number for the "required_attributes" field.</summary>
    public const int RequiredAttributesFieldNumber = 10;
    private static readonly pb::FieldCodec<string> _repeated_requiredAttributes_codec
        = pb::FieldCodec.ForString(82);
    private readonly pbc::RepeatedField<string> requiredAttributes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Callers can form complex logical operations using any combination of the
    /// `required_attributes`, `required_one_of_attributes`, and
    /// `required_one_of_attribute_sets` fields.
    ///
    /// `required_attributes` is a list; `required_one_of_attributes` uses a
    /// message which allows a list of lists. In combination, the two fields allow
    /// the composition of this expression:
    ///
    /// ```
    /// (required_attributes[0] AND required_attributes[1] AND ...)
    /// AND
    /// (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
    /// ...)
    /// AND
    /// (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
    /// ...)
    /// ```
    ///
    /// Restricts the response to vehicles with the specified attributes. This
    /// field is a conjunction/AND operation. A max of 50 required_attributes is
    /// allowed. This matches the maximum number of attributes allowed on a
    /// vehicle. Each repeated string should be of the format "key:value".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> RequiredAttributes {
      get { return requiredAttributes_; }
    }

    /// <summary>Field number for the "required_one_of_attributes" field.</summary>
    public const int RequiredOneOfAttributesFieldNumber = 13;
    private static readonly pb::FieldCodec<string> _repeated_requiredOneOfAttributes_codec
        = pb::FieldCodec.ForString(106);
    private readonly pbc::RepeatedField<string> requiredOneOfAttributes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Restricts the response to vehicles with at least one of the specified
    /// attributes in each `VehicleAttributeList`. Within each list, a vehicle must
    /// match at least one of the attributes. This field is an inclusive
    /// disjunction/OR operation in each `VehicleAttributeList` and a
    /// conjunction/AND operation across the collection of `VehicleAttributeList`.
    /// Each repeated string should be of the format
    /// "key1:value1|key2:value2|key3:value3".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> RequiredOneOfAttributes {
      get { return requiredOneOfAttributes_; }
    }

    /// <summary>Field number for the "required_one_of_attribute_sets" field.</summary>
    public const int RequiredOneOfAttributeSetsFieldNumber = 15;
    private static readonly pb::FieldCodec<string> _repeated_requiredOneOfAttributeSets_codec
        = pb::FieldCodec.ForString(122);
    private readonly pbc::RepeatedField<string> requiredOneOfAttributeSets_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// `required_one_of_attribute_sets` provides additional functionality.
    ///
    /// Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
    /// uses a message which allows a list of lists, allowing expressions such as
    /// this one:
    ///
    /// ```
    /// (required_attributes[0] AND required_attributes[1] AND ...)
    /// AND
    /// (
    ///   (required_one_of_attribute_sets[0][0] AND
    ///   required_one_of_attribute_sets[0][1] AND
    ///   ...)
    ///   OR
    ///   (required_one_of_attribute_sets[1][0] AND
    ///   required_one_of_attribute_sets[1][1] AND
    ///   ...)
    /// )
    /// ```
    ///
    /// Restricts the response to vehicles that match all the attributes in a
    /// `VehicleAttributeList`. Within each list, a vehicle must match all of the
    /// attributes. This field is a conjunction/AND operation in each
    /// `VehicleAttributeList` and inclusive disjunction/OR operation across the
    /// collection of `VehicleAttributeList`. Each repeated string should be of the
    /// format "key1:value1|key2:value2|key3:value3".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> RequiredOneOfAttributeSets {
      get { return requiredOneOfAttributeSets_; }
    }

    /// <summary>Field number for the "vehicle_state" field.</summary>
    public const int VehicleStateFieldNumber = 11;
    private global::Google.Maps.FleetEngine.V1.VehicleState vehicleState_ = global::Google.Maps.FleetEngine.V1.VehicleState.UnknownVehicleState;
    /// <summary>
    /// Restricts the response to vehicles that have this vehicle state.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.VehicleState VehicleState {
      get { return vehicleState_; }
      set {
        vehicleState_ = value;
      }
    }

    /// <summary>Field number for the "on_trip_only" field.</summary>
    public const int OnTripOnlyFieldNumber = 14;
    private bool onTripOnly_;
    /// <summary>
    /// Only return the vehicles with current trip(s).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool OnTripOnly {
      get { return onTripOnly_; }
      set {
        onTripOnly_ = value;
      }
    }

    /// <summary>Field number for the "filter" field.</summary>
    public const int FilterFieldNumber = 16;
    private string filter_ = "";
    /// <summary>
    /// Optional. A filter query to apply when listing vehicles. See
    /// http://aip.dev/160 for examples of the filter syntax.
    ///
    /// This field is designed to replace the `required_attributes`,
    /// `required_one_of_attributes`, and `required_one_of_attributes_sets` fields.
    /// If a non-empty value is specified here, the following fields must be empty:
    /// `required_attributes`, `required_one_of_attributes`, and
    /// `required_one_of_attributes_sets`.
    ///
    /// This filter functions as an AND clause with other constraints,
    /// such as `vehicle_state` or `on_trip_only`.
    ///
    /// Note that the only queries supported are on vehicle attributes (for
    /// example, `attributes.&lt;key> = &lt;value>` or `attributes.&lt;key1> = &lt;value1> AND
    /// attributes.&lt;key2> = &lt;value2>`). The maximum number of restrictions allowed
    /// in a filter query is 50.
    ///
    /// Also, all attributes are stored as strings, so the only supported
    /// comparisons against attributes are string comparisons. In order to compare
    /// against number or boolean values, the values must be explicitly quoted to
    /// be treated as strings (for example, `attributes.&lt;key> = "10"` or
    /// `attributes.&lt;key> = "true"`).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Filter {
      get { return filter_; }
      set {
        filter_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "viewport" field.</summary>
    public const int ViewportFieldNumber = 17;
    private global::Google.Geo.Type.Viewport viewport_;
    /// <summary>
    /// Optional. A filter that limits the vehicles returned to those whose last
    /// known location was in the rectangular area defined by the viewport.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Geo.Type.Viewport Viewport {
      get { return viewport_; }
      set {
        viewport_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ListVehiclesRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ListVehiclesRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Header, other.Header)) return false;
      if (Parent != other.Parent) return false;
      if (PageSize != other.PageSize) return false;
      if (PageToken != other.PageToken) return false;
      if (MinimumCapacity != other.MinimumCapacity) return false;
      if(!tripTypes_.Equals(other.tripTypes_)) return false;
      if (!object.Equals(MaximumStaleness, other.MaximumStaleness)) return false;
      if(!vehicleTypeCategories_.Equals(other.vehicleTypeCategories_)) return false;
      if(!requiredAttributes_.Equals(other.requiredAttributes_)) return false;
      if(!requiredOneOfAttributes_.Equals(other.requiredOneOfAttributes_)) return false;
      if(!requiredOneOfAttributeSets_.Equals(other.requiredOneOfAttributeSets_)) return false;
      if (VehicleState != other.VehicleState) return false;
      if (OnTripOnly != other.OnTripOnly) return false;
      if (Filter != other.Filter) return false;
      if (!object.Equals(Viewport, other.Viewport)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (header_ != null) hash ^= Header.GetHashCode();
      if (Parent.Length != 0) hash ^= Parent.GetHashCode();
      if (PageSize != 0) hash ^= PageSize.GetHashCode();
      if (PageToken.Length != 0) hash ^= PageToken.GetHashCode();
      if (minimumCapacity_ != null) hash ^= MinimumCapacity.GetHashCode();
      hash ^= tripTypes_.GetHashCode();
      if (maximumStaleness_ != null) hash ^= MaximumStaleness.GetHashCode();
      hash ^= vehicleTypeCategories_.GetHashCode();
      hash ^= requiredAttributes_.GetHashCode();
      hash ^= requiredOneOfAttributes_.GetHashCode();
      hash ^= requiredOneOfAttributeSets_.GetHashCode();
      if (VehicleState != global::Google.Maps.FleetEngine.V1.VehicleState.UnknownVehicleState) hash ^= VehicleState.GetHashCode();
      if (OnTripOnly != false) hash ^= OnTripOnly.GetHashCode();
      if (Filter.Length != 0) hash ^= Filter.GetHashCode();
      if (viewport_ != null) hash ^= Viewport.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Parent.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Parent);
      }
      if (PageSize != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(PageSize);
      }
      if (PageToken.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(PageToken);
      }
      if (minimumCapacity_ != null) {
        _single_minimumCapacity_codec.WriteTagAndValue(output, MinimumCapacity);
      }
      tripTypes_.WriteTo(output, _repeated_tripTypes_codec);
      if (maximumStaleness_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(MaximumStaleness);
      }
      vehicleTypeCategories_.WriteTo(output, _repeated_vehicleTypeCategories_codec);
      requiredAttributes_.WriteTo(output, _repeated_requiredAttributes_codec);
      if (VehicleState != global::Google.Maps.FleetEngine.V1.VehicleState.UnknownVehicleState) {
        output.WriteRawTag(88);
        output.WriteEnum((int) VehicleState);
      }
      if (header_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Header);
      }
      requiredOneOfAttributes_.WriteTo(output, _repeated_requiredOneOfAttributes_codec);
      if (OnTripOnly != false) {
        output.WriteRawTag(112);
        output.WriteBool(OnTripOnly);
      }
      requiredOneOfAttributeSets_.WriteTo(output, _repeated_requiredOneOfAttributeSets_codec);
      if (Filter.Length != 0) {
        output.WriteRawTag(130, 1);
        output.WriteString(Filter);
      }
      if (viewport_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(Viewport);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Parent.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Parent);
      }
      if (PageSize != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(PageSize);
      }
      if (PageToken.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(PageToken);
      }
      if (minimumCapacity_ != null) {
        _single_minimumCapacity_codec.WriteTagAndValue(ref output, MinimumCapacity);
      }
      tripTypes_.WriteTo(ref output, _repeated_tripTypes_codec);
      if (maximumStaleness_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(MaximumStaleness);
      }
      vehicleTypeCategories_.WriteTo(ref output, _repeated_vehicleTypeCategories_codec);
      requiredAttributes_.WriteTo(ref output, _repeated_requiredAttributes_codec);
      if (VehicleState != global::Google.Maps.FleetEngine.V1.VehicleState.UnknownVehicleState) {
        output.WriteRawTag(88);
        output.WriteEnum((int) VehicleState);
      }
      if (header_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Header);
      }
      requiredOneOfAttributes_.WriteTo(ref output, _repeated_requiredOneOfAttributes_codec);
      if (OnTripOnly != false) {
        output.WriteRawTag(112);
        output.WriteBool(OnTripOnly);
      }
      requiredOneOfAttributeSets_.WriteTo(ref output, _repeated_requiredOneOfAttributeSets_codec);
      if (Filter.Length != 0) {
        output.WriteRawTag(130, 1);
        output.WriteString(Filter);
      }
      if (viewport_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(Viewport);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (header_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (Parent.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Parent);
      }
      if (PageSize != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(PageSize);
      }
      if (PageToken.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PageToken);
      }
      if (minimumCapacity_ != null) {
        size += _single_minimumCapacity_codec.CalculateSizeWithTag(MinimumCapacity);
      }
      size += tripTypes_.CalculateSize(_repeated_tripTypes_codec);
      if (maximumStaleness_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaximumStaleness);
      }
      size += vehicleTypeCategories_.CalculateSize(_repeated_vehicleTypeCategories_codec);
      size += requiredAttributes_.CalculateSize(_repeated_requiredAttributes_codec);
      size += requiredOneOfAttributes_.CalculateSize(_repeated_requiredOneOfAttributes_codec);
      size += requiredOneOfAttributeSets_.CalculateSize(_repeated_requiredOneOfAttributeSets_codec);
      if (VehicleState != global::Google.Maps.FleetEngine.V1.VehicleState.UnknownVehicleState) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) VehicleState);
      }
      if (OnTripOnly != false) {
        size += 1 + 1;
      }
      if (Filter.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Filter);
      }
      if (viewport_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Viewport);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ListVehiclesRequest other) {
      if (other == null) {
        return;
      }
      if (other.header_ != null) {
        if (header_ == null) {
          Header = new global::Google.Maps.FleetEngine.V1.RequestHeader();
        }
        Header.MergeFrom(other.Header);
      }
      if (other.Parent.Length != 0) {
        Parent = other.Parent;
      }
      if (other.PageSize != 0) {
        PageSize = other.PageSize;
      }
      if (other.PageToken.Length != 0) {
        PageToken = other.PageToken;
      }
      if (other.minimumCapacity_ != null) {
        if (minimumCapacity_ == null || other.MinimumCapacity != 0) {
          MinimumCapacity = other.MinimumCapacity;
        }
      }
      tripTypes_.Add(other.tripTypes_);
      if (other.maximumStaleness_ != null) {
        if (maximumStaleness_ == null) {
          MaximumStaleness = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        MaximumStaleness.MergeFrom(other.MaximumStaleness);
      }
      vehicleTypeCategories_.Add(other.vehicleTypeCategories_);
      requiredAttributes_.Add(other.requiredAttributes_);
      requiredOneOfAttributes_.Add(other.requiredOneOfAttributes_);
      requiredOneOfAttributeSets_.Add(other.requiredOneOfAttributeSets_);
      if (other.VehicleState != global::Google.Maps.FleetEngine.V1.VehicleState.UnknownVehicleState) {
        VehicleState = other.VehicleState;
      }
      if (other.OnTripOnly != false) {
        OnTripOnly = other.OnTripOnly;
      }
      if (other.Filter.Length != 0) {
        Filter = other.Filter;
      }
      if (other.viewport_ != null) {
        if (viewport_ == null) {
          Viewport = new global::Google.Geo.Type.Viewport();
        }
        Viewport.MergeFrom(other.Viewport);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Parent = input.ReadString();
            break;
          }
          case 24: {
            PageSize = input.ReadInt32();
            break;
          }
          case 34: {
            PageToken = input.ReadString();
            break;
          }
          case 50: {
            int? value = _single_minimumCapacity_codec.Read(input);
            if (minimumCapacity_ == null || value != 0) {
              MinimumCapacity = value;
            }
            break;
          }
          case 58:
          case 56: {
            tripTypes_.AddEntriesFrom(input, _repeated_tripTypes_codec);
            break;
          }
          case 66: {
            if (maximumStaleness_ == null) {
              MaximumStaleness = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(MaximumStaleness);
            break;
          }
          case 74:
          case 72: {
            vehicleTypeCategories_.AddEntriesFrom(input, _repeated_vehicleTypeCategories_codec);
            break;
          }
          case 82: {
            requiredAttributes_.AddEntriesFrom(input, _repeated_requiredAttributes_codec);
            break;
          }
          case 88: {
            VehicleState = (global::Google.Maps.FleetEngine.V1.VehicleState) input.ReadEnum();
            break;
          }
          case 98: {
            if (header_ == null) {
              Header = new global::Google.Maps.FleetEngine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 106: {
            requiredOneOfAttributes_.AddEntriesFrom(input, _repeated_requiredOneOfAttributes_codec);
            break;
          }
          case 112: {
            OnTripOnly = input.ReadBool();
            break;
          }
          case 122: {
            requiredOneOfAttributeSets_.AddEntriesFrom(input, _repeated_requiredOneOfAttributeSets_codec);
            break;
          }
          case 130: {
            Filter = input.ReadString();
            break;
          }
          case 138: {
            if (viewport_ == null) {
              Viewport = new global::Google.Geo.Type.Viewport();
            }
            input.ReadMessage(Viewport);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Parent = input.ReadString();
            break;
          }
          case 24: {
            PageSize = input.ReadInt32();
            break;
          }
          case 34: {
            PageToken = input.ReadString();
            break;
          }
          case 50: {
            int? value = _single_minimumCapacity_codec.Read(ref input);
            if (minimumCapacity_ == null || value != 0) {
              MinimumCapacity = value;
            }
            break;
          }
          case 58:
          case 56: {
            tripTypes_.AddEntriesFrom(ref input, _repeated_tripTypes_codec);
            break;
          }
          case 66: {
            if (maximumStaleness_ == null) {
              MaximumStaleness = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(MaximumStaleness);
            break;
          }
          case 74:
          case 72: {
            vehicleTypeCategories_.AddEntriesFrom(ref input, _repeated_vehicleTypeCategories_codec);
            break;
          }
          case 82: {
            requiredAttributes_.AddEntriesFrom(ref input, _repeated_requiredAttributes_codec);
            break;
          }
          case 88: {
            VehicleState = (global::Google.Maps.FleetEngine.V1.VehicleState) input.ReadEnum();
            break;
          }
          case 98: {
            if (header_ == null) {
              Header = new global::Google.Maps.FleetEngine.V1.RequestHeader();
            }
            input.ReadMessage(Header);
            break;
          }
          case 106: {
            requiredOneOfAttributes_.AddEntriesFrom(ref input, _repeated_requiredOneOfAttributes_codec);
            break;
          }
          case 112: {
            OnTripOnly = input.ReadBool();
            break;
          }
          case 122: {
            requiredOneOfAttributeSets_.AddEntriesFrom(ref input, _repeated_requiredOneOfAttributeSets_codec);
            break;
          }
          case 130: {
            Filter = input.ReadString();
            break;
          }
          case 138: {
            if (viewport_ == null) {
              Viewport = new global::Google.Geo.Type.Viewport();
            }
            input.ReadMessage(Viewport);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// `ListVehicles` response message.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ListVehiclesResponse : pb::IMessage<ListVehiclesResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ListVehiclesResponse> _parser = new pb::MessageParser<ListVehiclesResponse>(() => new ListVehiclesResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ListVehiclesResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.FleetEngine.V1.VehicleApiReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ListVehiclesResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ListVehiclesResponse(ListVehiclesResponse other) : this() {
      vehicles_ = other.vehicles_.Clone();
      nextPageToken_ = other.nextPageToken_;
      totalSize_ = other.totalSize_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ListVehiclesResponse Clone() {
      return new ListVehiclesResponse(this);
    }

    /// <summary>Field number for the "vehicles" field.</summary>
    public const int VehiclesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Maps.FleetEngine.V1.Vehicle> _repeated_vehicles_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Maps.FleetEngine.V1.Vehicle.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.Vehicle> vehicles_ = new pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.Vehicle>();
    /// <summary>
    /// Vehicles matching the criteria in the request.
    /// The maximum number of vehicles returned is determined by the `page_size`
    /// field in the request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.Vehicle> Vehicles {
      get { return vehicles_; }
    }

    /// <summary>Field number for the "next_page_token" field.</summary>
    public const int NextPageTokenFieldNumber = 2;
    private string nextPageToken_ = "";
    /// <summary>
    /// Token to retrieve the next page of vehicles, or empty if there are no
    /// more vehicles that meet the request criteria.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string NextPageToken {
      get { return nextPageToken_; }
      set {
        nextPageToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "total_size" field.</summary>
    public const int TotalSizeFieldNumber = 3;
    private long totalSize_;
    /// <summary>
    /// Required. Total number of vehicles matching the request criteria across all
    /// pages.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long TotalSize {
      get { return totalSize_; }
      set {
        totalSize_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ListVehiclesResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ListVehiclesResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!vehicles_.Equals(other.vehicles_)) return false;
      if (NextPageToken != other.NextPageToken) return false;
      if (TotalSize != other.TotalSize) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= vehicles_.GetHashCode();
      if (NextPageToken.Length != 0) hash ^= NextPageToken.GetHashCode();
      if (TotalSize != 0L) hash ^= TotalSize.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      vehicles_.WriteTo(output, _repeated_vehicles_codec);
      if (NextPageToken.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(NextPageToken);
      }
      if (TotalSize != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TotalSize);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      vehicles_.WriteTo(ref output, _repeated_vehicles_codec);
      if (NextPageToken.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(NextPageToken);
      }
      if (TotalSize != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TotalSize);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += vehicles_.CalculateSize(_repeated_vehicles_codec);
      if (NextPageToken.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NextPageToken);
      }
      if (TotalSize != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TotalSize);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ListVehiclesResponse other) {
      if (other == null) {
        return;
      }
      vehicles_.Add(other.vehicles_);
      if (other.NextPageToken.Length != 0) {
        NextPageToken = other.NextPageToken;
      }
      if (other.TotalSize != 0L) {
        TotalSize = other.TotalSize;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            vehicles_.AddEntriesFrom(input, _repeated_vehicles_codec);
            break;
          }
          case 18: {
            NextPageToken = input.ReadString();
            break;
          }
          case 24: {
            TotalSize = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            vehicles_.AddEntriesFrom(ref input, _repeated_vehicles_codec);
            break;
          }
          case 18: {
            NextPageToken = input.ReadString();
            break;
          }
          case 24: {
            TotalSize = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Describes intermediate points along a route for a `VehicleMatch` in a
  /// `SearchVehiclesResponse`. This concept is represented as a `TripWaypoint` in
  /// all other endpoints.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Waypoint : pb::IMessage<Waypoint>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Waypoint> _parser = new pb::MessageParser<Waypoint>(() => new Waypoint());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Waypoint> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.FleetEngine.V1.VehicleApiReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Waypoint() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Waypoint(Waypoint other) : this() {
      latLng_ = other.latLng_ != null ? other.latLng_.Clone() : null;
      eta_ = other.eta_ != null ? other.eta_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Waypoint Clone() {
      return new Waypoint(this);
    }

    /// <summary>Field number for the "lat_lng" field.</summary>
    public const int LatLngFieldNumber = 1;
    private global::Google.Type.LatLng latLng_;
    /// <summary>
    /// The location of this waypoint.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Type.LatLng LatLng {
      get { return latLng_; }
      set {
        latLng_ = value;
      }
    }

    /// <summary>Field number for the "eta" field.</summary>
    public const int EtaFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Timestamp eta_;
    /// <summary>
    /// The estimated time that the vehicle will arrive at this waypoint.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp Eta {
      get { return eta_; }
      set {
        eta_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Waypoint);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Waypoint other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(LatLng, other.LatLng)) return false;
      if (!object.Equals(Eta, other.Eta)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (latLng_ != null) hash ^= LatLng.GetHashCode();
      if (eta_ != null) hash ^= Eta.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (latLng_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LatLng);
      }
      if (eta_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Eta);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (latLng_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LatLng);
      }
      if (eta_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Eta);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (latLng_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LatLng);
      }
      if (eta_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Eta);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Waypoint other) {
      if (other == null) {
        return;
      }
      if (other.latLng_ != null) {
        if (latLng_ == null) {
          LatLng = new global::Google.Type.LatLng();
        }
        LatLng.MergeFrom(other.LatLng);
      }
      if (other.eta_ != null) {
        if (eta_ == null) {
          Eta = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        Eta.MergeFrom(other.Eta);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (latLng_ == null) {
              LatLng = new global::Google.Type.LatLng();
            }
            input.ReadMessage(LatLng);
            break;
          }
          case 18: {
            if (eta_ == null) {
              Eta = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Eta);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (latLng_ == null) {
              LatLng = new global::Google.Type.LatLng();
            }
            input.ReadMessage(LatLng);
            break;
          }
          case 18: {
            if (eta_ == null) {
              Eta = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Eta);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Contains the vehicle and related estimates for a vehicle that match the
  /// points of active trips for the vehicle `SearchVehiclesRequest`.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class VehicleMatch : pb::IMessage<VehicleMatch>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<VehicleMatch> _parser = new pb::MessageParser<VehicleMatch>(() => new VehicleMatch());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<VehicleMatch> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.FleetEngine.V1.VehicleApiReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VehicleMatch() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VehicleMatch(VehicleMatch other) : this() {
      vehicle_ = other.vehicle_ != null ? other.vehicle_.Clone() : null;
      vehiclePickupEta_ = other.vehiclePickupEta_ != null ? other.vehiclePickupEta_.Clone() : null;
      VehiclePickupDistanceMeters = other.VehiclePickupDistanceMeters;
      VehiclePickupStraightLineDistanceMeters = other.VehiclePickupStraightLineDistanceMeters;
      vehicleDropoffEta_ = other.vehicleDropoffEta_ != null ? other.vehicleDropoffEta_.Clone() : null;
      VehiclePickupToDropoffDistanceMeters = other.VehiclePickupToDropoffDistanceMeters;
      tripType_ = other.tripType_;
      vehicleTripsWaypoints_ = other.vehicleTripsWaypoints_.Clone();
      vehicleMatchType_ = other.vehicleMatchType_;
      requestedOrderedBy_ = other.requestedOrderedBy_;
      orderedBy_ = other.orderedBy_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VehicleMatch Clone() {
      return new VehicleMatch(this);
    }

    /// <summary>Field number for the "vehicle" field.</summary>
    public const int VehicleFieldNumber = 1;
    private global::Google.Maps.FleetEngine.V1.Vehicle vehicle_;
    /// <summary>
    /// Required. A vehicle that matches the request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.Vehicle Vehicle {
      get { return vehicle_; }
      set {
        vehicle_ = value;
      }
    }

    /// <summary>Field number for the "vehicle_pickup_eta" field.</summary>
    public const int VehiclePickupEtaFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Timestamp vehiclePickupEta_;
    /// <summary>
    /// The vehicle's driving ETA to the pickup point specified in the
    /// request. An empty value indicates a failure in calculating ETA for the
    /// vehicle.  If `SearchVehiclesRequest.include_back_to_back` was `true` and
    /// this vehicle has an active trip, `vehicle_pickup_eta` includes the time
    /// required to complete the current active trip.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp VehiclePickupEta {
      get { return vehiclePickupEta_; }
      set {
        vehiclePickupEta_ = value;
      }
    }

    /// <summary>Field number for the "vehicle_pickup_distance_meters" field.</summary>
    public const int VehiclePickupDistanceMetersFieldNumber = 3;
    private static readonly pb::FieldCodec<int?> _single_vehiclePickupDistanceMeters_codec = pb::FieldCodec.ForStructWrapper<int>(26);
    private int? vehiclePickupDistanceMeters_;
    /// <summary>
    /// The distance from the Vehicle's current location to the pickup point
    /// specified in the request, including any intermediate pickup or dropoff
    /// points for existing trips. This distance comprises the calculated driving
    /// (route) distance, plus the straight line distance between the navigation
    /// end point and the requested pickup point. (The distance between the
    /// navigation end point and the requested pickup point is typically small.) An
    /// empty value indicates an error in calculating the distance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int? VehiclePickupDistanceMeters {
      get { return vehiclePickupDistanceMeters_; }
      set {
        vehiclePickupDistanceMeters_ = value;
      }
    }


    /// <summary>Field number for the "vehicle_pickup_straight_line_distance_meters" field.</summary>
    public const int VehiclePickupStraightLineDistanceMetersFieldNumber = 11;
    private static readonly pb::FieldCodec<int?> _single_vehiclePickupStraightLineDistanceMeters_codec = pb::FieldCodec.ForStructWrapper<int>(90);
    private int? vehiclePickupStraightLineDistanceMeters_;
    /// <summary>
    /// Required. The straight-line distance between the vehicle and the pickup
    /// point specified in the request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int? VehiclePickupStraightLineDistanceMeters {
      get { return vehiclePickupStraightLineDistanceMeters_; }
      set {
        vehiclePickupStraightLineDistanceMeters_ = value;
      }
    }


    /// <summary>Field number for the "vehicle_dropoff_eta" field.</summary>
    public const int VehicleDropoffEtaFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Timestamp vehicleDropoffEta_;
    /// <summary>
    /// The complete vehicle's driving ETA to the drop off point specified in the
    /// request. The ETA includes stopping at any waypoints before the
    /// `dropoff_point` specified in the request. The value will only be populated
    /// when a drop off point is specified in the request. An empty value indicates
    /// an error calculating the ETA.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Protobuf.WellKnownTypes.Timestamp VehicleDropoffEta {
      get { return vehicleDropoffEta_; }
      set {
        vehicleDropoffEta_ = value;
      }
    }

    /// <summary>Field number for the "vehicle_pickup_to_dropoff_distance_meters" field.</summary>
    public const int VehiclePickupToDropoffDistanceMetersFieldNumber = 5;
    private static readonly pb::FieldCodec<int?> _single_vehiclePickupToDropoffDistanceMeters_codec = pb::FieldCodec.ForStructWrapper<int>(42);
    private int? vehiclePickupToDropoffDistanceMeters_;
    /// <summary>
    /// The vehicle's driving distance (in meters) from the pickup point
    /// to the drop off point specified in the request. The distance is only
    /// between the two points and does not include the vehicle location or any
    /// other points that must be visited before the vehicle visits either the
    /// pickup point or dropoff point. The value will only be populated when a
    /// `dropoff_point` is specified in the request. An empty value indicates
    /// a failure in calculating the distance from the pickup to
    /// drop off point specified in the request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int? VehiclePickupToDropoffDistanceMeters {
      get { return vehiclePickupToDropoffDistanceMeters_; }
      set {
        vehiclePickupToDropoffDistanceMeters_ = value;
      }
    }


    /// <summary>Field number for the "trip_type" field.</summary>
    public const int TripTypeFieldNumber = 6;
    private global::Google.Maps.FleetEngine.V1.TripType tripType_ = global::Google.Maps.FleetEngine.V1.TripType.UnknownTripType;
    /// <summary>
    /// Required. The trip type of the request that was used to calculate the ETA
    /// to the pickup point.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.TripType TripType {
      get { return tripType_; }
      set {
        tripType_ = value;
      }
    }

    /// <summary>Field number for the "vehicle_trips_waypoints" field.</summary>
    public const int VehicleTripsWaypointsFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Google.Maps.FleetEngine.V1.Waypoint> _repeated_vehicleTripsWaypoints_codec
        = pb::FieldCodec.ForMessage(58, global::Google.Maps.FleetEngine.V1.Waypoint.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.Waypoint> vehicleTripsWaypoints_ = new pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.Waypoint>();
    /// <summary>
    /// The ordered list of waypoints used to calculate the ETA. The list
    /// includes vehicle location, the pickup points of active
    /// trips for the vehicle, and the pickup points provided in the
    /// request. An empty list indicates a failure in calculating ETA for the
    /// vehicle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.Waypoint> VehicleTripsWaypoints {
      get { return vehicleTripsWaypoints_; }
    }

    /// <summary>Field number for the "vehicle_match_type" field.</summary>
    public const int VehicleMatchTypeFieldNumber = 8;
    private global::Google.Maps.FleetEngine.V1.VehicleMatch.Types.VehicleMatchType vehicleMatchType_ = global::Google.Maps.FleetEngine.V1.VehicleMatch.Types.VehicleMatchType.Unknown;
    /// <summary>
    /// Type of the vehicle match.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.VehicleMatch.Types.VehicleMatchType VehicleMatchType {
      get { return vehicleMatchType_; }
      set {
        vehicleMatchType_ = value;
      }
    }

    /// <summary>Field number for the "requested_ordered_by" field.</summary>
    public const int RequestedOrderedByFieldNumber = 9;
    private global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder requestedOrderedBy_ = global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder;
    /// <summary>
    /// The order requested for sorting vehicle matches. Equivalent to
    /// `ordered_by`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder RequestedOrderedBy {
      get { return requestedOrderedBy_; }
      set {
        requestedOrderedBy_ = value;
      }
    }

    /// <summary>Field number for the "ordered_by" field.</summary>
    public const int OrderedByFieldNumber = 10;
    private global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder orderedBy_ = global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder;
    /// <summary>
    /// The order requested for sorting vehicle matches. Equivalent to
    /// `requested_ordered_by`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder OrderedBy {
      get { return orderedBy_; }
      set {
        orderedBy_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as VehicleMatch);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(VehicleMatch other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Vehicle, other.Vehicle)) return false;
      if (!object.Equals(VehiclePickupEta, other.VehiclePickupEta)) return false;
      if (VehiclePickupDistanceMeters != other.VehiclePickupDistanceMeters) return false;
      if (VehiclePickupStraightLineDistanceMeters != other.VehiclePickupStraightLineDistanceMeters) return false;
      if (!object.Equals(VehicleDropoffEta, other.VehicleDropoffEta)) return false;
      if (VehiclePickupToDropoffDistanceMeters != other.VehiclePickupToDropoffDistanceMeters) return false;
      if (TripType != other.TripType) return false;
      if(!vehicleTripsWaypoints_.Equals(other.vehicleTripsWaypoints_)) return false;
      if (VehicleMatchType != other.VehicleMatchType) return false;
      if (RequestedOrderedBy != other.RequestedOrderedBy) return false;
      if (OrderedBy != other.OrderedBy) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (vehicle_ != null) hash ^= Vehicle.GetHashCode();
      if (vehiclePickupEta_ != null) hash ^= VehiclePickupEta.GetHashCode();
      if (vehiclePickupDistanceMeters_ != null) hash ^= VehiclePickupDistanceMeters.GetHashCode();
      if (vehiclePickupStraightLineDistanceMeters_ != null) hash ^= VehiclePickupStraightLineDistanceMeters.GetHashCode();
      if (vehicleDropoffEta_ != null) hash ^= VehicleDropoffEta.GetHashCode();
      if (vehiclePickupToDropoffDistanceMeters_ != null) hash ^= VehiclePickupToDropoffDistanceMeters.GetHashCode();
      if (TripType != global::Google.Maps.FleetEngine.V1.TripType.UnknownTripType) hash ^= TripType.GetHashCode();
      hash ^= vehicleTripsWaypoints_.GetHashCode();
      if (VehicleMatchType != global::Google.Maps.FleetEngine.V1.VehicleMatch.Types.VehicleMatchType.Unknown) hash ^= VehicleMatchType.GetHashCode();
      if (RequestedOrderedBy != global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) hash ^= RequestedOrderedBy.GetHashCode();
      if (OrderedBy != global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) hash ^= OrderedBy.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (vehicle_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Vehicle);
      }
      if (vehiclePickupEta_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(VehiclePickupEta);
      }
      if (vehiclePickupDistanceMeters_ != null) {
        _single_vehiclePickupDistanceMeters_codec.WriteTagAndValue(output, VehiclePickupDistanceMeters);
      }
      if (vehicleDropoffEta_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(VehicleDropoffEta);
      }
      if (vehiclePickupToDropoffDistanceMeters_ != null) {
        _single_vehiclePickupToDropoffDistanceMeters_codec.WriteTagAndValue(output, VehiclePickupToDropoffDistanceMeters);
      }
      if (TripType != global::Google.Maps.FleetEngine.V1.TripType.UnknownTripType) {
        output.WriteRawTag(48);
        output.WriteEnum((int) TripType);
      }
      vehicleTripsWaypoints_.WriteTo(output, _repeated_vehicleTripsWaypoints_codec);
      if (VehicleMatchType != global::Google.Maps.FleetEngine.V1.VehicleMatch.Types.VehicleMatchType.Unknown) {
        output.WriteRawTag(64);
        output.WriteEnum((int) VehicleMatchType);
      }
      if (RequestedOrderedBy != global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        output.WriteRawTag(72);
        output.WriteEnum((int) RequestedOrderedBy);
      }
      if (OrderedBy != global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        output.WriteRawTag(80);
        output.WriteEnum((int) OrderedBy);
      }
      if (vehiclePickupStraightLineDistanceMeters_ != null) {
        _single_vehiclePickupStraightLineDistanceMeters_codec.WriteTagAndValue(output, VehiclePickupStraightLineDistanceMeters);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (vehicle_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Vehicle);
      }
      if (vehiclePickupEta_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(VehiclePickupEta);
      }
      if (vehiclePickupDistanceMeters_ != null) {
        _single_vehiclePickupDistanceMeters_codec.WriteTagAndValue(ref output, VehiclePickupDistanceMeters);
      }
      if (vehicleDropoffEta_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(VehicleDropoffEta);
      }
      if (vehiclePickupToDropoffDistanceMeters_ != null) {
        _single_vehiclePickupToDropoffDistanceMeters_codec.WriteTagAndValue(ref output, VehiclePickupToDropoffDistanceMeters);
      }
      if (TripType != global::Google.Maps.FleetEngine.V1.TripType.UnknownTripType) {
        output.WriteRawTag(48);
        output.WriteEnum((int) TripType);
      }
      vehicleTripsWaypoints_.WriteTo(ref output, _repeated_vehicleTripsWaypoints_codec);
      if (VehicleMatchType != global::Google.Maps.FleetEngine.V1.VehicleMatch.Types.VehicleMatchType.Unknown) {
        output.WriteRawTag(64);
        output.WriteEnum((int) VehicleMatchType);
      }
      if (RequestedOrderedBy != global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        output.WriteRawTag(72);
        output.WriteEnum((int) RequestedOrderedBy);
      }
      if (OrderedBy != global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        output.WriteRawTag(80);
        output.WriteEnum((int) OrderedBy);
      }
      if (vehiclePickupStraightLineDistanceMeters_ != null) {
        _single_vehiclePickupStraightLineDistanceMeters_codec.WriteTagAndValue(ref output, VehiclePickupStraightLineDistanceMeters);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (vehicle_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Vehicle);
      }
      if (vehiclePickupEta_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VehiclePickupEta);
      }
      if (vehiclePickupDistanceMeters_ != null) {
        size += _single_vehiclePickupDistanceMeters_codec.CalculateSizeWithTag(VehiclePickupDistanceMeters);
      }
      if (vehiclePickupStraightLineDistanceMeters_ != null) {
        size += _single_vehiclePickupStraightLineDistanceMeters_codec.CalculateSizeWithTag(VehiclePickupStraightLineDistanceMeters);
      }
      if (vehicleDropoffEta_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VehicleDropoffEta);
      }
      if (vehiclePickupToDropoffDistanceMeters_ != null) {
        size += _single_vehiclePickupToDropoffDistanceMeters_codec.CalculateSizeWithTag(VehiclePickupToDropoffDistanceMeters);
      }
      if (TripType != global::Google.Maps.FleetEngine.V1.TripType.UnknownTripType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TripType);
      }
      size += vehicleTripsWaypoints_.CalculateSize(_repeated_vehicleTripsWaypoints_codec);
      if (VehicleMatchType != global::Google.Maps.FleetEngine.V1.VehicleMatch.Types.VehicleMatchType.Unknown) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) VehicleMatchType);
      }
      if (RequestedOrderedBy != global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RequestedOrderedBy);
      }
      if (OrderedBy != global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) OrderedBy);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(VehicleMatch other) {
      if (other == null) {
        return;
      }
      if (other.vehicle_ != null) {
        if (vehicle_ == null) {
          Vehicle = new global::Google.Maps.FleetEngine.V1.Vehicle();
        }
        Vehicle.MergeFrom(other.Vehicle);
      }
      if (other.vehiclePickupEta_ != null) {
        if (vehiclePickupEta_ == null) {
          VehiclePickupEta = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        VehiclePickupEta.MergeFrom(other.VehiclePickupEta);
      }
      if (other.vehiclePickupDistanceMeters_ != null) {
        if (vehiclePickupDistanceMeters_ == null || other.VehiclePickupDistanceMeters != 0) {
          VehiclePickupDistanceMeters = other.VehiclePickupDistanceMeters;
        }
      }
      if (other.vehiclePickupStraightLineDistanceMeters_ != null) {
        if (vehiclePickupStraightLineDistanceMeters_ == null || other.VehiclePickupStraightLineDistanceMeters != 0) {
          VehiclePickupStraightLineDistanceMeters = other.VehiclePickupStraightLineDistanceMeters;
        }
      }
      if (other.vehicleDropoffEta_ != null) {
        if (vehicleDropoffEta_ == null) {
          VehicleDropoffEta = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        VehicleDropoffEta.MergeFrom(other.VehicleDropoffEta);
      }
      if (other.vehiclePickupToDropoffDistanceMeters_ != null) {
        if (vehiclePickupToDropoffDistanceMeters_ == null || other.VehiclePickupToDropoffDistanceMeters != 0) {
          VehiclePickupToDropoffDistanceMeters = other.VehiclePickupToDropoffDistanceMeters;
        }
      }
      if (other.TripType != global::Google.Maps.FleetEngine.V1.TripType.UnknownTripType) {
        TripType = other.TripType;
      }
      vehicleTripsWaypoints_.Add(other.vehicleTripsWaypoints_);
      if (other.VehicleMatchType != global::Google.Maps.FleetEngine.V1.VehicleMatch.Types.VehicleMatchType.Unknown) {
        VehicleMatchType = other.VehicleMatchType;
      }
      if (other.RequestedOrderedBy != global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        RequestedOrderedBy = other.RequestedOrderedBy;
      }
      if (other.OrderedBy != global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder.UnknownVehicleMatchOrder) {
        OrderedBy = other.OrderedBy;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (vehicle_ == null) {
              Vehicle = new global::Google.Maps.FleetEngine.V1.Vehicle();
            }
            input.ReadMessage(Vehicle);
            break;
          }
          case 18: {
            if (vehiclePickupEta_ == null) {
              VehiclePickupEta = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(VehiclePickupEta);
            break;
          }
          case 26: {
            int? value = _single_vehiclePickupDistanceMeters_codec.Read(input);
            if (vehiclePickupDistanceMeters_ == null || value != 0) {
              VehiclePickupDistanceMeters = value;
            }
            break;
          }
          case 34: {
            if (vehicleDropoffEta_ == null) {
              VehicleDropoffEta = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(VehicleDropoffEta);
            break;
          }
          case 42: {
            int? value = _single_vehiclePickupToDropoffDistanceMeters_codec.Read(input);
            if (vehiclePickupToDropoffDistanceMeters_ == null || value != 0) {
              VehiclePickupToDropoffDistanceMeters = value;
            }
            break;
          }
          case 48: {
            TripType = (global::Google.Maps.FleetEngine.V1.TripType) input.ReadEnum();
            break;
          }
          case 58: {
            vehicleTripsWaypoints_.AddEntriesFrom(input, _repeated_vehicleTripsWaypoints_codec);
            break;
          }
          case 64: {
            VehicleMatchType = (global::Google.Maps.FleetEngine.V1.VehicleMatch.Types.VehicleMatchType) input.ReadEnum();
            break;
          }
          case 72: {
            RequestedOrderedBy = (global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder) input.ReadEnum();
            break;
          }
          case 80: {
            OrderedBy = (global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder) input.ReadEnum();
            break;
          }
          case 90: {
            int? value = _single_vehiclePickupStraightLineDistanceMeters_codec.Read(input);
            if (vehiclePickupStraightLineDistanceMeters_ == null || value != 0) {
              VehiclePickupStraightLineDistanceMeters = value;
            }
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (vehicle_ == null) {
              Vehicle = new global::Google.Maps.FleetEngine.V1.Vehicle();
            }
            input.ReadMessage(Vehicle);
            break;
          }
          case 18: {
            if (vehiclePickupEta_ == null) {
              VehiclePickupEta = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(VehiclePickupEta);
            break;
          }
          case 26: {
            int? value = _single_vehiclePickupDistanceMeters_codec.Read(ref input);
            if (vehiclePickupDistanceMeters_ == null || value != 0) {
              VehiclePickupDistanceMeters = value;
            }
            break;
          }
          case 34: {
            if (vehicleDropoffEta_ == null) {
              VehicleDropoffEta = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(VehicleDropoffEta);
            break;
          }
          case 42: {
            int? value = _single_vehiclePickupToDropoffDistanceMeters_codec.Read(ref input);
            if (vehiclePickupToDropoffDistanceMeters_ == null || value != 0) {
              VehiclePickupToDropoffDistanceMeters = value;
            }
            break;
          }
          case 48: {
            TripType = (global::Google.Maps.FleetEngine.V1.TripType) input.ReadEnum();
            break;
          }
          case 58: {
            vehicleTripsWaypoints_.AddEntriesFrom(ref input, _repeated_vehicleTripsWaypoints_codec);
            break;
          }
          case 64: {
            VehicleMatchType = (global::Google.Maps.FleetEngine.V1.VehicleMatch.Types.VehicleMatchType) input.ReadEnum();
            break;
          }
          case 72: {
            RequestedOrderedBy = (global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder) input.ReadEnum();
            break;
          }
          case 80: {
            OrderedBy = (global::Google.Maps.FleetEngine.V1.SearchVehiclesRequest.Types.VehicleMatchOrder) input.ReadEnum();
            break;
          }
          case 90: {
            int? value = _single_vehiclePickupStraightLineDistanceMeters_codec.Read(ref input);
            if (vehiclePickupStraightLineDistanceMeters_ == null || value != 0) {
              VehiclePickupStraightLineDistanceMeters = value;
            }
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the VehicleMatch message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Type of vehicle match.
      /// </summary>
      public enum VehicleMatchType {
        /// <summary>
        /// Unknown vehicle match type
        /// </summary>
        [pbr::OriginalName("UNKNOWN")] Unknown = 0,
        /// <summary>
        /// The vehicle currently has no trip assigned to it and can proceed to the
        /// pickup point.
        /// </summary>
        [pbr::OriginalName("EXCLUSIVE")] Exclusive = 1,
        /// <summary>
        /// The vehicle is currently assigned to a trip, but can proceed to the
        /// pickup point after completing the in-progress trip.  ETA and distance
        /// calculations take the existing trip into account.
        /// </summary>
        [pbr::OriginalName("BACK_TO_BACK")] BackToBack = 2,
        /// <summary>
        /// The vehicle has sufficient capacity for a shared ride.
        /// </summary>
        [pbr::OriginalName("CARPOOL")] Carpool = 3,
        /// <summary>
        /// The vehicle will finish its current, active trip before proceeding to the
        /// pickup point.  ETA and distance calculations take the existing trip into
        /// account.
        /// </summary>
        [pbr::OriginalName("CARPOOL_BACK_TO_BACK")] CarpoolBackToBack = 4,
      }

    }
    #endregion

  }

  /// <summary>
  /// A list-of-lists datatype for vehicle attributes.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class VehicleAttributeList : pb::IMessage<VehicleAttributeList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<VehicleAttributeList> _parser = new pb::MessageParser<VehicleAttributeList>(() => new VehicleAttributeList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<VehicleAttributeList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Maps.FleetEngine.V1.VehicleApiReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VehicleAttributeList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VehicleAttributeList(VehicleAttributeList other) : this() {
      attributes_ = other.attributes_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VehicleAttributeList Clone() {
      return new VehicleAttributeList(this);
    }

    /// <summary>Field number for the "attributes" field.</summary>
    public const int AttributesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Maps.FleetEngine.V1.VehicleAttribute> _repeated_attributes_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Maps.FleetEngine.V1.VehicleAttribute.Parser);
    private readonly pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleAttribute> attributes_ = new pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleAttribute>();
    /// <summary>
    /// A list of attributes in this collection.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Google.Maps.FleetEngine.V1.VehicleAttribute> Attributes {
      get { return attributes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as VehicleAttributeList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(VehicleAttributeList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!attributes_.Equals(other.attributes_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= attributes_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      attributes_.WriteTo(output, _repeated_attributes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      attributes_.WriteTo(ref output, _repeated_attributes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += attributes_.CalculateSize(_repeated_attributes_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(VehicleAttributeList other) {
      if (other == null) {
        return;
      }
      attributes_.Add(other.attributes_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            attributes_.AddEntriesFrom(input, _repeated_attributes_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            attributes_.AddEntriesFrom(ref input, _repeated_attributes_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
